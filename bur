#!/usr/bin/env python3
"""
Advanced Interactive Port Scanner v3.0
Professional Network Security Assessment Tool
"""

import socket
import sys
import time
import threading
import json
import csv
import os
import signal
import ipaddress
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
from enum import Enum
import platform
import subprocess
import re

# ASCII Banner
BANNER = """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                                        ‚ïë
‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    ‚ïë
‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó   ‚ïë
‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù   ‚ñà‚ñà‚ïë       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ïë
‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë       ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë   ‚ïë
‚ïë     ‚ñà‚ñà‚ïë     ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë   ‚ïë
‚ïë     ‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù       ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   ‚ïë
‚ïë                                                                        ‚ïë
‚ïë                    ADVANCED NETWORK SCANNER v3.0                      ‚ïë
‚ïë                  Professional Security Assessment Tool                ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""

class Color:
    """ANSI color codes for terminal output"""
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    DARKCYAN = '\033[36m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    END = '\033[0m'
    
    @staticmethod
    def print_success(msg):
        print(f"{Color.GREEN}‚úì {msg}{Color.END}")
    
    @staticmethod
    def print_error(msg):
        print(f"{Color.RED}‚úó {msg}{Color.END}")
    
    @staticmethod
    def print_warning(msg):
        print(f"{Color.YELLOW}‚ö† {msg}{Color.END}")
    
    @staticmethod
    def print_info(msg):
        print(f"{Color.CYAN}‚Ñπ {msg}{Color.END}")
    
    @staticmethod
    def print_header(msg):
        print(f"\n{Color.BOLD}{Color.PURPLE}{msg}{Color.END}")
        print("‚ïê" * len(msg))

class ScanProfile:
    """Predefined scan profiles for different use cases"""
    
    PROFILES = {
        "1": {
            "name": "Quick Scan",
            "description": "Fast scan of most common ports (Top 20)",
            "ports": [21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445, 993, 995, 1723, 3306, 3389, 5900, 8080],
            "threads": 50,
            "timeout": 1.0,
            "banner": False
        },
        "2": {
            "name": "Standard Scan", 
            "description": "Scan top 1000 most common ports",
            "ports": "top1000",
            "threads": 100,
            "timeout": 1.5,
            "banner": True
        },
        "3": {
            "name": "Comprehensive Scan",
            "description": "Scan ALL 65535 ports with service detection",
            "ports": "all",
            "threads": 500,
            "timeout": 1.0,
            "banner": True
        },
        "4": {
            "name": "Web Services",
            "description": "Focus on web-related ports",
            "ports": [80, 443, 8080, 8443, 8000, 8888, 3000, 5000, 9000, 9090, 9200],
            "threads": 50,
            "timeout": 2.0,
            "banner": True
        },
        "5": {
            "name": "Database Services",
            "description": "Focus on database ports",
            "ports": [1433, 1521, 3306, 5432, 5984, 6379, 7000, 7001, 8086, 9042, 27017, 28015],
            "threads": 50,
            "timeout": 2.0,
            "banner": True
        },
        "6": {
            "name": "Custom Scan",
            "description": "Define your own parameters",
            "ports": None,
            "threads": None,
            "timeout": None,
            "banner": None
        }
    }

class ServiceDatabase:
    """Enhanced service detection database"""
    
    SERVICES = {
        20: ("FTP-DATA", "File Transfer Protocol (Data)"),
        21: ("FTP", "File Transfer Protocol (Control)"),
        22: ("SSH", "Secure Shell"),
        23: ("Telnet", "Telnet Protocol"),
        25: ("SMTP", "Simple Mail Transfer Protocol"),
        53: ("DNS", "Domain Name System"),
        67: ("DHCP", "Dynamic Host Configuration Protocol (Server)"),
        68: ("DHCP", "Dynamic Host Configuration Protocol (Client)"),
        69: ("TFTP", "Trivial File Transfer Protocol"),
        80: ("HTTP", "HyperText Transfer Protocol"),
        88: ("Kerberos", "Kerberos Authentication"),
        110: ("POP3", "Post Office Protocol v3"),
        111: ("RPC", "Remote Procedure Call"),
        119: ("NNTP", "Network News Transfer Protocol"),
        123: ("NTP", "Network Time Protocol"),
        135: ("MS-RPC", "Microsoft RPC"),
        137: ("NetBIOS-NS", "NetBIOS Name Service"),
        138: ("NetBIOS-DGM", "NetBIOS Datagram Service"),
        139: ("NetBIOS-SSN", "NetBIOS Session Service"),
        143: ("IMAP", "Internet Message Access Protocol"),
        161: ("SNMP", "Simple Network Management Protocol"),
        162: ("SNMP-Trap", "SNMP Trap"),
        389: ("LDAP", "Lightweight Directory Access Protocol"),
        443: ("HTTPS", "HTTP Secure"),
        445: ("SMB", "Server Message Block"),
        465: ("SMTPS", "SMTP Secure"),
        514: ("Syslog", "System Logging Protocol"),
        515: ("LPD", "Line Printer Daemon"),
        587: ("SMTP-Submission", "SMTP Mail Submission"),
        631: ("IPP", "Internet Printing Protocol"),
        636: ("LDAPS", "LDAP Secure"),
        873: ("Rsync", "Remote Sync"),
        993: ("IMAPS", "IMAP Secure"),
        995: ("POP3S", "POP3 Secure"),
        1080: ("SOCKS", "SOCKS Proxy"),
        1433: ("MS-SQL", "Microsoft SQL Server"),
        1434: ("MS-SQL-Browser", "MS SQL Server Browser"),
        1521: ("Oracle", "Oracle Database"),
        1723: ("PPTP", "Point-to-Point Tunneling Protocol"),
        2049: ("NFS", "Network File System"),
        2082: ("cPanel", "cPanel Control Panel"),
        2083: ("cPanel-SSL", "cPanel SSL"),
        2086: ("WHM", "Web Host Manager"),
        2087: ("WHM-SSL", "WHM SSL"),
        3128: ("Squid", "Squid Proxy Server"),
        3306: ("MySQL", "MySQL Database"),
        3389: ("RDP", "Remote Desktop Protocol"),
        4444: ("Metasploit", "Metasploit Default"),
        5060: ("SIP", "Session Initiation Protocol"),
        5432: ("PostgreSQL", "PostgreSQL Database"),
        5900: ("VNC", "Virtual Network Computing"),
        5984: ("CouchDB", "CouchDB Database"),
        6379: ("Redis", "Redis Database"),
        6667: ("IRC", "Internet Relay Chat"),
        7000: ("Cassandra", "Apache Cassandra"),
        8000: ("HTTP-Alt", "HTTP Alternate"),
        8080: ("HTTP-Proxy", "HTTP Proxy"),
        8086: ("InfluxDB", "InfluxDB Database"),
        8443: ("HTTPS-Alt", "HTTPS Alternate"),
        8888: ("HTTP-Alt2", "HTTP Alternate 2"),
        9000: ("SonarQube", "SonarQube"),
        9042: ("Cassandra-Native", "Cassandra Native"),
        9090: ("WebSM", "Web-based System Manager"),
        9200: ("Elasticsearch", "Elasticsearch"),
        11211: ("Memcached", "Memcached"),
        27017: ("MongoDB", "MongoDB Database"),
        28015: ("RethinkDB", "RethinkDB Database"),
        50000: ("SAP", "SAP Router")
    }
    
    # Top 1000 ports for standard scanning
    TOP_1000 = [1, 3, 4, 6, 7, 9, 13, 17, 19, 20, 21, 22, 23, 24, 25, 26, 30, 32, 33, 37, 42, 43, 49, 53, 70, 79, 80, 81, 82, 83, 84, 85, 88, 89, 90, 99, 100, 106, 109, 110, 111, 113, 119, 125, 135, 139, 143, 144, 146, 161, 163, 179, 199, 211, 212, 222, 254, 255, 256, 259, 264, 280, 301, 306, 311, 340, 366, 389, 406, 407, 416, 417, 425, 427, 443, 444, 445, 458, 464, 465, 481, 497, 500, 512, 513, 514, 515, 524, 541, 543, 544, 545, 548, 554, 555, 563, 587, 593, 616, 617, 625, 631, 636, 646, 648, 666, 667, 668, 683, 687, 691, 700, 705, 711, 714, 720, 722, 726, 749, 765, 777, 783, 787, 800, 801, 808, 843, 873, 880, 888, 898, 900, 901, 902, 903, 911, 912, 981, 987, 990, 992, 993, 995, 999, 1000, 1001, 1002, 1007, 1009, 1010, 1011, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1102, 1104, 1105, 1106, 1107, 1108, 1110, 1111, 1112, 1113, 1114, 1117, 1119, 1121, 1122, 1123, 1124, 1126, 1130, 1131, 1132, 1137, 1138, 1141, 1145, 1147, 1148, 1149, 1151, 1152, 1154, 1163, 1164, 1165, 1166, 1169, 1174, 1175, 1183, 1185, 1186, 1187, 1192, 1198, 1199, 1201, 1213, 1216, 1217, 1218, 1233, 1234, 1236, 1244, 1247, 1248, 1259, 1271, 1272, 1277, 1287, 1296, 1300, 1301, 1309, 1310, 1311, 1322, 1328, 1334, 1352, 1417, 1433, 1434, 1443, 1455, 1461, 1494, 1500, 1501, 1503, 1521, 1524, 1533, 1556, 1580, 1583, 1594, 1600, 1641, 1658, 1666, 1687, 1688, 1700, 1717, 1718, 1719, 1720, 1721, 1723, 1755, 1761, 1782, 1783, 1801, 1805, 1812, 1839, 1840, 1862, 1863, 1864, 1875, 1900, 1914, 1935, 1947, 1971, 1972, 1974, 1984, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2013, 2020, 2021, 2022, 2030, 2033, 2034, 2035, 2038, 2040, 2041, 2042, 2043, 2045, 2046, 2047, 2048, 2049, 2065, 2068, 2099, 2100, 2103, 2105, 2106, 2107, 2111, 2119, 2121, 2126, 2135, 2144, 2160, 2161, 2170, 2179, 2190, 2191, 2196, 2200, 2222, 2251, 2260, 2288, 2301, 2323, 2366, 2381, 2382, 2383, 2393, 2394, 2399, 2401, 2492, 2500, 2522, 2525, 2557, 2601, 2602, 2604, 2605, 2607, 2608, 2638, 2701, 2702, 2710, 2717, 2718, 2725, 2800, 2809, 2811, 2869, 2875, 2909, 2910, 2920, 2967, 2968, 2998, 3000, 3001, 3003, 3005, 3006, 3007, 3011, 3013, 3017, 3030, 3031, 3052, 3071, 3077, 3128, 3168, 3211, 3221, 3260, 3261, 3268, 3269, 3283, 3300, 3301, 3306, 3322, 3323, 3324, 3325, 3333, 3351, 3367, 3369, 3370, 3371, 3372, 3389, 3390, 3404, 3476, 3493, 3517, 3527, 3546, 3551, 3580, 3659, 3689, 3690, 3703, 3737, 3766, 3784, 3800, 3801, 3809, 3814, 3826, 3827, 3828, 3851, 3869, 3871, 3878, 3880, 3889, 3905, 3914, 3918, 3920, 3945, 3971, 3986, 3995, 3998, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4045, 4111, 4125, 4126, 4129, 4224, 4242, 4279, 4321, 4343, 4443, 4444, 4445, 4446, 4449, 4550, 4567, 4662, 4848, 4899, 4900, 4998, 5000, 5001, 5002, 5003, 5004, 5009, 5030, 5033, 5050, 5051, 5054, 5060, 5061, 5080, 5087, 5100, 5101, 5102, 5120, 5190, 5200, 5214, 5221, 5222, 5225, 5226, 5269, 5280, 5298, 5357, 5405, 5414, 5431, 5432, 5440, 5500, 5510, 5544, 5550, 5555, 5560, 5566, 5631, 5633, 5666, 5678, 5679, 5718, 5730, 5800, 5801, 5802, 5810, 5811, 5815, 5822, 5825, 5850, 5859, 5862, 5877, 5900, 5901, 5902, 5903, 5904, 5906, 5907, 5910, 5911, 5915, 5922, 5925, 5950, 5952, 5959, 5960, 5961, 5962, 5963, 5987, 5988, 5989, 5998, 5999, 6000, 6001, 6002, 6003, 6004, 6005, 6006, 6007, 6009, 6025, 6059, 6100, 6101, 6106, 6112, 6123, 6129, 6156, 6346, 6389, 6502, 6510, 6543, 6547, 6565, 6566, 6567, 6580, 6646, 6666, 6667, 6668, 6669, 6689, 6692, 6699, 6779, 6788, 6789, 6792, 6839, 6881, 6901, 6969, 7000, 7001, 7002, 7004, 7007, 7019, 7025, 7070, 7100, 7103, 7106, 7200, 7201, 7402, 7435, 7443, 7496, 7512, 7625, 7627, 7676, 7741, 7777, 7778, 7800, 7911, 7920, 7921, 7937, 7938, 7999, 8000, 8001, 8002, 8007, 8008, 8009, 8010, 8011, 8021, 8022, 8031, 8042, 8045, 8080, 8081, 8082, 8083, 8084, 8085, 8086, 8087, 8088, 8089, 8090, 8093, 8099, 8100, 8180, 8181, 8192, 8193, 8194, 8200, 8222, 8254, 8290, 8291, 8292, 8300, 8333, 8383, 8400, 8402, 8443, 8500, 8600, 8649, 8651, 8652, 8654, 8701, 8800, 8873, 8888, 8899, 8994, 9000, 9001, 9002, 9003, 9009, 9010, 9011, 9040, 9050, 9071, 9080, 9081, 9090, 9091, 9099, 9100, 9101, 9102, 9103, 9110, 9111, 9200, 9207, 9220, 9290, 9415, 9418, 9485, 9500, 9502, 9503, 9535, 9575, 9593, 9594, 9595, 9618, 9666, 9876, 9877, 9878, 9898, 9900, 9917, 9929, 9943, 9944, 9968, 9998, 9999, 10000, 10001, 10002, 10003, 10004, 10009, 10010, 10012, 10024, 10025, 10082, 10180, 10215, 10243, 10566, 10616, 10617, 10621, 10626, 10628, 10629, 10778, 11110, 11111, 11967, 12000, 12174, 12265, 12345, 13456, 13722, 13782, 13783, 14000, 14238, 14441, 14442, 15000, 15002, 15003, 15004, 15660, 15742, 16000, 16001, 16012, 16016, 16018, 16080, 16113, 16992, 16993, 17877, 17988, 18040, 18101, 18988, 19101, 19283, 19315, 19350, 19780, 19801, 19842, 20000, 20005, 20031, 20221, 20222, 20828, 21571, 22939, 23502, 24444, 24800, 25734, 25735, 26214, 27000, 27352, 27353, 27355, 27356, 27715, 28201, 30000, 30718, 30951, 31038, 31337, 32768, 32769, 32770, 32771, 32772, 32773, 32774, 32775, 32776, 32777, 32778, 32779, 32780, 32781, 32782, 32783, 32784, 32785, 33354, 33899, 34571, 34572, 34573, 35500, 38292, 40193, 40911, 41511, 42510, 44176, 44442, 44443, 44501, 45100, 48080, 49152, 49153, 49154, 49155, 49156, 49157, 49158, 49159, 49160, 49161, 49163, 49165, 49167, 49175, 49176, 49400, 49999, 50000, 50001, 50002, 50003, 50006, 50300, 50389, 50500, 50636, 50800, 51103, 51493, 52673, 52822, 52848, 52869, 54045, 54328, 55055, 55056, 55555, 55600, 56737, 56738, 57294, 57797, 58080, 60020, 60443, 61532, 61900, 62078, 63331, 64623, 64680, 65000, 65129, 65389]

class InteractiveScanner:
    """Main interactive scanner class"""
    
    def __init__(self):
        self.targets = []
        self.ports = []
        self.threads = 100
        self.timeout = 1.0
        self.banner_grab = False
        self.output_formats = []
        self.results = []
        self.scanner = None
        self.total_ports_to_scan = 0
        self.ports_scanned = 0
        self.start_time = None
        
    def clear_screen(self):
        """Clear terminal screen"""
        os.system('cls' if os.name == 'nt' else 'clear')
    
    def print_banner(self):
        """Display the application banner"""
        self.clear_screen()
        print(Color.CYAN + BANNER + Color.END)
        time.sleep(1)
    
    def get_user_input(self, prompt, validator=None, default=None):
        """Get and validate user input"""
        while True:
            user_input = input(f"{Color.YELLOW}{prompt}{Color.END}").strip()
            
            if not user_input and default is not None:
                return default
            
            if validator:
                valid, result = validator(user_input)
                if valid:
                    return result
                else:
                    Color.print_error(f"Invalid input: {result}")
            else:
                return user_input
    
    def validate_ip_or_hostname(self, target):
        """Validate IP address or hostname"""
        # Check if it's an IP address
        try:
            ipaddress.ip_address(target)
            return True, target
        except ValueError:
            pass
        
        # Check if it's a CIDR notation
        try:
            network = ipaddress.ip_network(target, strict=False)
            return True, target
        except ValueError:
            pass
        
        # Check if it's a valid hostname
        try:
            socket.gethostbyname(target)
            return True, target
        except socket.gaierror:
            return False, f"Cannot resolve hostname: {target}"
    
    def validate_port_range(self, port_input):
        """Validate port range input"""
        try:
            if port_input.lower() == 'all':
                return True, list(range(1, 65536))
            elif port_input.lower() == 'top1000':
                return True, ServiceDatabase.TOP_1000
            elif '-' in port_input:
                start, end = map(int, port_input.split('-'))
                if 1 <= start <= 65535 and 1 <= end <= 65535 and start <= end:
                    return True, list(range(start, end + 1))
                else:
                    return False, "Port range must be between 1-65535"
            elif ',' in port_input:
                ports = []
                for p in port_input.split(','):
                    if '-' in p:
                        start, end = map(int, p.split('-'))
                        ports.extend(range(start, end + 1))
                    else:
                        ports.append(int(p))
                return True, sorted(set(ports))
            else:
                port = int(port_input)
                if 1 <= port <= 65535:
                    return True, [port]
                else:
                    return False, "Port must be between 1-65535"
        except ValueError:
            return False, "Invalid port format"
    
    def step1_welcome(self):
        """Step 1: Welcome and introduction"""
        self.print_banner()
        print(f"{Color.BOLD}Welcome to Advanced Port Scanner v3.0!{Color.END}\n")
        print("This tool will help you perform comprehensive network port scanning")
        print("with full coverage capabilities and professional reporting.\n")
        
        Color.print_info("Press Enter to continue...")
        input()
    
    def step2_select_profile(self):
        """Step 2: Select scan profile"""
        Color.print_header("STEP 1: SELECT SCAN PROFILE")
        print("\nAvailable scan profiles:\n")
        
        for key, profile in ScanProfile.PROFILES.items():
            print(f"  {Color.BOLD}[{key}]{Color.END} {profile['name']}")
            print(f"      {Color.DARKCYAN}{profile['description']}{Color.END}")
            print()
        
        choice = self.get_user_input(
            "\nSelect profile [1-6] (default: 2): ",
            validator=lambda x: (True, x) if x in ScanProfile.PROFILES else (False, "Invalid choice"),
            default="2"
        )
        
        selected_profile = ScanProfile.PROFILES[choice]
        Color.print_success(f"Selected: {selected_profile['name']}")
        
        return selected_profile
    
    def step3_configure_targets(self):
        """Step 3: Configure target hosts"""
        Color.print_header("STEP 2: CONFIGURE TARGET HOSTS")
        
        print("\nYou can enter:")
        print("  ‚Ä¢ Single IP: 192.168.1.1")
        print("  ‚Ä¢ Hostname: example.com")
        print("  ‚Ä¢ IP Range (CIDR): 192.168.1.0/24")
        print("  ‚Ä¢ Multiple targets (comma-separated): 192.168.1.1,192.168.1.2")
        print()
        
        while True:
            target_input = self.get_user_input(
                "Enter target(s): ",
                validator=None
            )
            
            if not target_input:
                Color.print_error("Target cannot be empty")
                continue
            
            # Parse multiple targets
            targets = []
            failed = []
            
            for target in target_input.split(','):
                target = target.strip()
                
                # Handle CIDR notation
                if '/' in target:
                    try:
                        network = ipaddress.ip_network(target, strict=False)
                        hosts = [str(ip) for ip in network.hosts()]
                        if hosts:
                            targets.extend(hosts)
                            Color.print_success(f"Added {len(hosts)} hosts from {target}")
                        else:
                            targets.append(str(network.network_address))
                            Color.print_success(f"Added network address {network.network_address}")
                    except ValueError as e:
                        failed.append((target, str(e)))
                else:
                    valid, result = self.validate_ip_or_hostname(target)
                    if valid:
                        targets.append(result)
                        Color.print_success(f"Added target: {result}")
                    else:
                        failed.append((target, result))
            
            if failed:
                Color.print_warning("Failed to add some targets:")
                for target, reason in failed:
                    print(f"  ‚Ä¢ {target}: {reason}")
            
            if targets:
                self.targets = targets
                print(f"\n{Color.GREEN}Total targets to scan: {len(self.targets)}{Color.END}")
                break
            else:
                Color.print_error("No valid targets added. Please try again.")
    
    def step4_configure_ports(self, profile):
        """Step 4: Configure ports to scan"""
        Color.print_header("STEP 3: CONFIGURE PORTS")
        
        if profile['ports'] == "all":
            self.ports = list(range(1, 65536))
            Color.print_info(f"Scanning ALL 65,535 ports for maximum coverage")
        elif profile['ports'] == "top1000":
            self.ports = ServiceDatabase.TOP_1000
            Color.print_info(f"Scanning top 1000 most common ports")
        elif profile['ports'] and profile['name'] != "Custom Scan":
            self.ports = profile['ports']
            Color.print_info(f"Scanning {len(self.ports)} predefined ports")
        else:
            print("\nPort configuration options:")
            print("  ‚Ä¢ Single port: 80")
            print("  ‚Ä¢ Port range: 1-1000")
            print("  ‚Ä¢ Multiple ports: 80,443,8080")
            print("  ‚Ä¢ Mixed: 80,443,1000-2000")
            print("  ‚Ä¢ All ports: all")
            print("  ‚Ä¢ Top 1000: top1000")
            print()
            
            port_input = self.get_user_input(
                "Enter ports to scan (default: top1000): ",
                validator=self.validate_port_range,
                default=ServiceDatabase.TOP_1000
            )
            
            self.ports = port_input
        
        print(f"\n{Color.GREEN}Total ports to scan: {len(self.ports)}{Color.END}")
        
        if len(self.ports) > 10000:
            Color.print_warning("Large number of ports selected. This may take some time.")
            confirm = self.get_user_input(
                "Continue? (Y/n): ",
                default="Y"
            )
            if confirm.lower() == 'n':
                return self.step4_configure_ports({"name": "Custom Scan", "ports": None})
    
    def step5_configure_advanced(self, profile):
        """Step 5: Configure advanced options"""
        Color.print_header("STEP 4: ADVANCED OPTIONS")
        
        # Thread configuration
        if profile['threads'] and profile['name'] != "Custom Scan":
            self.threads = profile['threads']
            Color.print_info(f"Using {self.threads} threads (profile default)")
        else:
            print(f"\nThread count affects scan speed:")
            print(f"  ‚Ä¢ Low (50): Slower but stealthier")
            print(f"  ‚Ä¢ Medium (100-200): Balanced")
            print(f"  ‚Ä¢ High (500+): Fast but may trigger alerts")
            
            thread_input = self.get_user_input(
                f"Number of threads (default: 100, max: 1000): ",
                validator=lambda x: (True, int(x)) if x.isdigit() and 1 <= int(x) <= 1000 else (False, "Must be 1-1000"),
                default=100
            )
            self.threads = thread_input
        
        # Timeout configuration
        if profile['timeout'] and profile['name'] != "Custom Scan":
            self.timeout = profile['timeout']
            Color.print_info(f"Using {self.timeout}s timeout (profile default)")
        else:
            timeout_input = self.get_user_input(
                f"Connection timeout in seconds (default: 1.0): ",
                validator=lambda x: (True, float(x)) if x.replace('.', '').isdigit() else (False, "Must be a number"),
                default=1.0
            )
            self.timeout = timeout_input
        
        # Banner grabbing
        if profile['banner'] is not None and profile['name'] != "Custom Scan":
            self.banner_grab = profile['banner']
            Color.print_info(f"Banner grabbing: {'Enabled' if self.banner_grab else 'Disabled'} (profile default)")
        else:
            banner_input = self.get_user_input(
                "Enable banner grabbing for service detection? (Y/n): ",
                default="Y"
            )
            self.banner_grab = banner_input.lower() != 'n'
    
    def step6_configure_output(self):
        """Step 6: Configure output options"""
        Color.print_header("STEP 5: OUTPUT OPTIONS")
        
        print("\nAvailable output formats:")
        print("  [1] Text Report (.txt)")
        print("  [2] JSON Report (.json)")
        print("  [3] CSV Report (.csv)")
        print("  [4] HTML Report (.html)")
        print("  [5] XML Report (.xml)")
        print("  [6] All Formats")
        print()
        
        format_input = self.get_user_input(
            "Select output format(s) [1-6] (default: 6): ",
            default="6"
        )
        
        format_map = {
            "1": ["txt"],
            "2": ["json"],
            "3": ["csv"],
            "4": ["html"],
            "5": ["xml"],
            "6": ["txt", "json", "csv", "html", "xml"]
        }
        
        self.output_formats = format_map.get(format_input, ["txt"])
        Color.print_success(f"Will generate: {', '.join(self.output_formats).upper()} reports")
    
    def step7_confirm_scan(self):
        """Step 7: Confirm scan configuration"""
        Color.print_header("SCAN CONFIGURATION SUMMARY")
        
        print(f"\n{Color.BOLD}Targets:{Color.END}")
        if len(self.targets) <= 5:
            for target in self.targets:
                print(f"  ‚Ä¢ {target}")
        else:
            print(f"  ‚Ä¢ {self.targets[0]}")
            print(f"  ‚Ä¢ {self.targets[1]}")
            print(f"  ‚Ä¢ ...")
            print(f"  ‚Ä¢ {self.targets[-1]}")
            print(f"  Total: {len(self.targets)} hosts")
        
        print(f"\n{Color.BOLD}Ports:{Color.END}")
        if len(self.ports) <= 20:
            print(f"  {', '.join(map(str, sorted(self.ports)))}")
        else:
            print(f"  {len(self.ports)} ports (Range: {min(self.ports)}-{max(self.ports)})")
        
        print(f"\n{Color.BOLD}Configuration:{Color.END}")
        print(f"  ‚Ä¢ Threads: {self.threads}")
        print(f"  ‚Ä¢ Timeout: {self.timeout}s")
        print(f"  ‚Ä¢ Banner Grab: {'Yes' if self.banner_grab else 'No'}")
        print(f"  ‚Ä¢ Output: {', '.join(self.output_formats).upper()}")
        
        self.total_ports_to_scan = len(self.targets) * len(self.ports)
        print(f"\n{Color.BOLD}Total operations: {self.total_ports_to_scan:,} port checks{Color.END}")
        
        if self.total_ports_to_scan > 100000:
            Color.print_warning("This is a large scan and may take considerable time!")
        
        print()
        confirm = self.get_user_input(
            f"{Color.BOLD}Start scanning? (Y/n): {Color.END}",
            default="Y"
        )
        
        return confirm.lower() != 'n'
    
    def perform_scan(self):
        """Perform the actual port scanning"""
        Color.print_header("SCANNING IN PROGRESS")
        
        self.start_time = datetime.now()
        self.ports_scanned = 0
        
        for target_idx, target in enumerate(self.targets, 1):
            print(f"\n{Color.CYAN}[{target_idx}/{len(self.targets)}] Scanning {target}{Color.END}")
            print("‚îÄ" * 50)
            
            result = ScanResult()
            result.host = target
            result.scan_start = datetime.now()
            
            # Try to resolve hostname
            try:
                result.hostname = socket.gethostbyaddr(target)[0]
                Color.print_info(f"Hostname: {result.hostname}")
            except:
                result.hostname = target
            
            # Create thread pool for port scanning
            with ThreadPoolExecutor(max_workers=self.threads) as executor:
                futures = []
                
                for port in self.ports:
                    future = executor.submit(self.scan_port, target, port, result)
                    futures.append(future)
                
                # Process results as they complete
                for future in as_completed(futures):
                    self.ports_scanned += 1
                    
                    # Update progress
                    progress = (self.ports_scanned / self.total_ports_to_scan) * 100
                    elapsed = datetime.now() - self.start_time
                    
                    if self.ports_scanned % 100 == 0:
                        print(f"\r{Color.YELLOW}Progress: {progress:.1f}% | "
                              f"Ports: {self.ports_scanned:,}/{self.total_ports_to_scan:,} | "
                              f"Time: {elapsed} | "
                              f"Open: {len(result.open_ports)}{Color.END}", end='')
            
            result.scan_end = datetime.now()
            result.os_guess = self.guess_os(result)
            self.results.append(result)
            
            # Print summary for this host
            print(f"\n{Color.GREEN}Found {len(result.open_ports)} open ports{Color.END}")
            if result.os_guess:
                Color.print_info(f"OS Detection: {result.os_guess}")
    
    def scan_port(self, host, port, result):
        """Scan a single port"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            
            connection_result = sock.connect_ex((host, port))
            
            if connection_result == 0:
                # Port is open
                service_name, service_desc = ServiceDatabase.SERVICES.get(
                    port, (f"unknown-{port}", "Unknown Service")
                )
                
                result.open_ports.append(port)
                result.services[port] = service_name
                
                # Try banner grabbing if enabled
                if self.banner_grab:
                    try:
                        sock.send(b"HEAD / HTTP/1.0\r\n\r\n")
                        banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
                        if banner:
                            result.banners[port] = banner[:200]  # Limit banner length
                    except:
                        pass
                
                print(f"\n  {Color.GREEN}[OPEN]{Color.END} Port {port:5d} - {service_name} ({service_desc})")
                
            sock.close()
            
        except socket.timeout:
            result.filtered_ports.append(port)
        except Exception:
            pass
    
    def guess_os(self, result):
        """Guess operating system based on open ports"""
        open_ports = set(result.open_ports)
        
        # OS fingerprinting based on common port patterns
        windows_indicators = {135, 139, 445, 3389, 5985}
        linux_indicators = {22, 111, 2049}
        macos_indicators = {548, 631, 5900}
        
        windows_score = len(windows_indicators & open_ports)
        linux_score = len(linux_indicators & open_ports)
        macos_score = len(macos_indicators & open_ports)
        
        if windows_score >= 2:
            return "Windows"
        elif linux_score >= 1 and 22 in open_ports:
            return "Linux/Unix"
        elif macos_score >= 1:
            return "macOS"
        else:
            return "Unknown"
    
    def generate_reports(self):
        """Generate scan reports"""
        Color.print_header("GENERATING REPORTS")
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        for fmt in self.output_formats:
            filename = f"scan_report_{timestamp}.{fmt}"
            
            try:
                if fmt == "txt":
                    self.generate_text_report(filename)
                elif fmt == "json":
                    self.generate_json_report(filename)
                elif fmt == "csv":
                    self.generate_csv_report(filename)
                elif fmt == "html":
                    self.generate_html_report(filename)
                elif fmt == "xml":
                    self.generate_xml_report(filename)
                
                Color.print_success(f"Generated: {filename}")
                
            except Exception as e:
                Color.print_error(f"Failed to generate {fmt} report: {e}")
    
    def generate_text_report(self, filename):
        """Generate text report"""
        with open(filename, 'w') as f:
            f.write("="*80 + "\n")
            f.write("                    ADVANCED PORT SCANNER REPORT\n")
            f.write("="*80 + "\n\n")
            f.write(f"Scan Date: {datetime.now()}\n")
            f.write(f"Total Hosts Scanned: {len(self.results)}\n")
            f.write(f"Total Ports Checked: {self.total_ports_to_scan:,}\n")
            f.write(f"Scan Duration: {datetime.now() - self.start_time}\n")
            f.write("\n" + "="*80 + "\n\n")
            
            for result in self.results:
                f.write(f"HOST: {result.host}\n")
                f.write(f"Hostname: {result.hostname}\n")
                f.write(f"OS Detection: {result.os_guess}\n")
                f.write(f"Scan Duration: {result.scan_end - result.scan_start}\n")
                f.write(f"Open Ports: {len(result.open_ports)}\n")
                f.write("\n" + "-"*40 + "\n\n")
                
                if result.open_ports:
                    f.write("PORT     STATE    SERVICE\n")
                    f.write("-"*40 + "\n")
                    for port in sorted(result.open_ports):
                        service = result.services.get(port, "unknown")
                        f.write(f"{port:5d}    open     {service}\n")
                        if port in result.banners:
                            f.write(f"         Banner: {result.banners[port][:60]}...\n")
                
                f.write("\n" + "="*80 + "\n\n")
    
    def generate_json_report(self, filename):
        """Generate JSON report"""
        report_data = {
            "scan_info": {
                "tool": "Advanced Port Scanner v3.0",
                "timestamp": str(datetime.now()),
                "duration": str(datetime.now() - self.start_time),
                "total_hosts": len(self.results),
                "total_ports_scanned": self.total_ports_to_scan
            },
            "results": []
        }
        
        for result in self.results:
            host_data = {
                "host": result.host,
                "hostname": result.hostname,
                "os_guess": result.os_guess,
                "scan_duration": str(result.scan_end - result.scan_start),
                "open_ports": result.open_ports,
                "services": result.services,
                "banners": result.banners,
                "statistics": {
                    "open": len(result.open_ports),
                    "filtered": len(result.filtered_ports)
                }
            }
            report_data["results"].append(host_data)
        
        with open(filename, 'w') as f:
            json.dump(report_data, f, indent=2)
    
    def generate_csv_report(self, filename):
        """Generate CSV report"""
        with open(filename, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(['Host', 'Hostname', 'Port', 'State', 'Service', 'Banner', 'OS'])
            
            for result in self.results:
                for port in result.open_ports:
                    writer.writerow([
                        result.host,
                        result.hostname,
                        port,
                        'open',
                        result.services.get(port, ''),
                        result.banners.get(port, '')[:100] if port in result.banners else '',
                        result.os_guess
                    ])
    
    def generate_html_report(self, filename):
        """Generate HTML report"""
        html = """<!DOCTYPE html>
<html>
<head>
    <title>Port Scan Report</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .container { background: white; border-radius: 10px; padding: 30px; box-shadow: 0 10px 40px rgba(0,0,0,0.2); }
        h1 { color: #333; border-bottom: 3px solid #667eea; padding-bottom: 10px; }
        .summary { background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0; }
        .host-section { margin: 30px 0; padding: 20px; background: #fff; border: 1px solid #e0e0e0; border-radius: 8px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px; text-align: left; }
        td { padding: 10px; border-bottom: 1px solid #eee; }
        tr:hover { background: #f5f5f5; }
        .open { color: #28a745; font-weight: bold; }
        .badge { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: bold; }
        .badge-success { background: #d4edda; color: #155724; }
        .badge-info { background: #d1ecf1; color: #0c5460; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Advanced Port Scan Report</h1>
        <div class="summary">
            <h2>Scan Summary</h2>
            <p><strong>Scan Date:</strong> """ + str(datetime.now()) + """</p>
            <p><strong>Total Hosts:</strong> """ + str(len(self.results)) + """</p>
            <p><strong>Total Ports Scanned:</strong> """ + f"{self.total_ports_to_scan:,}" + """</p>
            <p><strong>Scan Duration:</strong> """ + str(datetime.now() - self.start_time) + """</p>
        </div>
"""
        
        for result in self.results:
            total_open = len(result.open_ports)
            html += f"""
        <div class="host-section">
            <h2>üìç {result.host} ({result.hostname})</h2>
            <p><span class="badge badge-info">OS: {result.os_guess}</span> 
               <span class="badge badge-success">Open Ports: {total_open}</span></p>
            """
            
            if result.open_ports:
                html += """
            <table>
                <tr>
                    <th>Port</th>
                    <th>State</th>
                    <th>Service</th>
                    <th>Banner</th>
                </tr>
"""
                for port in sorted(result.open_ports):
                    service = result.services.get(port, "unknown")
                    banner = result.banners.get(port, "")[:100] if port in result.banners else "-"
                    html += f"""
                <tr>
                    <td>{port}</td>
                    <td class="open">Open</td>
                    <td>{service}</td>
                    <td>{banner}</td>
                </tr>
"""
                html += "            </table>"
            else:
                html += "            <p>No open ports found.</p>"
            
            html += "        </div>"
        
        html += """
    </div>
</body>
</html>
"""
        
        with open(filename, 'w') as f:
            f.write(html)
    
    def generate_xml_report(self, filename):
        """Generate XML report"""
        xml_content = '<?xml version="1.0" encoding="UTF-8"?>\n'
        xml_content += '<scanreport>\n'
        xml_content += f'  <scaninfo timestamp="{datetime.now()}" duration="{datetime.now() - self.start_time}" />\n'
        xml_content += '  <hosts>\n'
        
        for result in self.results:
            xml_content += f'    <host ip="{result.host}" hostname="{result.hostname}" os="{result.os_guess}">\n'
            xml_content += '      <ports>\n'
            
            for port in sorted(result.open_ports):
                service = result.services.get(port, "unknown")
                banner = result.banners.get(port, "").replace('"', '&quot;') if port in result.banners else ""
                xml_content += f'        <port number="{port}" state="open" service="{service}" banner="{banner}" />\n'
            
            xml_content += '      </ports>\n'
            xml_content += '    </host>\n'
        
        xml_content += '  </hosts>\n'
        xml_content += '</scanreport>\n'
        
        with open(filename, 'w') as f:
            f.write(xml_content)
    
    def display_final_summary(self):
        """Display final scan summary"""
        Color.print_header("SCAN COMPLETED")
        
        total_open_ports = sum(len(r.open_ports) for r in self.results)
        scan_duration = datetime.now() - self.start_time
        
        print(f"\n{Color.BOLD}Final Statistics:{Color.END}")
        print(f"  ‚Ä¢ Total Hosts Scanned: {len(self.results)}")
        print(f"  ‚Ä¢ Total Ports Checked: {self.total_ports_to_scan:,}")
        print(f"  ‚Ä¢ Total Open Ports Found: {total_open_ports}")
        print(f"  ‚Ä¢ Scan Duration: {scan_duration}")
        print(f"  ‚Ä¢ Average Speed: {self.total_ports_to_scan / scan_duration.total_seconds():.0f} ports/second")
        
        print(f"\n{Color.BOLD}Top Findings:{Color.END}")
        
        # Find hosts with most open ports
        if self.results:
            sorted_results = sorted(self.results, key=lambda x: len(x.open_ports), reverse=True)
            for i, result in enumerate(sorted_results[:3], 1):
                if result.open_ports:
                    print(f"  {i}. {result.host}: {len(result.open_ports)} open ports (OS: {result.os_guess})")
        
        print(f"\n{Color.GREEN}Reports have been generated successfully!{Color.END}")
        print(f"Check the current directory for your report files.\n")
    
    def run(self):
        """Main execution flow"""
        try:
            # Step 1: Welcome
            self.step1_welcome()
            
            # Step 2: Select scan profile
            profile = self.step2_select_profile()
            
            # Step 3: Configure targets
            self.step3_configure_targets()
            
            # Step 4: Configure ports
            self.step4_configure_ports(profile)
            
            # Step 5: Advanced options
            self.step5_configure_advanced(profile)
            
            # Step 6: Output options
            self.step6_configure_output()
            
            # Step 7: Confirm and start scan
            if self.step7_confirm_scan():
                self.perform_scan()
                self.generate_reports()
                self.display_final_summary()
            else:
                Color.print_warning("Scan cancelled by user")
                
        except KeyboardInterrupt:
            Color.print_warning("\n\nScan interrupted by user (Ctrl+C)")
            if self.results:
                print("Generating partial reports...")
                self.generate_reports()
        except Exception as e:
            Color.print_error(f"\nAn error occurred: {e}")
            import traceback
            traceback.print_exc()

class ScanResult:
    """Container for scan results"""
    
    def __init__(self):
        self.host = None
        self.hostname = None
        self.scan_start = None
        self.scan_end = None
        self.open_ports = []
        self.closed_ports = []
        self.filtered_ports = []
        self.services = {}
        self.banners = {}
        self.os_guess = None

def main():
    """Main entry point"""
    scanner = InteractiveScanner()
    scanner.run()

if __name__ == "__main__":
    main()
