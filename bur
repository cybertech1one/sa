#!/usr/bin/env python3
"""
WebHunter - Intelligent Web Discovery Tool v3.0
Advanced Directory & File Enumeration with Smart Detection
"""

import sys
import os
import time
import threading
import json
import hashlib
import re
import socket
import ssl
import http.client
from datetime import datetime
from urllib.parse import urljoin, urlparse, quote
from concurrent.futures import ThreadPoolExecutor, as_completed
from collections import defaultdict, Counter
import statistics
import random
import string

# ASCII Banner
BANNER = """
╔═══════════════════════════════════════════════════════════════════════════════╗
║                                                                               ║
║  ██╗    ██╗███████╗██████╗ ██╗  ██╗██╗   ██╗███╗   ██╗████████╗███████╗██████╗║
║  ██║    ██║██╔════╝██╔══██╗██║  ██║██║   ██║████╗  ██║╚══██╔══╝██╔════╝██╔══██╗
║  ██║ █╗ ██║█████╗  ██████╔╝███████║██║   ██║██╔██╗ ██║   ██║   █████╗  ██████╔╝
║  ██║███╗██║██╔══╝  ██╔══██╗██╔══██║██║   ██║██║╚██╗██║   ██║   ██╔══╝  ██╔══██╗
║  ╚███╔███╔╝███████╗██████╔╝██║  ██║╚██████╔╝██║ ╚████║   ██║   ███████╗██║  ██║
║   ╚══╝╚══╝ ╚══════╝╚═════╝ ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═══╝   ╚═╝   ╚══════╝╚═╝  ╚═╝
║                                                                               ║
║              INTELLIGENT WEB DISCOVERY TOOL - THINK LIKE A HUNTER            ║
╚═══════════════════════════════════════════════════════════════════════════════╝
"""

class Console:
    """Enhanced console output with colors and formatting"""
    
    # Colors
    PURPLE = '\\033[95m'
    CYAN = '\\033[96m'
    BLUE = '\\033[94m'
    GREEN = '\\033[92m'
    YELLOW = '\\033[93m'
    RED = '\\033[91m'
    WHITE = '\\033[97m'
    GRAY = '\\033[90m'
    BOLD = '\\033[1m'
    UNDERLINE = '\\033[4m'
    END = '\\033[0m'
    
    # Status symbols
    SUCCESS = f"{GREEN}[+]{END}"
    INFO = f"{CYAN}[*]{END}"
    WARNING = f"{YELLOW}[!]{END}"
    ERROR = f"{RED}[-]{END}"
    QUESTION = f"{BLUE}[?]{END}"
    FOUND = f"{GREEN}[FOUND]{END}"
    
    @staticmethod
    def clear():
        os.system('cls' if os.name == 'nt' else 'clear')
    
    @staticmethod
    def print_banner():
        Console.clear()
        print(f"{Console.CYAN}{BANNER}{Console.END}")
        time.sleep(0.5)
    
    @staticmethod
    def section(title):
        print(f"\\n{Console.BOLD}{Console.PURPLE}▶ {title.upper()}{Console.END}")
        print("─" * 60)
    
    @staticmethod
    def progress_bar(current, total, width=50, extra=""):
        percent = current / total if total > 0 else 0
        filled = int(width * percent)
        bar = "█" * filled + "░" * (width - filled)
        
        sys.stdout.write(f"\\r{Console.CYAN}Progress: [{bar}] {percent*100:.1f}% "
                        f"({current}/{total}) {extra}{Console.END}")
        sys.stdout.flush()

class IntelligentDetector:
    """Smart detection engine that learns and adapts"""
    
    def __init__(self):
        self.false_positive_signatures = []
        self.custom_404_patterns = []
        self.response_clusters = defaultdict(list)
        self.baseline_responses = {}
        self.wildcard_responses = {}
        self.rate_limit_indicators = []
        self.technology_signatures = {}
        
    def establish_baseline(self, http_client, base_url):
        """Establish baseline for intelligent detection"""
        Console.section("ESTABLISHING BASELINE")
        print(f"{Console.INFO} Learning target behavior patterns...\\n")
        
        # Test 1: Random non-existent paths
        random_paths = []
        for i in range(3):
            random_path = ''.join(random.choices(string.ascii_lowercase + string.digits, k=16))
            random_paths.append(random_path)
            
        print(f"  Testing random paths for 404 detection...")
        for path in random_paths:
            response = http_client.request(urljoin(base_url, path))
            if response:
                self.analyze_404_response(response)
                print(f"    • {path}: Status {response['status_code']} "
                     f"(Size: {len(response['content'])} bytes)")
        
        # Test 2: Extension handling
        print(f"\\n  Testing extension handling...")
        test_extensions = ['.php', '.html', '.asp', '.jsp', '']
        base_random = ''.join(random.choices(string.ascii_lowercase, k=8))
        
        for ext in test_extensions:
            test_path = f"{base_random}{ext}"
            response = http_client.request(urljoin(base_url, test_path))
            if response:
                print(f"    • {test_path}: Status {response['status_code']}")
        
        # Test 3: Wildcard detection
        print(f"\\n  Testing wildcard responses...")
        wildcard_test = f"{''.join(random.choices(string.ascii_lowercase, k=8))}/test"
        response = http_client.request(urljoin(base_url, wildcard_test))
        if response and response['status_code'] == 200:
            print(f"    {Console.WARNING} Possible wildcard detected!")
            self.wildcard_responses[base_url] = response
        
        # Test 4: Case sensitivity
        print(f"\\n  Testing case sensitivity...")
        for test in ['Admin', 'ADMIN', 'admin']:
            response = http_client.request(urljoin(base_url, test))
            if response:
                print(f"    • {test}: Status {response['status_code']}")
        
        print(f"\\n{Console.SUCCESS} Baseline established successfully!")
        time.sleep(1)
    
    def analyze_404_response(self, response):
        """Analyze 404 responses to detect custom error pages"""
        content = response['content']
        
        # Extract patterns from 404 pages
        patterns = {
            'content_length': len(content),
            'content_hash': hashlib.md5(content).hexdigest(),
            'title': self.extract_title(content),
            'keywords': self.extract_keywords(content)
        }
        
        self.custom_404_patterns.append(patterns)
    
    def extract_title(self, content):
        """Extract HTML title"""
        try:
            text = content.decode('utf-8', errors='ignore')
            match = re.search(r'<title>(.*?)</title>', text, re.IGNORECASE)
            return match.group(1) if match else None
        except:
            return None
    
    def extract_keywords(self, content):
        """Extract keywords for pattern matching"""
        try:
            text = content.decode('utf-8', errors='ignore')
            # Common 404 indicators
            keywords = ['not found', '404', 'error', 'does not exist', 'page not found']
            found = [kw for kw in keywords if kw.lower() in text.lower()]
            return found
        except:
            return []
    
    def is_false_positive(self, response, path):
        """Intelligent false positive detection"""
        
        # Check against known 404 patterns
        for pattern in self.custom_404_patterns:
            # Check content length similarity
            if abs(len(response['content']) - pattern['content_length']) < 50:
                return True
            
            # Check content hash
            if hashlib.md5(response['content']).hexdigest() == pattern['content_hash']:
                return True
            
            # Check title match
            current_title = self.extract_title(response['content'])
            if current_title and pattern['title'] and current_title == pattern['title']:
                if '404' in current_title or 'not found' in current_title.lower():
                    return True
        
        # Check for generic error messages
        content_text = response['content'].decode('utf-8', errors='ignore').lower()
        error_indicators = [
            'page not found',
            'file not found', 
            'path not found',
            '404 not found',
            'the requested url was not found',
            'object not found',
            'error 404'
        ]
        
        for indicator in error_indicators:
            if indicator in content_text:
                return True
        
        # Check response clustering
        return self.check_response_cluster(response)
    
    def check_response_cluster(self, response):
        """Check if response belongs to a false positive cluster"""
        content_length = len(response['content'])
        
        # Group responses by similar content length
        for cluster_size, responses in self.response_clusters.items():
            if abs(content_length - cluster_size) < 100:
                # Check if this cluster is likely false positives
                if len(responses) > 5:  # If many similar responses
                    return True
        
        # Add to cluster
        self.response_clusters[content_length].append(response)
        return False
    
    def detect_rate_limiting(self, response):
        """Detect rate limiting responses"""
        if response['status_code'] == 429:
            return True
        
        content_text = response['content'].decode('utf-8', errors='ignore').lower()
        rate_limit_indicators = [
            'rate limit',
            'too many requests',
            'slow down',
            'throttled',
            'exceeded quota'
        ]
        
        return any(indicator in content_text for indicator in rate_limit_indicators)
    
    def detect_technology(self, response):
        """Detect web technologies from response"""
        technologies = []
        headers = response.get('headers', {})
        
        # Server detection
        server = headers.get('Server', '').lower()
        if 'apache' in server:
            technologies.append('Apache')
        elif 'nginx' in server:
            technologies.append('Nginx')
        elif 'iis' in server:
            technologies.append('IIS')
        
        # Framework detection
        if 'X-Powered-By' in headers:
            technologies.append(headers['X-Powered-By'])
        
        # CMS detection from content
        content_text = response['content'].decode('utf-8', errors='ignore')
        if 'wp-content' in content_text or 'wordpress' in content_text.lower():
            technologies.append('WordPress')
        elif 'joomla' in content_text.lower():
            technologies.append('Joomla')
        elif 'drupal' in content_text.lower():
            technologies.append('Drupal')
        
        return technologies

class SmartHTTPClient:
    """Advanced HTTP client with intelligent features"""
    
    def __init__(self, timeout=10, delay=0, user_agent=None, cookies=None, 
                 auth=None, proxy=None, custom_headers=None):
        self.timeout = timeout
        self.delay = delay
        self.user_agent = user_agent or self.get_random_user_agent()
        self.cookies = cookies
        self.auth = auth
        self.proxy = proxy
        self.custom_headers = custom_headers or {}
        self.request_count = 0
        self.last_request_time = 0
        
    def get_random_user_agent(self):
        """Get random user agent"""
        agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36"
        ]
        return random.choice(agents)
    
    def request(self, url, method="GET", follow_redirects=False, custom_headers=None):
        """Make intelligent HTTP request"""
        
        # Rate limiting
        if self.delay > 0:
            current_time = time.time()
            time_since_last = current_time - self.last_request_time
            if time_since_last < self.delay:
                time.sleep(self.delay - time_since_last)
            self.last_request_time = time.time()
        
        parsed = urlparse(url)
        
        # Setup connection
        if parsed.scheme == 'https':
            if self.proxy:
                # Proxy support for HTTPS
                conn = http.client.HTTPSConnection(
                    self.proxy.split(':')[0],
                    int(self.proxy.split(':')[1]) if ':' in self.proxy else 8080,
                    timeout=self.timeout,
                    context=ssl._create_unverified_context()
                )
            else:
                conn = http.client.HTTPSConnection(
                    parsed.netloc,
                    timeout=self.timeout,
                    context=ssl._create_unverified_context()
                )
        else:
            if self.proxy:
                conn = http.client.HTTPConnection(
                    self.proxy.split(':')[0],
                    int(self.proxy.split(':')[1]) if ':' in self.proxy else 8080,
                    timeout=self.timeout
                )
            else:
                conn = http.client.HTTPConnection(parsed.netloc, timeout=self.timeout)
        
        # Build path
        path = parsed.path or '/'
        if parsed.query:
            path += '?' + parsed.query
        
        # Build headers
        headers = {
            'User-Agent': self.user_agent,
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'close',
            'Cache-Control': 'max-age=0'
        }
        
        # Add custom headers
        headers.update(self.custom_headers)
        if custom_headers:
            headers.update(custom_headers)
        
        # Add cookies
        if self.cookies:
            headers['Cookie'] = self.cookies
        
        # Add authentication
        if self.auth:
            import base64
            auth_string = base64.b64encode(f"{self.auth[0]}:{self.auth[1]}".encode()).decode()
            headers['Authorization'] = f"Basic {auth_string}"
        
        try:
            # Make request
            if self.proxy and parsed.scheme == 'https':
                conn.set_tunnel(parsed.netloc)
            
            conn.request(method, path if not self.proxy else url, headers=headers)
            response = conn.getresponse()
            
            # Read response
            status_code = response.status
            response_headers = dict(response.getheaders())
            
            # Handle encoding
            content = response.read()
            
            # Decompress if needed
            if response_headers.get('Content-Encoding') == 'gzip':
                import gzip
                content = gzip.decompress(content)
            
            conn.close()
            
            self.request_count += 1
            
            # Handle redirects
            if follow_redirects and status_code in [301, 302, 303, 307, 308]:
                location = response_headers.get('Location', '')
                if location:
                    if not location.startswith('http'):
                        location = urljoin(url, location)
                    return self.request(location, method, follow_redirects, custom_headers)
            
            return {
                'status_code': status_code,
                'headers': response_headers,
                'content': content,
                'url': url,
                'method': method
            }
            
        except socket.timeout:
            return {'error': 'timeout', 'url': url}
        except socket.error as e:
            return {'error': str(e), 'url': url}
        except Exception as e:
            return {'error': str(e), 'url': url}
        finally:
            try:
                conn.close()
            except:
                pass

class WebHunter:
    """Main scanning engine with intelligent discovery"""
    
    def __init__(self):
        self.target_url = None
        self.wordlist = []
        self.extensions = []
        self.threads = 50
        self.timeout = 10
        self.delay = 0
        self.recursive = False
        self.recursive_depth = 2
        self.http_client = None
        self.detector = IntelligentDetector()
        
        # Results
        self.found_dirs = []
        self.found_files = []
        self.interesting_findings = []
        self.technologies = set()
        
        # Statistics
        self.start_time = None
        self.total_requests = 0
        self.successful = 0
        self.failed = 0
        self.errors = 0
        
        # Status tracking
        self.status_codes = Counter()
        self.response_times = []
        self.scan_queue = []
        self.scanned_paths = set()
    
    def interactive_setup(self):
        """Interactive setup wizard"""
        Console.print_banner()
        
        # Step 1: Target Configuration
        Console.section("TARGET CONFIGURATION")
        
        while True:
            target = input(f"{Console.QUESTION} Enter target URL (e.g., http://example.com): ").strip()
            
            if not target:
                print(f"{Console.ERROR} Target URL cannot be empty!")
                continue
            
            # Normalize URL
            if not target.startswith(('http://', 'https://')):
                target = 'http://' + target
            
            # Validate URL
            try:
                parsed = urlparse(target)
                if not parsed.netloc:
                    print(f"{Console.ERROR} Invalid URL format!")
                    continue
                
                # Test connection
                print(f"{Console.INFO} Testing connection to {target}...")
                test_client = SmartHTTPClient(timeout=5)
                response = test_client.request(target)
                
                if response and 'error' not in response:
                    print(f"{Console.SUCCESS} Connection successful! Status: {response['status_code']}")
                    self.target_url = target.rstrip('/')
                    
                    # Detect technologies
                    techs = self.detector.detect_technology(response)
                    if techs:
                        print(f"{Console.INFO} Detected technologies: {', '.join(techs)}")
                        self.technologies.update(techs)
                    break
                else:
                    error = response.get('error', 'Connection failed')
                    print(f"{Console.ERROR} Connection failed: {error}")
                    retry = input(f"{Console.QUESTION} Try again? (y/n): ").lower()
                    if retry != 'y':
                        sys.exit(1)
                        
            except Exception as e:
                print(f"{Console.ERROR} Error: {e}")
                continue
        
        # Step 2: Wordlist Configuration
        Console.section("WORDLIST CONFIGURATION")
        
        while True:
            wordlist_path = input(f"{Console.QUESTION} Enter wordlist file path: ").strip()
            
            if not wordlist_path:
                print(f"{Console.ERROR} Wordlist path cannot be empty!")
                continue
            
            if not os.path.exists(wordlist_path):
                print(f"{Console.ERROR} File not found: {wordlist_path}")
                continue
            
            try:
                with open(wordlist_path, 'r', encoding='utf-8', errors='ignore') as f:
                    self.wordlist = [line.strip() for line in f if line.strip()]
                
                print(f"{Console.SUCCESS} Loaded {len(self.wordlist)} words from wordlist")
                
                # Show sample
                if len(self.wordlist) > 5:
                    print(f"{Console.INFO} Sample entries: {', '.join(self.wordlist[:5])}...")
                
                break
                
            except Exception as e:
                print(f"{Console.ERROR} Error loading wordlist: {e}")
                continue
        
        # Step 3: Extension Configuration
        Console.section("FILE EXTENSION CONFIGURATION")
        
        ext_input = input(f"{Console.QUESTION} Enter file extensions to test "
                         f"(comma-separated, e.g., .php,.txt or press Enter for none): ").strip()
        
        if ext_input:
            self.extensions = [ext.strip() for ext in ext_input.split(',')]
            self.extensions = [ext if ext.startswith('.') else f'.{ext}' for ext in self.extensions]
            print(f"{Console.SUCCESS} Will test {len(self.extensions)} extensions: {', '.join(self.extensions)}")
        else:
            print(f"{Console.INFO} No file extensions configured (directories only)")
        
        # Step 4: Recursion Configuration
        Console.section("RECURSIVE SCANNING")
        
        recursive = input(f"{Console.QUESTION} Enable recursive scanning? (y/N): ").strip().lower()
        
        if recursive == 'y':
            self.recursive = True
            depth = input(f"{Console.QUESTION} Maximum recursion depth (default: 2): ").strip()
            
            try:
                self.recursive_depth = int(depth) if depth else 2
                print(f"{Console.SUCCESS} Recursive scanning enabled (depth: {self.recursive_depth})")
            except:
                self.recursive_depth = 2
                print(f"{Console.WARNING} Using default depth: 2")
        else:
            print(f"{Console.INFO} Recursive scanning disabled")
        
        # Step 5: Advanced Configuration
        Console.section("ADVANCED CONFIGURATION")
        
        # Threads
        threads = input(f"{Console.QUESTION} Number of threads (default: 50): ").strip()
        try:
            self.threads = int(threads) if threads else 50
            self.threads = max(1, min(200, self.threads))  # Limit between 1-200
        except:
            self.threads = 50
        print(f"{Console.INFO} Using {self.threads} threads")
        
        # Timeout
        timeout = input(f"{Console.QUESTION} Request timeout in seconds (default: 10): ").strip()
        try:
            self.timeout = float(timeout) if timeout else 10
        except:
            self.timeout = 10
        print(f"{Console.INFO} Timeout: {self.timeout}s")
        
        # Delay between requests
        delay = input(f"{Console.QUESTION} Delay between requests in seconds (default: 0): ").strip()
        try:
            self.delay = float(delay) if delay else 0
        except:
            self.delay = 0
        
        if self.delay > 0:
            print(f"{Console.INFO} Delay: {self.delay}s between requests")
        
        # Authentication
        Console.section("AUTHENTICATION (Optional)")
        
        auth_type = input(f"{Console.QUESTION} Authentication type (none/basic/cookie) [none]: ").strip().lower()
        
        auth = None
        cookies = None
        
        if auth_type == 'basic':
            username = input(f"{Console.QUESTION} Username: ").strip()
            password = input(f"{Console.QUESTION} Password: ").strip()
            if username and password:
                auth = (username, password)
                print(f"{Console.SUCCESS} Basic authentication configured")
        
        elif auth_type == 'cookie':
            cookie_string = input(f"{Console.QUESTION} Cookie string: ").strip()
            if cookie_string:
                cookies = cookie_string
                print(f"{Console.SUCCESS} Cookie authentication configured")
        
        # Custom headers
        custom_headers = {}
        add_headers = input(f"{Console.QUESTION} Add custom headers? (y/N): ").strip().lower()
        
        if add_headers == 'y':
            print(f"{Console.INFO} Enter headers (format: Header: Value), empty line to finish:")
            while True:
                header = input(f"  > ").strip()
                if not header:
                    break
                if ':' in header:
                    key, value = header.split(':', 1)
                    custom_headers[key.strip()] = value.strip()
                    print(f"    Added: {key.strip()}")
        
        # Proxy
        proxy = input(f"{Console.QUESTION} Proxy server (e.g., 127.0.0.1:8080) [none]: ").strip()
        
        # Create HTTP client with configuration
        self.http_client = SmartHTTPClient(
            timeout=self.timeout,
            delay=self.delay,
            cookies=cookies,
            auth=auth,
            proxy=proxy if proxy else None,
            custom_headers=custom_headers
        )
        
        # Step 6: Output Configuration
        Console.section("OUTPUT CONFIGURATION")
        
        self.output_format = input(f"{Console.QUESTION} Output format (txt/json/html/all) [all]: ").strip().lower()
        if not self.output_format:
            self.output_format = 'all'
        
        print(f"{Console.SUCCESS} Configuration complete!")
        
        # Summary
        Console.section("SCAN CONFIGURATION SUMMARY")
        print(f"  Target:     {self.target_url}")
        print(f"  Wordlist:   {len(self.wordlist)} entries")
        print(f"  Extensions: {len(self.extensions)} extensions")
        print(f"  Recursive:  {'Yes (depth: ' + str(self.recursive_depth) + ')' if self.recursive else 'No'}")
        print(f"  Threads:    {self.threads}")
        print(f"  Timeout:    {self.timeout}s")
        print(f"  Delay:      {self.delay}s")
        
        total_requests = len(self.wordlist) * (1 + len(self.extensions))
        print(f"\\n  Estimated requests: {total_requests}")
        
        confirm = input(f"\\n{Console.QUESTION} Start scanning? (Y/n): ").strip().lower()
        
        if confirm == 'n':
            print(f"{Console.WARNING} Scan cancelled by user")
            sys.exit(0)
    
    def scan(self):
        """Main scanning function"""
        self.start_time = datetime.now()
        
        # Establish baseline
        self.detector.establish_baseline(self.http_client, self.target_url)
        
        # Build scan queue
        Console.section("BUILDING SCAN QUEUE")
        
        for word in self.wordlist:
            # Add directory
            self.scan_queue.append((word, 'dir', 0))
            
            # Add with extensions
            for ext in self.extensions:
                self.scan_queue.append((f"{word}{ext}", 'file', 0))
        
        total_items = len(self.scan_queue)
        print(f"{Console.SUCCESS} Queue built: {total_items} items to scan")
        
        # Start scanning
        Console.section("SCANNING IN PROGRESS")
        print(f"{Console.INFO} Press Ctrl+C to stop scanning\\n")
        
        try:
            with ThreadPoolExecutor(max_workers=self.threads) as executor:
                futures = []
                
                while self.scan_queue or futures:
                    # Submit new tasks
                    while self.scan_queue and len(futures) < self.threads:
                        item = self.scan_queue.pop(0)
                        future = executor.submit(self.scan_path, *item)
                        futures.append(future)
                    
                    # Process completed tasks
                    done = []
                    for future in futures[:]:
                        if future.done():
                            try:
                                result = future.result(timeout=0.1)
                                if result:
                                    self.process_result(result)
                            except:
                                pass
                            futures.remove(future)
                            done.append(future)
                    
                    # Update progress
                    scanned = self.total_requests
                    Console.progress_bar(scanned, total_items, 
                                        extra=f"Found: {len(self.found_dirs) + len(self.found_files)}")
                    
                    time.sleep(0.1)
        
        except KeyboardInterrupt:
            print(f"\\n\\n{Console.WARNING} Scan interrupted by user")
        
        # Final results
        self.show_results()
        self.save_results()
    
    def scan_path(self, path, path_type, depth):
        """Scan a single path"""
        if depth > self.recursive_depth:
            return None
        
        # Skip if already scanned
        full_path = f"{self.target_url}/{path}".replace('//', '/')
        if full_path in self.scanned_paths:
            return None
        
        self.scanned_paths.add(full_path)
        
        # Make request
        url = urljoin(self.target_url + '/', path)
        response = self.http_client.request(url)
        
        self.total_requests += 1
        
        if not response or 'error' in response:
            self.errors += 1
            return None
        
        # Update statistics
        self.status_codes[response['status_code']] += 1
        
        # Check if valid response
        if response['status_code'] in [200, 201, 204, 301, 302, 307, 308, 401, 403, 405]:
            # Check for false positives
            if self.detector.is_false_positive(response, path):
                self.failed += 1
                return None
            
            # Valid finding
            self.successful += 1
            
            result = {
                'url': url,
                'path': path,
                'type': path_type,
                'status': response['status_code'],
                'size': len(response['content']),
                'title': self.detector.extract_title(response['content']),
                'server': response['headers'].get('Server', 'Unknown'),
                'technologies': self.detector.detect_technology(response),
                'depth': depth,
                'timestamp': datetime.now()
            }
            
            # Check if interesting
            if self.is_interesting(path, response):
                result['interesting'] = True
                self.interesting_findings.append(result)
            
            # Add to results
            if path_type == 'dir':
                self.found_dirs.append(result)
                
                # Add to recursive queue if enabled
                if self.recursive and depth < self.recursive_depth:
                    # Add subdirectory items to queue
                    for word in self.wordlist:
                        new_path = f"{path}/{word}".replace('//', '/')
                        self.scan_queue.append((new_path, 'dir', depth + 1))
                        
                        for ext in self.extensions:
                            new_path_ext = f"{path}/{word}{ext}".replace('//', '/')
                            self.scan_queue.append((new_path_ext, 'file', depth + 1))
            else:
                self.found_files.append(result)
            
            return result
        
        self.failed += 1
        return None
    
    def process_result(self, result):
        """Process and display found result"""
        if not result:
            return
        
        # Build status string
        status_name, status_desc, _ = HTTPStatus.get_status_info(result['status'])
        color = HTTPStatus.get_color(result['status'])
        
        # Build output
        output = f"\\n{Console.FOUND} {result['url']}"
        output += f"\\n  Status: {color}{result['status']} {status_name}{Console.END}"
        output += f" | Size: {result['size']} bytes"
        
        if result['title']:
            output += f"\\n  Title: {result['title']}"
        
        if result['technologies']:
            output += f"\\n  Tech: {', '.join(result['technologies'])}"
        
        if result.get('interesting'):
            output += f"\\n  {Console.WARNING} INTERESTING FINDING!"
        
        print(output)
    
    def is_interesting(self, path, response):
        """Check if finding is interesting"""
        interesting_patterns = [
            # Sensitive files
            r'\\.env', r'\\.git', r'\\.svn', r'\\.htaccess', r'\\.htpasswd',
            r'config\\.', r'database\\.', r'db\\.', r'backup', r'\\.bak',
            r'\\.old', r'\\.save', r'\\.swp', r'\\.key', r'\\.pem', r'\\.crt',
            
            # Admin/Auth
            r'admin', r'login', r'auth', r'portal', r'dashboard',
            r'cpanel', r'phpmyadmin', r'manager',
            
            # API/Services  
            r'api', r'rest', r'graphql', r'swagger', r'wsdl',
            
            # Information disclosure
            r'phpinfo', r'info\\.php', r'test\\.php', r'debug',
            r'error', r'logs?', r'trace', r'stack'
        ]
        
        path_lower = path.lower()
        for pattern in interesting_patterns:
            if re.search(pattern, path_lower):
                return True
        
        # Check response content
        content_text = response['content'].decode('utf-8', errors='ignore').lower()
        
        # Directory listing
        if 'index of' in content_text or 'directory listing' in content_text:
            return True
        
        # Error messages with paths
        if 'fatal error' in content_text or 'warning:' in content_text:
            return True
        
        # Config files
        if 'password' in content_text or 'api_key' in content_text:
            return True
        
        return False
    
    def show_results(self):
        """Display final results"""
        duration = datetime.now() - self.start_time
        
        Console.section("SCAN COMPLETE")
        
        print(f"\\n{Console.BOLD}Statistics:{Console.END}")
        print(f"  Duration:        {duration}")
        print(f"  Total Requests:  {self.total_requests}")
        print(f"  Successful:      {self.successful}")
        print(f"  Failed:          {self.failed}")
        print(f"  Errors:          {self.errors}")
        print(f"  Requests/sec:    {self.total_requests / duration.total_seconds():.2f}")
        
        print(f"\\n{Console.BOLD}Findings:{Console.END}")
        print(f"  Directories:     {len(self.found_dirs)}")
        print(f"  Files:           {len(self.found_files)}")
        print(f"  Interesting:     {len(self.interesting_findings)}")
        
        print(f"\\n{Console.BOLD}Status Code Distribution:{Console.END}")
        for code, count in sorted(self.status_codes.items()):
            status_name, _, _ = HTTPStatus.get_status_info(code)
            color = HTTPStatus.get_color(code)
            print(f"  {color}{code} {status_name:{20}} {count:5} requests{Console.END}")
        
        if self.technologies:
            print(f"\\n{Console.BOLD}Detected Technologies:{Console.END}")
            for tech in self.technologies:
                print(f"  • {tech}")
        
        if self.interesting_findings:
            print(f"\\n{Console.BOLD}{Console.YELLOW}Interesting Findings:{Console.END}")
            for finding in self.interesting_findings[:10]:  # Show top 10
                print(f"  • {finding['url']}")
    
    def save_results(self):
        """Save results to file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        domain = urlparse(self.target_url).netloc.replace(':', '_')
        
        if self.output_format in ['txt', 'all']:
            self.save_text_report(f"webhunter_{domain}_{timestamp}.txt")
        
        if self.output_format in ['json', 'all']:
            self.save_json_report(f"webhunter_{domain}_{timestamp}.json")
        
        if self.output_format in ['html', 'all']:
            self.save_html_report(f"webhunter_{domain}_{timestamp}.html")
    
    def save_text_report(self, filename):
        """Save text report"""
        try:
            with open(filename, 'w') as f:
                f.write("="*80 + "\\n")
                f.write("WEBHUNTER SCAN REPORT\\n")
                f.write("="*80 + "\\n\\n")
                
                f.write(f"Target: {self.target_url}\\n")
                f.write(f"Date: {datetime.now()}\\n")
                f.write(f"Duration: {datetime.now() - self.start_time}\\n")
                f.write(f"Total Requests: {self.total_requests}\\n")
                f.write(f"Found: {len(self.found_dirs) + len(self.found_files)} items\\n")
                f.write("\\n" + "="*80 + "\\n\\n")
                
                if self.found_dirs:
                    f.write("DIRECTORIES FOUND:\\n")
                    f.write("-"*40 + "\\n")
                    for item in sorted(self.found_dirs, key=lambda x: x['path']):
                        f.write(f"[{item['status']}] {item['url']}\\n")
                        if item.get('title'):
                            f.write(f"     Title: {item['title']}\\n")
                    f.write("\\n")
                
                if self.found_files:
                    f.write("FILES FOUND:\\n")
                    f.write("-"*40 + "\\n")
                    for item in sorted(self.found_files, key=lambda x: x['path']):
                        f.write(f"[{item['status']}] {item['url']}\\n")
                        f.write(f"     Size: {item['size']} bytes\\n")
                    f.write("\\n")
                
                if self.interesting_findings:
                    f.write("INTERESTING FINDINGS:\\n")
                    f.write("-"*40 + "\\n")
                    for item in self.interesting_findings:
                        f.write(f"[{item['status']}] {item['url']}\\n")
                        if item.get('title'):
                            f.write(f"     Title: {item['title']}\\n")
                    f.write("\\n")
            
            print(f"{Console.SUCCESS} Text report saved: {filename}")
            
        except Exception as e:
            print(f"{Console.ERROR} Failed to save text report: {e}")
    
    def save_json_report(self, filename):
        """Save JSON report"""
        try:
            report = {
                'scan_info': {
                    'target': self.target_url,
                    'start_time': str(self.start_time),
                    'end_time': str(datetime.now()),
                    'duration': str(datetime.now() - self.start_time),
                    'total_requests': self.total_requests,
                    'successful': self.successful,
                    'failed': self.failed,
                    'errors': self.errors
                },
                'technologies': list(self.technologies),
                'directories': [
                    {
                        'url': d['url'],
                        'path': d['path'],
                        'status': d['status'],
                        'size': d['size'],
                        'title': d.get('title'),
                        'depth': d['depth']
                    } for d in self.found_dirs
                ],
                'files': [
                    {
                        'url': f['url'],
                        'path': f['path'],
                        'status': f['status'],
                        'size': f['size'],
                        'title': f.get('title')
                    } for f in self.found_files
                ],
                'interesting': [
                    {
                        'url': i['url'],
                        'path': i['path'],
                        'status': i['status'],
                        'type': i['type']
                    } for i in self.interesting_findings
                ]
            }
            
            with open(filename, 'w') as f:
                json.dump(report, f, indent=2, default=str)
            
            print(f"{Console.SUCCESS} JSON report saved: {filename}")
            
        except Exception as e:
            print(f"{Console.ERROR} Failed to save JSON report: {e}")
    
    def save_html_report(self, filename):
        """Save HTML report"""
        try:
            html = """<!DOCTYPE html>
<html>
<head>
    <title>WebHunter Scan Report</title>
    <style>
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }
        h2 {
            color: #555;
            margin-top: 30px;
            background: #f8f9fa;
            padding: 10px;
            border-left: 4px solid #667eea;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #dee2e6;
        }
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }
        .stat-label {
            color: #6c757d;
            margin-top: 5px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th {
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: left;
        }
        td {
            padding: 10px;
            border-bottom: 1px solid #dee2e6;
        }
        tr:hover {
            background: #f8f9fa;
        }
        .status-200 { color: #28a745; font-weight: bold; }
        .status-301, .status-302 { color: #17a2b8; }
        .status-401, .status-403 { color: #ffc107; }
        .status-404 { color: #dc3545; }
        .interesting {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 10px;
            margin: 10px 0;
        }
        .tech-badge {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            margin: 2px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔍 WebHunter Scan Report</h1>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-value">""" + str(self.total_requests) + """</div>
                <div class="stat-label">Total Requests</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">""" + str(len(self.found_dirs)) + """</div>
                <div class="stat-label">Directories Found</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">""" + str(len(self.found_files)) + """</div>
                <div class="stat-label">Files Found</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">""" + str(len(self.interesting_findings)) + """</div>
                <div class="stat-label">Interesting Findings</div>
            </div>
        </div>
        
        <h2>Target Information</h2>
        <p><strong>URL:</strong> """ + self.target_url + """</p>
        <p><strong>Scan Date:</strong> """ + str(datetime.now()) + """</p>
        <p><strong>Duration:</strong> """ + str(datetime.now() - self.start_time) + """</p>
"""
            
            if self.technologies:
                html += "<p><strong>Technologies:</strong> "
                for tech in self.technologies:
                    html += f'<span class="tech-badge">{tech}</span>'
                html += "</p>"
            
            if self.interesting_findings:
                html += """
        <h2>⚠️ Interesting Findings</h2>
        <div class="interesting">
"""
                for finding in self.interesting_findings[:20]:
                    html += f"""
            <div style="margin: 10px 0;">
                <strong>{finding['url']}</strong><br>
                Status: <span class="status-{finding['status']}">{finding['status']}</span> | 
                Type: {finding['type']} | 
                Size: {finding['size']} bytes
            </div>
"""
                html += "        </div>"
            
            if self.found_dirs:
                html += """
        <h2>Directories Found</h2>
        <table>
            <tr>
                <th>Path</th>
                <th>Status</th>
                <th>Size</th>
                <th>Title</th>
            </tr>
"""
                for d in sorted(self.found_dirs, key=lambda x: x['path']):
                    html += f"""
            <tr>
                <td><a href="{d['url']}" target="_blank">{d['path']}</a></td>
                <td class="status-{d['status']}">{d['status']}</td>
                <td>{d['size']} bytes</td>
                <td>{d.get('title', '-')}</td>
            </tr>
"""
                html += "        </table>"
            
            if self.found_files:
                html += """
        <h2>Files Found</h2>
        <table>
            <tr>
                <th>Path</th>
                <th>Status</th>
                <th>Size</th>
                <th>Title</th>
            </tr>
"""
                for f in sorted(self.found_files, key=lambda x: x['path']):
                    html += f"""
            <tr>
                <td><a href="{f['url']}" target="_blank">{f['path']}</a></td>
                <td class="status-{f['status']}">{f['status']}</td>
                <td>{f['size']} bytes</td>
                <td>{f.get('title', '-')}</td>
            </tr>
"""
                html += "        </table>"
            
            html += """
    </div>
</body>
</html>
"""
            
            with open(filename, 'w') as f:
                f.write(html)
            
            print(f"{Console.SUCCESS} HTML report saved: {filename}")
            
        except Exception as e:
            print(f"{Console.ERROR} Failed to save HTML report: {e}")

def main():
    """Main entry point"""
    try:
        scanner = WebHunter()
        scanner.interactive_setup()
        scanner.scan()
        
    except KeyboardInterrupt:
        print(f"\\n\\n{Console.WARNING} Scan interrupted by user")
        sys.exit(0)
    except Exception as e:
        print(f"\\n{Console.ERROR} Fatal error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main(            "ports": [80, 443, 8080, 8443, 8000, 8888, 3000, 5000, 9000, 9090, 9200],
            "threads": 50,
            "timeout": 2.0,
            "banner": True
        },
        "5": {
            "name": "Database Services",
            "description": "Focus on database ports",
            "ports": [1433, 1521, 3306, 5432, 5984, 6379, 7000, 7001, 8086, 9042, 27017, 28015],
            "threads": 50,
            "timeout": 2.0,
            "banner": True
        },
        "6": {
            "name": "Custom Scan",
            "description": "Define your own parameters",
            "ports": None,
            "threads": None,
            "timeout": None,
            "banner": None
        }
    }

class ServiceDatabase:
    """Enhanced service detection database"""
    
    SERVICES = {
        20: ("FTP-DATA", "File Transfer Protocol (Data)"),
        21: ("FTP", "File Transfer Protocol (Control)"),
        22: ("SSH", "Secure Shell"),
        23: ("Telnet", "Telnet Protocol"),
        25: ("SMTP", "Simple Mail Transfer Protocol"),
        53: ("DNS", "Domain Name System"),
        67: ("DHCP", "Dynamic Host Configuration Protocol (Server)"),
        68: ("DHCP", "Dynamic Host Configuration Protocol (Client)"),
        69: ("TFTP", "Trivial File Transfer Protocol"),
        80: ("HTTP", "HyperText Transfer Protocol"),
        88: ("Kerberos", "Kerberos Authentication"),
        110: ("POP3", "Post Office Protocol v3"),
        111: ("RPC", "Remote Procedure Call"),
        119: ("NNTP", "Network News Transfer Protocol"),
        123: ("NTP", "Network Time Protocol"),
        135: ("MS-RPC", "Microsoft RPC"),
        137: ("NetBIOS-NS", "NetBIOS Name Service"),
        138: ("NetBIOS-DGM", "NetBIOS Datagram Service"),
        139: ("NetBIOS-SSN", "NetBIOS Session Service"),
        143: ("IMAP", "Internet Message Access Protocol"),
        161: ("SNMP", "Simple Network Management Protocol"),
        162: ("SNMP-Trap", "SNMP Trap"),
        389: ("LDAP", "Lightweight Directory Access Protocol"),
        443: ("HTTPS", "HTTP Secure"),
        445: ("SMB", "Server Message Block"),
        465: ("SMTPS", "SMTP Secure"),
        514: ("Syslog", "System Logging Protocol"),
        515: ("LPD", "Line Printer Daemon"),
        587: ("SMTP-Submission", "SMTP Mail Submission"),
        631: ("IPP", "Internet Printing Protocol"),
        636: ("LDAPS", "LDAP Secure"),
        873: ("Rsync", "Remote Sync"),
        993: ("IMAPS", "IMAP Secure"),
        995: ("POP3S", "POP3 Secure"),
        1080: ("SOCKS", "SOCKS Proxy"),
        1433: ("MS-SQL", "Microsoft SQL Server"),
        1434: ("MS-SQL-Browser", "MS SQL Server Browser"),
        1521: ("Oracle", "Oracle Database"),
        1723: ("PPTP", "Point-to-Point Tunneling Protocol"),
        2049: ("NFS", "Network File System"),
        2082: ("cPanel", "cPanel Control Panel"),
        2083: ("cPanel-SSL", "cPanel SSL"),
        2086: ("WHM", "Web Host Manager"),
        2087: ("WHM-SSL", "WHM SSL"),
        3128: ("Squid", "Squid Proxy Server"),
        3306: ("MySQL", "MySQL Database"),
        3389: ("RDP", "Remote Desktop Protocol"),
        4444: ("Metasploit", "Metasploit Default"),
        5060: ("SIP", "Session Initiation Protocol"),
        5432: ("PostgreSQL", "PostgreSQL Database"),
        5900: ("VNC", "Virtual Network Computing"),
        5984: ("CouchDB", "CouchDB Database"),
        6379: ("Redis", "Redis Database"),
        6667: ("IRC", "Internet Relay Chat"),
        7000: ("Cassandra", "Apache Cassandra"),
        8000: ("HTTP-Alt", "HTTP Alternate"),
        8080: ("HTTP-Proxy", "HTTP Proxy"),
        8086: ("InfluxDB", "InfluxDB Database"),
        8443: ("HTTPS-Alt", "HTTPS Alternate"),
        8888: ("HTTP-Alt2", "HTTP Alternate 2"),
        9000: ("SonarQube", "SonarQube"),
        9042: ("Cassandra-Native", "Cassandra Native"),
        9090: ("WebSM", "Web-based System Manager"),
        9200: ("Elasticsearch", "Elasticsearch"),
        11211: ("Memcached", "Memcached"),
        27017: ("MongoDB", "MongoDB Database"),
        28015: ("RethinkDB", "RethinkDB Database"),
        50000: ("SAP", "SAP Router")
    }
    
    # Top 1000 ports for standard scanning
    TOP_1000 = [1, 3, 4, 6, 7, 9, 13, 17, 19, 20, 21, 22, 23, 24, 25, 26, 30, 32, 33, 37, 42, 43, 49, 53, 70, 79, 80, 81, 82, 83, 84, 85, 88, 89, 90, 99, 100, 106, 109, 110, 111, 113, 119, 125, 135, 139, 143, 144, 146, 161, 163, 179, 199, 211, 212, 222, 254, 255, 256, 259, 264, 280, 301, 306, 311, 340, 366, 389, 406, 407, 416, 417, 425, 427, 443, 444, 445, 458, 464, 465, 481, 497, 500, 512, 513, 514, 515, 524, 541, 543, 544, 545, 548, 554, 555, 563, 587, 593, 616, 617, 625, 631, 636, 646, 648, 666, 667, 668, 683, 687, 691, 700, 705, 711, 714, 720, 722, 726, 749, 765, 777, 783, 787, 800, 801, 808, 843, 873, 880, 888, 898, 900, 901, 902, 903, 911, 912, 981, 987, 990, 992, 993, 995, 999, 1000, 1001, 1002, 1007, 1009, 1010, 1011, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1102, 1104, 1105, 1106, 1107, 1108, 1110, 1111, 1112, 1113, 1114, 1117, 1119, 1121, 1122, 1123, 1124, 1126, 1130, 1131, 1132, 1137, 1138, 1141, 1145, 1147, 1148, 1149, 1151, 1152, 1154, 1163, 1164, 1165, 1166, 1169, 1174, 1175, 1183, 1185, 1186, 1187, 1192, 1198, 1199, 1201, 1213, 1216, 1217, 1218, 1233, 1234, 1236, 1244, 1247, 1248, 1259, 1271, 1272, 1277, 1287, 1296, 1300, 1301, 1309, 1310, 1311, 1322, 1328, 1334, 1352, 1417, 1433, 1434, 1443, 1455, 1461, 1494, 1500, 1501, 1503, 1521, 1524, 1533, 1556, 1580, 1583, 1594, 1600, 1641, 1658, 1666, 1687, 1688, 1700, 1717, 1718, 1719, 1720, 1721, 1723, 1755, 1761, 1782, 1783, 1801, 1805, 1812, 1839, 1840, 1862, 1863, 1864, 1875, 1900, 1914, 1935, 1947, 1971, 1972, 1974, 1984, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2013, 2020, 2021, 2022, 2030, 2033, 2034, 2035, 2038, 2040, 2041, 2042, 2043, 2045, 2046, 2047, 2048, 2049, 2065, 2068, 2099, 2100, 2103, 2105, 2106, 2107, 2111, 2119, 2121, 2126, 2135, 2144, 2160, 2161, 2170, 2179, 2190, 2191, 2196, 2200, 2222, 2251, 2260, 2288, 2301, 2323, 2366, 2381, 2382, 2383, 2393, 2394, 2399, 2401, 2492, 2500, 2522, 2525, 2557, 2601, 2602, 2604, 2605, 2607, 2608, 2638, 2701, 2702, 2710, 2717, 2718, 2725, 2800, 2809, 2811, 2869, 2875, 2909, 2910, 2920, 2967, 2968, 2998, 3000, 3001, 3003, 3005, 3006, 3007, 3011, 3013, 3017, 3030, 3031, 3052, 3071, 3077, 3128, 3168, 3211, 3221, 3260, 3261, 3268, 3269, 3283, 3300, 3301, 3306, 3322, 3323, 3324, 3325, 3333, 3351, 3367, 3369, 3370, 3371, 3372, 3389, 3390, 3404, 3476, 3493, 3517, 3527, 3546, 3551, 3580, 3659, 3689, 3690, 3703, 3737, 3766, 3784, 3800, 3801, 3809, 3814, 3826, 3827, 3828, 3851, 3869, 3871, 3878, 3880, 3889, 3905, 3914, 3918, 3920, 3945, 3971, 3986, 3995, 3998, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4045, 4111, 4125, 4126, 4129, 4224, 4242, 4279, 4321, 4343, 4443, 4444, 4445, 4446, 4449, 4550, 4567, 4662, 4848, 4899, 4900, 4998, 5000, 5001, 5002, 5003, 5004, 5009, 5030, 5033, 5050, 5051, 5054, 5060, 5061, 5080, 5087, 5100, 5101, 5102, 5120, 5190, 5200, 5214, 5221, 5222, 5225, 5226, 5269, 5280, 5298, 5357, 5405, 5414, 5431, 5432, 5440, 5500, 5510, 5544, 5550, 5555, 5560, 5566, 5631, 5633, 5666, 5678, 5679, 5718, 5730, 5800, 5801, 5802, 5810, 5811, 5815, 5822, 5825, 5850, 5859, 5862, 5877, 5900, 5901, 5902, 5903, 5904, 5906, 5907, 5910, 5911, 5915, 5922, 5925, 5950, 5952, 5959, 5960, 5961, 5962, 5963, 5987, 5988, 5989, 5998, 5999, 6000, 6001, 6002, 6003, 6004, 6005, 6006, 6007, 6009, 6025, 6059, 6100, 6101, 6106, 6112, 6123, 6129, 6156, 6346, 6389, 6502, 6510, 6543, 6547, 6565, 6566, 6567, 6580, 6646, 6666, 6667, 6668, 6669, 6689, 6692, 6699, 6779, 6788, 6789, 6792, 6839, 6881, 6901, 6969, 7000, 7001, 7002, 7004, 7007, 7019, 7025, 7070, 7100, 7103, 7106, 7200, 7201, 7402, 7435, 7443, 7496, 7512, 7625, 7627, 7676, 7741, 7777, 7778, 7800, 7911, 7920, 7921, 7937, 7938, 7999, 8000, 8001, 8002, 8007, 8008, 8009, 8010, 8011, 8021, 8022, 8031, 8042, 8045, 8080, 8081, 8082, 8083, 8084, 8085, 8086, 8087, 8088, 8089, 8090, 8093, 8099, 8100, 8180, 8181, 8192, 8193, 8194, 8200, 8222, 8254, 8290, 8291, 8292, 8300, 8333, 8383, 8400, 8402, 8443, 8500, 8600, 8649, 8651, 8652, 8654, 8701, 8800, 8873, 8888, 8899, 8994, 9000, 9001, 9002, 9003, 9009, 9010, 9011, 9040, 9050, 9071, 9080, 9081, 9090, 9091, 9099, 9100, 9101, 9102, 9103, 9110, 9111, 9200, 9207, 9220, 9290, 9415, 9418, 9485, 9500, 9502, 9503, 9535, 9575, 9593, 9594, 9595, 9618, 9666, 9876, 9877, 9878, 9898, 9900, 9917, 9929, 9943, 9944, 9968, 9998, 9999, 10000, 10001, 10002, 10003, 10004, 10009, 10010, 10012, 10024, 10025, 10082, 10180, 10215, 10243, 10566, 10616, 10617, 10621, 10626, 10628, 10629, 10778, 11110, 11111, 11967, 12000, 12174, 12265, 12345, 13456, 13722, 13782, 13783, 14000, 14238, 14441, 14442, 15000, 15002, 15003, 15004, 15660, 15742, 16000, 16001, 16012, 16016, 16018, 16080, 16113, 16992, 16993, 17877, 17988, 18040, 18101, 18988, 19101, 19283, 19315, 19350, 19780, 19801, 19842, 20000, 20005, 20031, 20221, 20222, 20828, 21571, 22939, 23502, 24444, 24800, 25734, 25735, 26214, 27000, 27352, 27353, 27355, 27356, 27715, 28201, 30000, 30718, 30951, 31038, 31337, 32768, 32769, 32770, 32771, 32772, 32773, 32774, 32775, 32776, 32777, 32778, 32779, 32780, 32781, 32782, 32783, 32784, 32785, 33354, 33899, 34571, 34572, 34573, 35500, 38292, 40193, 40911, 41511, 42510, 44176, 44442, 44443, 44501, 45100, 48080, 49152, 49153, 49154, 49155, 49156, 49157, 49158, 49159, 49160, 49161, 49163, 49165, 49167, 49175, 49176, 49400, 49999, 50000, 50001, 50002, 50003, 50006, 50300, 50389, 50500, 50636, 50800, 51103, 51493, 52673, 52822, 52848, 52869, 54045, 54328, 55055, 55056, 55555, 55600, 56737, 56738, 57294, 57797, 58080, 60020, 60443, 61532, 61900, 62078, 63331, 64623, 64680, 65000, 65129, 65389]

class InteractiveScanner:
    """Main interactive scanner class"""
    
    def __init__(self):
        self.targets = []
        self.ports = []
        self.threads = 100
        self.timeout = 1.0
        self.banner_grab = False
        self.output_formats = []
        self.results = []
        self.scanner = None
        self.total_ports_to_scan = 0
        self.ports_scanned = 0
        self.start_time = None
        
    def clear_screen(self):
        """Clear terminal screen"""
        os.system('cls' if os.name == 'nt' else 'clear')
    
    def print_banner(self):
        """Display the application banner"""
        self.clear_screen()
        print(Color.CYAN + BANNER + Color.END)
        time.sleep(1)
    
    def get_user_input(self, prompt, validator=None, default=None):
        """Get and validate user input"""
        while True:
            user_input = input(f"{Color.YELLOW}{prompt}{Color.END}").strip()
            
            if not user_input and default is not None:
                return default
            
            if validator:
                valid, result = validator(user_input)
                if valid:
                    return result
                else:
                    Color.print_error(f"Invalid input: {result}")
            else:
                return user_input
    
    def validate_ip_or_hostname(self, target):
        """Validate IP address or hostname"""
        # Check if it's an IP address
        try:
            ipaddress.ip_address(target)
            return True, target
        except ValueError:
            pass
        
        # Check if it's a CIDR notation
        try:
            network = ipaddress.ip_network(target, strict=False)
            return True, target
        except ValueError:
            pass
        
        # Check if it's a valid hostname
        try:
            socket.gethostbyname(target)
            return True, target
        except socket.gaierror:
            return False, f"Cannot resolve hostname: {target}"
    
    def validate_port_range(self, port_input):
        """Validate port range input"""
        try:
            if port_input.lower() == 'all':
                return True, list(range(1, 65536))
            elif port_input.lower() == 'top1000':
                return True, ServiceDatabase.TOP_1000
            elif '-' in port_input:
                start, end = map(int, port_input.split('-'))
                if 1 <= start <= 65535 and 1 <= end <= 65535 and start <= end:
                    return True, list(range(start, end + 1))
                else:
                    return False, "Port range must be between 1-65535"
            elif ',' in port_input:
                ports = []
                for p in port_input.split(','):
                    if '-' in p:
                        start, end = map(int, p.split('-'))
                        ports.extend(range(start, end + 1))
                    else:
                        ports.append(int(p))
                return True, sorted(set(ports))
            else:
                port = int(port_input)
                if 1 <= port <= 65535:
                    return True, [port]
                else:
                    return False, "Port must be between 1-65535"
        except ValueError:
            return False, "Invalid port format"
    
    def step1_welcome(self):
        """Step 1: Welcome and introduction"""
        self.print_banner()
        print(f"{Color.BOLD}Welcome to Advanced Port Scanner v3.0!{Color.END}\n")
        print("This tool will help you perform comprehensive network port scanning")
        print("with full coverage capabilities and professional reporting.\n")
        
        Color.print_info("Press Enter to continue...")
        input()
    
    def step2_select_profile(self):
        """Step 2: Select scan profile"""
        Color.print_header("STEP 1: SELECT SCAN PROFILE")
        print("\nAvailable scan profiles:\n")
        
        for key, profile in ScanProfile.PROFILES.items():
            print(f"  {Color.BOLD}[{key}]{Color.END} {profile['name']}")
            print(f"      {Color.DARKCYAN}{profile['description']}{Color.END}")
            print()
        
        choice = self.get_user_input(
            "\nSelect profile [1-6] (default: 2): ",
            validator=lambda x: (True, x) if x in ScanProfile.PROFILES else (False, "Invalid choice"),
            default="2"
        )
        
        selected_profile = ScanProfile.PROFILES[choice]
        Color.print_success(f"Selected: {selected_profile['name']}")
        
        return selected_profile
    
    def step3_configure_targets(self):
        """Step 3: Configure target hosts"""
        Color.print_header("STEP 2: CONFIGURE TARGET HOSTS")
        
        print("\nYou can enter:")
        print("  • Single IP: 192.168.1.1")
        print("  • Hostname: example.com")
        print("  • IP Range (CIDR): 192.168.1.0/24")
        print("  • Multiple targets (comma-separated): 192.168.1.1,192.168.1.2")
        print()
        
        while True:
            target_input = self.get_user_input(
                "Enter target(s): ",
                validator=None
            )
            
            if not target_input:
                Color.print_error("Target cannot be empty")
                continue
            
            # Parse multiple targets
            targets = []
            failed = []
            
            for target in target_input.split(','):
                target = target.strip()
                
                # Handle CIDR notation
                if '/' in target:
                    try:
                        network = ipaddress.ip_network(target, strict=False)
                        hosts = [str(ip) for ip in network.hosts()]
                        if hosts:
                            targets.extend(hosts)
                            Color.print_success(f"Added {len(hosts)} hosts from {target}")
                        else:
                            targets.append(str(network.network_address))
                            Color.print_success(f"Added network address {network.network_address}")
                    except ValueError as e:
                        failed.append((target, str(e)))
                else:
                    valid, result = self.validate_ip_or_hostname(target)
                    if valid:
                        targets.append(result)
                        Color.print_success(f"Added target: {result}")
                    else:
                        failed.append((target, result))
            
            if failed:
                Color.print_warning("Failed to add some targets:")
                for target, reason in failed:
                    print(f"  • {target}: {reason}")
            
            if targets:
                self.targets = targets
                print(f"\n{Color.GREEN}Total targets to scan: {len(self.targets)}{Color.END}")
                break
            else:
                Color.print_error("No valid targets added. Please try again.")
    
    def step4_configure_ports(self, profile):
        """Step 4: Configure ports to scan"""
        Color.print_header("STEP 3: CONFIGURE PORTS")
        
        if profile['ports'] == "all":
            self.ports = list(range(1, 65536))
            Color.print_info(f"Scanning ALL 65,535 ports for maximum coverage")
        elif profile['ports'] == "top1000":
            self.ports = ServiceDatabase.TOP_1000
            Color.print_info(f"Scanning top 1000 most common ports")
        elif profile['ports'] and profile['name'] != "Custom Scan":
            self.ports = profile['ports']
            Color.print_info(f"Scanning {len(self.ports)} predefined ports")
        else:
            print("\nPort configuration options:")
            print("  • Single port: 80")
            print("  • Port range: 1-1000")
            print("  • Multiple ports: 80,443,8080")
            print("  • Mixed: 80,443,1000-2000")
            print("  • All ports: all")
            print("  • Top 1000: top1000")
            print()
            
            port_input = self.get_user_input(
                "Enter ports to scan (default: top1000): ",
                validator=self.validate_port_range,
                default=ServiceDatabase.TOP_1000
            )
            
            self.ports = port_input
        
        print(f"\n{Color.GREEN}Total ports to scan: {len(self.ports)}{Color.END}")
        
        if len(self.ports) > 10000:
            Color.print_warning("Large number of ports selected. This may take some time.")
            confirm = self.get_user_input(
                "Continue? (Y/n): ",
                default="Y"
            )
            if confirm.lower() == 'n':
                return self.step4_configure_ports({"name": "Custom Scan", "ports": None})
    
    def step5_configure_advanced(self, profile):
        """Step 5: Configure advanced options"""
        Color.print_header("STEP 4: ADVANCED OPTIONS")
        
        # Thread configuration
        if profile['threads'] and profile['name'] != "Custom Scan":
            self.threads = profile['threads']
            Color.print_info(f"Using {self.threads} threads (profile default)")
        else:
            print(f"\nThread count affects scan speed:")
            print(f"  • Low (50): Slower but stealthier")
            print(f"  • Medium (100-200): Balanced")
            print(f"  • High (500+): Fast but may trigger alerts")
            
            thread_input = self.get_user_input(
                f"Number of threads (default: 100, max: 1000): ",
                validator=lambda x: (True, int(x)) if x.isdigit() and 1 <= int(x) <= 1000 else (False, "Must be 1-1000"),
                default=100
            )
            self.threads = thread_input
        
        # Timeout configuration
        if profile['timeout'] and profile['name'] != "Custom Scan":
            self.timeout = profile['timeout']
            Color.print_info(f"Using {self.timeout}s timeout (profile default)")
        else:
            timeout_input = self.get_user_input(
                f"Connection timeout in seconds (default: 1.0): ",
                validator=lambda x: (True, float(x)) if x.replace('.', '').isdigit() else (False, "Must be a number"),
                default=1.0
            )
            self.timeout = timeout_input
        
        # Banner grabbing
        if profile['banner'] is not None and profile['name'] != "Custom Scan":
            self.banner_grab = profile['banner']
            Color.print_info(f"Banner grabbing: {'Enabled' if self.banner_grab else 'Disabled'} (profile default)")
        else:
            banner_input = self.get_user_input(
                "Enable banner grabbing for service detection? (Y/n): ",
                default="Y"
            )
            self.banner_grab = banner_input.lower() != 'n'
    
    def step6_configure_output(self):
        """Step 6: Configure output options"""
        Color.print_header("STEP 5: OUTPUT OPTIONS")
        
        print("\nAvailable output formats:")
        print("  [1] Text Report (.txt)")
        print("  [2] JSON Report (.json)")
        print("  [3] CSV Report (.csv)")
        print("  [4] HTML Report (.html)")
        print("  [5] XML Report (.xml)")
        print("  [6] All Formats")
        print()
        
        format_input = self.get_user_input(
            "Select output format(s) [1-6] (default: 6): ",
            default="6"
        )
        
        format_map = {
            "1": ["txt"],
            "2": ["json"],
            "3": ["csv"],
            "4": ["html"],
            "5": ["xml"],
            "6": ["txt", "json", "csv", "html", "xml"]
        }
        
        self.output_formats = format_map.get(format_input, ["txt"])
        Color.print_success(f"Will generate: {', '.join(self.output_formats).upper()} reports")
    
    def step7_confirm_scan(self):
        """Step 7: Confirm scan configuration"""
        Color.print_header("SCAN CONFIGURATION SUMMARY")
        
        print(f"\n{Color.BOLD}Targets:{Color.END}")
        if len(self.targets) <= 5:
            for target in self.targets:
                print(f"  • {target}")
        else:
            print(f"  • {self.targets[0]}")
            print(f"  • {self.targets[1]}")
            print(f"  • ...")
            print(f"  • {self.targets[-1]}")
            print(f"  Total: {len(self.targets)} hosts")
        
        print(f"\n{Color.BOLD}Ports:{Color.END}")
        if len(self.ports) <= 20:
            print(f"  {', '.join(map(str, sorted(self.ports)))}")
        else:
            print(f"  {len(self.ports)} ports (Range: {min(self.ports)}-{max(self.ports)})")
        
        print(f"\n{Color.BOLD}Configuration:{Color.END}")
        print(f"  • Threads: {self.threads}")
        print(f"  • Timeout: {self.timeout}s")
        print(f"  • Banner Grab: {'Yes' if self.banner_grab else 'No'}")
        print(f"  • Output: {', '.join(self.output_formats).upper()}")
        
        self.total_ports_to_scan = len(self.targets) * len(self.ports)
        print(f"\n{Color.BOLD}Total operations: {self.total_ports_to_scan:,} port checks{Color.END}")
        
        if self.total_ports_to_scan > 100000:
            Color.print_warning("This is a large scan and may take considerable time!")
        
        print()
        confirm = self.get_user_input(
            f"{Color.BOLD}Start scanning? (Y/n): {Color.END}",
            default="Y"
        )
        
        return confirm.lower() != 'n'
    
    def perform_scan(self):
        """Perform the actual port scanning"""
        Color.print_header("SCANNING IN PROGRESS")
        
        self.start_time = datetime.now()
        self.ports_scanned = 0
        
        for target_idx, target in enumerate(self.targets, 1):
            print(f"\n{Color.CYAN}[{target_idx}/{len(self.targets)}] Scanning {target}{Color.END}")
            print("─" * 50)
            
            result = ScanResult()
            result.host = target
            result.scan_start = datetime.now()
            
            # Try to resolve hostname
            try:
                result.hostname = socket.gethostbyaddr(target)[0]
                Color.print_info(f"Hostname: {result.hostname}")
            except:
                result.hostname = target
            
            # Create thread pool for port scanning
            with ThreadPoolExecutor(max_workers=self.threads) as executor:
                futures = []
                
                for port in self.ports:
                    future = executor.submit(self.scan_port, target, port, result)
                    futures.append(future)
                
                # Process results as they complete
                for future in as_completed(futures):
                    self.ports_scanned += 1
                    
                    # Update progress
                    progress = (self.ports_scanned / self.total_ports_to_scan) * 100
                    elapsed = datetime.now() - self.start_time
                    
                    if self.ports_scanned % 100 == 0:
                        print(f"\r{Color.YELLOW}Progress: {progress:.1f}% | "
                              f"Ports: {self.ports_scanned:,}/{self.total_ports_to_scan:,} | "
                              f"Time: {elapsed} | "
                              f"Open: {len(result.open_ports)}{Color.END}", end='')
            
            result.scan_end = datetime.now()
            result.os_guess = self.guess_os(result)
            self.results.append(result)
            
            # Print summary for this host
            print(f"\n{Color.GREEN}Found {len(result.open_ports)} open ports{Color.END}")
            if result.os_guess:
                Color.print_info(f"OS Detection: {result.os_guess}")
    
    def scan_port(self, host, port, result):
        """Scan a single port"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            
            connection_result = sock.connect_ex((host, port))
            
            if connection_result == 0:
                # Port is open
                service_name, service_desc = ServiceDatabase.SERVICES.get(
                    port, (f"unknown-{port}", "Unknown Service")
                )
                
                result.open_ports.append(port)
                result.services[port] = service_name
                
                # Try banner grabbing if enabled
                if self.banner_grab:
                    try:
                        sock.send(b"HEAD / HTTP/1.0\r\n\r\n")
                        banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
                        if banner:
                            result.banners[port] = banner[:200]  # Limit banner length
                    except:
                        pass
                
                print(f"\n  {Color.GREEN}[OPEN]{Color.END} Port {port:5d} - {service_name} ({service_desc})")
                
            sock.close()
            
        except socket.timeout:
            result.filtered_ports.append(port)
        except Exception:
            pass
    
    def guess_os(self, result):
        """Guess operating system based on open ports"""
        open_ports = set(result.open_ports)
        
        # OS fingerprinting based on common port patterns
        windows_indicators = {135, 139, 445, 3389, 5985}
        linux_indicators = {22, 111, 2049}
        macos_indicators = {548, 631, 5900}
        
        windows_score = len(windows_indicators & open_ports)
        linux_score = len(linux_indicators & open_ports)
        macos_score = len(macos_indicators & open_ports)
        
        if windows_score >= 2:
            return "Windows"
        elif linux_score >= 1 and 22 in open_ports:
            return "Linux/Unix"
        elif macos_score >= 1:
            return "macOS"
        else:
            return "Unknown"
    
    def generate_reports(self):
        """Generate scan reports"""
        Color.print_header("GENERATING REPORTS")
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        for fmt in self.output_formats:
            filename = f"scan_report_{timestamp}.{fmt}"
            
            try:
                if fmt == "txt":
                    self.generate_text_report(filename)
                elif fmt == "json":
                    self.generate_json_report(filename)
                elif fmt == "csv":
                    self.generate_csv_report(filename)
                elif fmt == "html":
                    self.generate_html_report(filename)
                elif fmt == "xml":
                    self.generate_xml_report(filename)
                
                Color.print_success(f"Generated: {filename}")
                
            except Exception as e:
                Color.print_error(f"Failed to generate {fmt} report: {e}")
    
    def generate_text_report(self, filename):
        """Generate text report"""
        with open(filename, 'w') as f:
            f.write("="*80 + "\n")
            f.write("                    ADVANCED PORT SCANNER REPORT\n")
            f.write("="*80 + "\n\n")
            f.write(f"Scan Date: {datetime.now()}\n")
            f.write(f"Total Hosts Scanned: {len(self.results)}\n")
            f.write(f"Total Ports Checked: {self.total_ports_to_scan:,}\n")
            f.write(f"Scan Duration: {datetime.now() - self.start_time}\n")
            f.write("\n" + "="*80 + "\n\n")
            
            for result in self.results:
                f.write(f"HOST: {result.host}\n")
                f.write(f"Hostname: {result.hostname}\n")
                f.write(f"OS Detection: {result.os_guess}\n")
                f.write(f"Scan Duration: {result.scan_end - result.scan_start}\n")
                f.write(f"Open Ports: {len(result.open_ports)}\n")
                f.write("\n" + "-"*40 + "\n\n")
                
                if result.open_ports:
                    f.write("PORT     STATE    SERVICE\n")
                    f.write("-"*40 + "\n")
                    for port in sorted(result.open_ports):
                        service = result.services.get(port, "unknown")
                        f.write(f"{port:5d}    open     {service}\n")
                        if port in result.banners:
                            f.write(f"         Banner: {result.banners[port][:60]}...\n")
                
                f.write("\n" + "="*80 + "\n\n")
    
    def generate_json_report(self, filename):
        """Generate JSON report"""
        report_data = {
            "scan_info": {
                "tool": "Advanced Port Scanner v3.0",
                "timestamp": str(datetime.now()),
                "duration": str(datetime.now() - self.start_time),
                "total_hosts": len(self.results),
                "total_ports_scanned": self.total_ports_to_scan
            },
            "results": []
        }
        
        for result in self.results:
            host_data = {
                "host": result.host,
                "hostname": result.hostname,
                "os_guess": result.os_guess,
                "scan_duration": str(result.scan_end - result.scan_start),
                "open_ports": result.open_ports,
                "services": result.services,
                "banners": result.banners,
                "statistics": {
                    "open": len(result.open_ports),
                    "filtered": len(result.filtered_ports)
                }
            }
            report_data["results"].append(host_data)
        
        with open(filename, 'w') as f:
            json.dump(report_data, f, indent=2)
    
    def generate_csv_report(self, filename):
        """Generate CSV report"""
        with open(filename, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(['Host', 'Hostname', 'Port', 'State', 'Service', 'Banner', 'OS'])
            
            for result in self.results:
                for port in result.open_ports:
                    writer.writerow([
                        result.host,
                        result.hostname,
                        port,
                        'open',
                        result.services.get(port, ''),
                        result.banners.get(port, '')[:100] if port in result.banners else '',
                        result.os_guess
                    ])
    
    def generate_html_report(self, filename):
        """Generate HTML report"""
        html = """<!DOCTYPE html>
<html>
<head>
    <title>Port Scan Report</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .container { background: white; border-radius: 10px; padding: 30px; box-shadow: 0 10px 40px rgba(0,0,0,0.2); }
        h1 { color: #333; border-bottom: 3px solid #667eea; padding-bottom: 10px; }
        .summary { background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0; }
        .host-section { margin: 30px 0; padding: 20px; background: #fff; border: 1px solid #e0e0e0; border-radius: 8px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px; text-align: left; }
        td { padding: 10px; border-bottom: 1px solid #eee; }
        tr:hover { background: #f5f5f5; }
        .open { color: #28a745; font-weight: bold; }
        .badge { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: bold; }
        .badge-success { background: #d4edda; color: #155724; }
        .badge-info { background: #d1ecf1; color: #0c5460; }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔍 Advanced Port Scan Report</h1>
        <div class="summary">
            <h2>Scan Summary</h2>
            <p><strong>Scan Date:</strong> """ + str(datetime.now()) + """</p>
            <p><strong>Total Hosts:</strong> """ + str(len(self.results)) + """</p>
            <p><strong>Total Ports Scanned:</strong> """ + f"{self.total_ports_to_scan:,}" + """</p>
            <p><strong>Scan Duration:</strong> """ + str(datetime.now() - self.start_time) + """</p>
        </div>
"""
        
        for result in self.results:
            total_open = len(result.open_ports)
            html += f"""
        <div class="host-section">
            <h2>📍 {result.host} ({result.hostname})</h2>
            <p><span class="badge badge-info">OS: {result.os_guess}</span> 
               <span class="badge badge-success">Open Ports: {total_open}</span></p>
            """
            
            if result.open_ports:
                html += """
            <table>
                <tr>
                    <th>Port</th>
                    <th>State</th>
                    <th>Service</th>
                    <th>Banner</th>
                </tr>
"""
                for port in sorted(result.open_ports):
                    service = result.services.get(port, "unknown")
                    banner = result.banners.get(port, "")[:100] if port in result.banners else "-"
                    html += f"""
                <tr>
                    <td>{port}</td>
                    <td class="open">Open</td>
                    <td>{service}</td>
                    <td>{banner}</td>
                </tr>
"""
                html += "            </table>"
            else:
                html += "            <p>No open ports found.</p>"
            
            html += "        </div>"
        
        html += """
    </div>
</body>
</html>
"""
        
        with open(filename, 'w') as f:
            f.write(html)
    
    def generate_xml_report(self, filename):
        """Generate XML report"""
        xml_content = '<?xml version="1.0" encoding="UTF-8"?>\n'
        xml_content += '<scanreport>\n'
        xml_content += f'  <scaninfo timestamp="{datetime.now()}" duration="{datetime.now() - self.start_time}" />\n'
        xml_content += '  <hosts>\n'
        
        for result in self.results:
            xml_content += f'    <host ip="{result.host}" hostname="{result.hostname}" os="{result.os_guess}">\n'
            xml_content += '      <ports>\n'
            
            for port in sorted(result.open_ports):
                service = result.services.get(port, "unknown")
                banner = result.banners.get(port, "").replace('"', '&quot;') if port in result.banners else ""
                xml_content += f'        <port number="{port}" state="open" service="{service}" banner="{banner}" />\n'
            
            xml_content += '      </ports>\n'
            xml_content += '    </host>\n'
        
        xml_content += '  </hosts>\n'
        xml_content += '</scanreport>\n'
        
        with open(filename, 'w') as f:
            f.write(xml_content)
    
    def display_final_summary(self):
        """Display final scan summary"""
        Color.print_header("SCAN COMPLETED")
        
        total_open_ports = sum(len(r.open_ports) for r in self.results)
        scan_duration = datetime.now() - self.start_time
        
        print(f"\n{Color.BOLD}Final Statistics:{Color.END}")
        print(f"  • Total Hosts Scanned: {len(self.results)}")
        print(f"  • Total Ports Checked: {self.total_ports_to_scan:,}")
        print(f"  • Total Open Ports Found: {total_open_ports}")
        print(f"  • Scan Duration: {scan_duration}")
        print(f"  • Average Speed: {self.total_ports_to_scan / scan_duration.total_seconds():.0f} ports/second")
        
        print(f"\n{Color.BOLD}Top Findings:{Color.END}")
        
        # Find hosts with most open ports
        if self.results:
            sorted_results = sorted(self.results, key=lambda x: len(x.open_ports), reverse=True)
            for i, result in enumerate(sorted_results[:3], 1):
                if result.open_ports:
                    print(f"  {i}. {result.host}: {len(result.open_ports)} open ports (OS: {result.os_guess})")
        
        print(f"\n{Color.GREEN}Reports have been generated successfully!{Color.END}")
        print(f"Check the current directory for your report files.\n")
    
    def run(self):
        """Main execution flow"""
        try:
            # Step 1: Welcome
            self.step1_welcome()
            
            # Step 2: Select scan profile
            profile = self.step2_select_profile()
            
            # Step 3: Configure targets
            self.step3_configure_targets()
            
            # Step 4: Configure ports
            self.step4_configure_ports(profile)
            
            # Step 5: Advanced options
            self.step5_configure_advanced(profile)
            
            # Step 6: Output options
            self.step6_configure_output()
            
            # Step 7: Confirm and start scan
            if self.step7_confirm_scan():
                self.perform_scan()
                self.generate_reports()
                self.display_final_summary()
            else:
                Color.print_warning("Scan cancelled by user")
                
        except KeyboardInterrupt:
            Color.print_warning("\n\nScan interrupted by user (Ctrl+C)")
            if self.results:
                print("Generating partial reports...")
                self.generate_reports()
        except Exception as e:
            Color.print_error(f"\nAn error occurred: {e}")
            import traceback
            traceback.print_exc()

class ScanResult:
    """Container for scan results"""
    
    def __init__(self):
        self.host = None
        self.hostname = None
        self.scan_start = None
        self.scan_end = None
        self.open_ports = []
        self.closed_ports = []
        self.filtered_ports = []
        self.services = {}
        self.banners = {}
        self.os_guess = None

def main():
    """Main entry point"""
    scanner = InteractiveScanner()
    scanner.run()

if __name__ == "__main__":
    main()
