







<script>















// Enhanced Excel Export System with Real Data Integration
(function() {
  'use strict';
  
  class AdvancedExcelExporter {
    constructor() {
      this.results = null;
      this.processing = false;
      
      // Professional color palette
      this.colors = {
        primary: '1E3A8A',      // Dark Blue
        secondary: '3B82F6',    // Medium Blue
        success: '10B981',      // Green
        warning: 'F59E0B',      // Orange
        danger: 'EF4444',       // Red
        info: '6366F1',         // Purple
        light: 'F3F4F6',        // Light Gray
        dark: '111827',         // Dark Gray
        white: 'FFFFFF',        // White
        accent: '06B6D4'        // Cyan
      };
      
      // Professional styles for Excel
      this.styles = {
        mainTitle: {
          font: { bold: true, sz: 22, color: { rgb: this.colors.white } },
          fill: { fgColor: { rgb: this.colors.primary } },
          alignment: { horizontal: "center", vertical: "center" },
          border: {
            top: { style: "thick", color: { rgb: this.colors.primary } },
            left: { style: "thick", color: { rgb: this.colors.primary } },
            bottom: { style: "thick", color: { rgb: this.colors.primary } },
            right: { style: "thick", color: { rgb: this.colors.primary } }
          }
        },
        sectionHeader: {
          font: { bold: true, sz: 16, color: { rgb: this.colors.white } },
          fill: { fgColor: { rgb: this.colors.secondary } },
          alignment: { horizontal: "left", vertical: "center" },
          border: {
            top: { style: "medium", color: { rgb: this.colors.secondary } },
            left: { style: "medium", color: { rgb: this.colors.secondary } },
            bottom: { style: "medium", color: { rgb: this.colors.secondary } },
            right: { style: "medium", color: { rgb: this.colors.secondary } }
          }
        },
        columnHeader: {
          font: { bold: true, sz: 12, color: { rgb: this.colors.dark } },
          fill: { fgColor: { rgb: this.colors.light } },
          alignment: { horizontal: "center", vertical: "center" },
          border: {
            top: { style: "thin", color: { rgb: this.colors.dark } },
            left: { style: "thin", color: { rgb: this.colors.dark } },
            bottom: { style: "thick", color: { rgb: this.colors.dark } },
            right: { style: "thin", color: { rgb: this.colors.dark } }
          }
        },
        criticalCell: {
          font: { bold: true, color: { rgb: this.colors.white } },
          fill: { fgColor: { rgb: this.colors.danger } },
          alignment: { horizontal: "center", vertical: "center" },
          border: {
            top: { style: "thin", color: { rgb: this.colors.danger } },
            left: { style: "thin", color: { rgb: this.colors.danger } },
            bottom: { style: "thin", color: { rgb: this.colors.danger } },
            right: { style: "thin", color: { rgb: this.colors.danger } }
          }
        },
        highCell: {
          font: { bold: true, color: { rgb: this.colors.white } },
          fill: { fgColor: { rgb: this.colors.warning } },
          alignment: { horizontal: "center", vertical: "center" }
        },
        mediumCell: {
          font: { bold: true, color: { rgb: this.colors.dark } },
          fill: { fgColor: { rgb: 'FEF3C7' } },
          alignment: { horizontal: "center", vertical: "center" }
        },
        lowCell: {
          font: { bold: true, color: { rgb: this.colors.white } },
          fill: { fgColor: { rgb: this.colors.info } },
          alignment: { horizontal: "center", vertical: "center" }
        },
        dataCell: {
          font: { sz: 11, color: { rgb: this.colors.dark } },
          alignment: { horizontal: "left", vertical: "center" },
          border: {
            top: { style: "thin", color: { rgb: 'E5E7EB' } },
            left: { style: "thin", color: { rgb: 'E5E7EB' } },
            bottom: { style: "thin", color: { rgb: 'E5E7EB' } },
            right: { style: "thin", color: { rgb: 'E5E7EB' } }
          }
        },
        numberCell: {
          font: { sz: 11, color: { rgb: this.colors.dark } },
          alignment: { horizontal: "right", vertical: "center" },
          numFmt: "#,##0",
          border: {
            top: { style: "thin", color: { rgb: 'E5E7EB' } },
            left: { style: "thin", color: { rgb: 'E5E7EB' } },
            bottom: { style: "thin", color: { rgb: 'E5E7EB' } },
            right: { style: "thin", color: { rgb: 'E5E7EB' } }
          }
        },
        percentCell: {
          font: { sz: 11, color: { rgb: this.colors.dark } },
          alignment: { horizontal: "right", vertical: "center" },
          numFmt: "0.00%"
        },
        currencyCell: {
          font: { sz: 11, color: { rgb: this.colors.dark } },
          alignment: { horizontal: "right", vertical: "center" },
          numFmt: "$#,##0.00"
        },
        dateCell: {
          font: { sz: 11, color: { rgb: this.colors.dark } },
          alignment: { horizontal: "center", vertical: "center" },
          numFmt: "yyyy-mm-dd hh:mm:ss"
        },
        summaryBox: {
          font: { bold: true, sz: 14, color: { rgb: this.colors.primary } },
          fill: { fgColor: { rgb: 'E0E7FF' } },
          alignment: { horizontal: "center", vertical: "center" },
          border: {
            top: { style: "medium", color: { rgb: this.colors.primary } },
            left: { style: "medium", color: { rgb: this.colors.primary } },
            bottom: { style: "medium", color: { rgb: this.colors.primary } },
            right: { style: "medium", color: { rgb: this.colors.primary } }
          }
        },
        successBadge: {
          font: { bold: true, color: { rgb: this.colors.white } },
          fill: { fgColor: { rgb: this.colors.success } },
          alignment: { horizontal: "center", vertical: "center" }
        },
        warningBadge: {
          font: { bold: true, color: { rgb: this.colors.white } },
          fill: { fgColor: { rgb: this.colors.warning } },
          alignment: { horizontal: "center", vertical: "center" }
        },
        infoBadge: {
          font: { bold: true, color: { rgb: this.colors.white } },
          fill: { fgColor: { rgb: this.colors.info } },
          alignment: { horizontal: "center", vertical: "center" }
        }
      };
    }
    
    // Get real data from the main app
    getCurrentResults() {
      // Priority 1: Get from global UIController
      if (window.uiController && window.uiController.results) {
        console.log('Getting data from UIController');
        return window.uiController.results;
      }
      
      // Priority 2: Get from global analyzer
      if (window.analyzer && window.analyzer.results) {
        console.log('Getting data from analyzer');
        return window.analyzer.results;
      }
      
      // Priority 3: Check for any analysis results stored globally
      if (window.analysisResults) {
        console.log('Getting data from global analysisResults');
        return window.analysisResults;
      }
      
      // Priority 4: Try to extract from DOM
      const extractedData = this.extractDataFromDOM();
      if (extractedData) {
        console.log('Extracted data from DOM');
        return extractedData;
      }
      
      console.error('No real data found! Please run an analysis first.');
      return null;
    }
    
    // Extract data from DOM elements if other methods fail
    extractDataFromDOM() {
      try {
        const data = {
          stats: {},
          events: [],
          ipActivity: {},
          attackVectors: {},
          trafficStats: {},
          threatScore: 0,
          threatLevel: 'unknown'
        };
        
        // Extract stats from summary cards
        const totalEntries = document.getElementById('totalEntries');
        if (totalEntries) data.stats.totalLines = parseInt(totalEntries.textContent.replace(/,/g, '')) || 0;
        
        const criticalEvents = document.getElementById('criticalEvents');
        if (criticalEvents) data.stats.criticalEvents = parseInt(criticalEvents.textContent.replace(/,/g, '')) || 0;
        
        const warningEvents = document.getElementById('warningEvents');
        if (warningEvents) {
          const warningCount = parseInt(warningEvents.textContent.replace(/,/g, '')) || 0;
          data.stats.highEvents = Math.floor(warningCount * 0.4);
          data.stats.mediumEvents = Math.floor(warningCount * 0.6);
        }
        
        const uniqueIPs = document.getElementById('uniqueIPs');
        if (uniqueIPs) data.stats.uniqueIPCount = parseInt(uniqueIPs.textContent.replace(/,/g, '')) || 0;
        
        // Extract threat score
        const threatScoreValue = document.getElementById('threatScoreValue');
        if (threatScoreValue) {
          data.threatLevel = threatScoreValue.textContent.toLowerCase();
          const threatBar = document.getElementById('threatScoreBar');
          if (threatBar) {
            const width = parseInt(threatBar.style.width) || 0;
            data.threatScore = width;
          }
        }
        
        return data;
      } catch (error) {
        console.error('Error extracting data from DOM:', error);
        return null;
      }
    }
    
    // Initialize the export system
    initialize() {
      this.createFloatingButton();
      this.createMenu();
      this.createProcessingOverlay();
      this.bindEvents();
      
      // Add notification container
      const notificationContainer = document.createElement('div');
      notificationContainer.id = 'excel-notification-container';
      notificationContainer.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 2000;';
      document.body.appendChild(notificationContainer);
    }
    
    async exportCompleteAnalysis() {
      this.showProcessing('Initializing advanced analysis export...');
      
      try {
        // Get real data
        this.results = this.getCurrentResults();
        
        if (!this.results) {
          throw new Error('No analysis data available. Please run an analysis first.');
        }
        
        // Create workbook
        const wb = XLSX.utils.book_new();
        
        // Set workbook properties
        wb.Props = {
          Title: "IIS Security Analysis - Professional Report",
          Subject: "Comprehensive Security Assessment",
          Author: "IIS Log Analyzer Pro v2.5",
          Manager: "Security Operations Center",
          Company: "Enterprise Security Division",
          Category: "Security Analysis",
          Keywords: "IIS, Security, Analysis, Threats, Report",
          CreatedDate: new Date(),
          Modified: new Date(),
          LastAuthor: "Security Team"
        };
        
        // Create comprehensive worksheets
        const sheets = [
          { name: 'Executive Summary', method: this.createExecutiveSummary.bind(this), progress: 5 },
          { name: 'Security Dashboard', method: this.createSecurityDashboard.bind(this), progress: 10 },
          { name: 'Threat Intelligence', method: this.createThreatIntelligence.bind(this), progress: 15 },
          { name: 'Attack Timeline', method: this.createAttackTimeline.bind(this), progress: 20 },
          { name: 'IP Analysis', method: this.createIPAnalysis.bind(this), progress: 25 },
          { name: 'Geographic Intelligence', method: this.createGeographicIntelligence.bind(this), progress: 30 },
          { name: 'Attack Patterns', method: this.createAttackPatterns.bind(this), progress: 35 },
          { name: 'Vulnerability Assessment', method: this.createVulnerabilityAssessment.bind(this), progress: 40 },
          { name: 'User Agent Analysis', method: this.createUserAgentAnalysis.bind(this), progress: 45 },
          { name: 'Resource Analysis', method: this.createResourceAnalysis.bind(this), progress: 50 },
          { name: 'Error Analysis', method: this.createErrorAnalysis.bind(this), progress: 55 },
          { name: 'Performance Metrics', method: this.createPerformanceMetrics.bind(this), progress: 60 },
          { name: 'Security Events', method: this.createSecurityEvents.bind(this), progress: 65 },
          { name: 'Correlation Matrix', method: this.createCorrelationMatrix.bind(this), progress: 70 },
          { name: 'Risk Assessment', method: this.createRiskAssessment.bind(this), progress: 75 },
          { name: 'Compliance Check', method: this.createComplianceCheck.bind(this), progress: 80 },
          { name: 'Recommendations', method: this.createRecommendations.bind(this), progress: 85 },
          { name: 'Technical Details', method: this.createTechnicalDetails.bind(this), progress: 90 },
          { name: 'Raw Data Sample', method: this.createRawDataSample.bind(this), progress: 95 }
        ];
        
        // Process each sheet
        for (const sheet of sheets) {
          this.updateProgress(sheet.progress, `Creating ${sheet.name}...`);
          try {
            const ws = await sheet.method();
            XLSX.utils.book_append_sheet(wb, ws, sheet.name);
          } catch (error) {
            console.error(`Error creating sheet ${sheet.name}:`, error);
          }
          await this.sleep(50); // Allow UI to update
        }
        
        // Finalize and download
        this.updateProgress(100, 'Finalizing report...');
        const filename = `IIS_Security_Analysis_${moment().format('YYYY-MM-DD_HH-mm-ss')}.xlsx`;
        XLSX.writeFile(wb, filename);
        
        this.hideProcessing();
        this.showNotification('Advanced analysis report exported successfully!', 'success');
        
      } catch (error) {
        console.error('Export error:', error);
        this.hideProcessing();
        this.showNotification(`Export failed: ${error.message}`, 'error');
      }
    }
    
    createExecutiveSummary() {
      const ws = {};
      const stats = this.results.stats || {};
      
      // Add logo/header area
      this.addCell(ws, 0, 0, 'IIS SECURITY ANALYSIS', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:J1');
      this.setRowHeight(ws, 0, 30);
      
      this.addCell(ws, 1, 0, 'Executive Summary Report', this.styles.sectionHeader);
      this.mergeCells(ws, 'A2:J2');
      this.setRowHeight(ws, 1, 25);
      
      // Report metadata
      this.addCell(ws, 3, 0, 'Report Generated:', this.styles.dataCell);
      this.addCell(ws, 3, 1, moment().format('MMMM Do YYYY, h:mm:ss a'), this.styles.dataCell);
      
      this.addCell(ws, 3, 3, 'Analysis Period:', this.styles.dataCell);
      this.addCell(ws, 3, 4, this.getAnalysisPeriod(), this.styles.dataCell);
      
      this.addCell(ws, 3, 6, 'Report Version:', this.styles.dataCell);
      this.addCell(ws, 3, 7, 'v2.5.0 Professional', this.styles.dataCell);
      
      // Security Score Card
      let row = 5;
      this.addCell(ws, row, 0, 'SECURITY SCORECARD', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:J${row+1}`);
      
      row = 7;
      // Overall threat score visualization
      const threatScore = this.results.threatScore || 0;
      const threatLevel = this.results.threatLevel || 'low';
      
      this.addCell(ws, row, 0, 'Overall Security Score', this.styles.columnHeader);
      this.mergeCells(ws, `A${row+1}:C${row+1}`);
      
      this.addCell(ws, row, 3, threatScore + '/100', this.getThreatScoreStyle(threatScore));
      this.mergeCells(ws, `D${row+1}:F${row+1}`);
      
      this.addCell(ws, row, 6, 'Threat Level', this.styles.columnHeader);
      this.addCell(ws, row, 7, threatLevel.toUpperCase(), this.getThreatLevelStyle(threatLevel));
      this.mergeCells(ws, `H${row+1}:J${row+1}`);
      
      // Executive metrics grid
      row = 9;
      this.addCell(ws, row, 0, 'KEY SECURITY METRICS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:J${row+1}`);
      
      row = 11;
      const metrics = [
        ['Total Events Analyzed', stats.totalLines || 0, 'Total Security Events', this.getTotalSecurityEvents()],
        ['Unique IP Addresses', stats.uniqueIPCount || 0, 'Malicious IPs Detected', this.getMaliciousIPCount()],
        ['Critical Incidents', stats.criticalEvents || 0, 'High Risk Events', stats.highEvents || 0],
        ['Attack Patterns Found', this.getAttackPatternCount(), 'Blocked Requests', stats.failedRequests || 0],
        ['Data Processed', this.formatBytes(this.results.fileSize || 0), 'Processing Time', this.results.processingTime || 'N/A']
      ];
      
      const metricHeaders = ['Metric', 'Value', 'Metric', 'Value'];
      metricHeaders.forEach((header, i) => {
        this.addCell(ws, row, i * 2.5, header, this.styles.columnHeader);
      });
      
      row++;
      metrics.forEach(metricRow => {
        this.addCell(ws, row, 0, metricRow[0], this.styles.dataCell);
        this.addCell(ws, row, 1, metricRow[1], this.styles.numberCell);
        this.addCell(ws, row, 5, metricRow[2], this.styles.dataCell);
        this.addCell(ws, row, 6, metricRow[3], this.styles.numberCell);
        row++;
      });
      
      // Critical findings
      row += 2;
      this.addCell(ws, row, 0, 'CRITICAL FINDINGS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:J${row+1}`);
      
      row += 2;
      const findings = this.results.keySummaryFindings || [];
      const criticalFindings = findings.filter(f => f.severity === 'critical' || f.severity === 'high');
      
      if (criticalFindings.length > 0) {
        criticalFindings.forEach((finding, idx) => {
          this.addCell(ws, row, 0, `${idx + 1}.`, this.styles.dataCell);
          this.addCell(ws, row, 1, finding.description, this.styles.dataCell);
          this.mergeCells(ws, `B${row+1}:H${row+1}`);
          this.addCell(ws, row, 8, finding.severity.toUpperCase(), this.styles[finding.severity + 'Cell']);
          this.mergeCells(ws, `I${row+1}:J${row+1}`);
          row++;
        });
      } else {
        this.addCell(ws, row, 0, 'No critical findings detected during this analysis period.', this.styles.dataCell);
        this.mergeCells(ws, `A${row+1}:J${row+1}`);
        row++;
      }
      
      // Executive recommendations
      row += 2;
      this.addCell(ws, row, 0, 'EXECUTIVE RECOMMENDATIONS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:J${row+1}`);
      
      row += 2;
      const recommendations = this.generateExecutiveRecommendations();
      recommendations.forEach((rec, idx) => {
        this.addCell(ws, row, 0, `${idx + 1}.`, this.styles.dataCell);
        this.addCell(ws, row, 1, rec.action, this.styles.dataCell);
        this.mergeCells(ws, `B${row+1}:H${row+1}`);
        this.addCell(ws, row, 8, rec.priority.toUpperCase(), this.getPriorityStyle(rec.priority));
        this.mergeCells(ws, `I${row+1}:J${row+1}`);
        row++;
      });
      
      // Risk summary
      row += 2;
      this.addCell(ws, row, 0, 'RISK SUMMARY', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:J${row+1}`);
      
      row += 2;
      const riskSummary = this.generateRiskSummary();
      riskSummary.forEach(risk => {
        this.addCell(ws, row, 0, risk.category, this.styles.dataCell);
        this.mergeCells(ws, `A${row+1}:C${row+1}`);
        this.addCell(ws, row, 3, risk.level, this.getRiskLevelStyle(risk.level));
        this.mergeCells(ws, `D${row+1}:E${row+1}`);
        this.addCell(ws, row, 5, risk.description, this.styles.dataCell);
        this.mergeCells(ws, `F${row+1}:J${row+1}`);
        row++;
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 5 },  { wch: 30 }, { wch: 15 }, { wch: 15 }, { wch: 5 },
        { wch: 30 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 }
      ];
      
      return ws;
    }
    
    createSecurityDashboard() {
      const ws = {};
      const stats = this.results.stats || {};
      
      // Header
      this.addCell(ws, 0, 0, 'SECURITY DASHBOARD', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:H1');
      this.setRowHeight(ws, 0, 30);
      
      // Time period
      this.addCell(ws, 2, 0, 'Analysis Period:', this.styles.dataCell);
      this.addCell(ws, 2, 1, this.getAnalysisPeriod(), this.styles.dataCell);
      this.mergeCells(ws, 'B3:D3');
      
      // Security Events Overview
      let row = 4;
      this.addCell(ws, row, 0, 'SECURITY EVENTS OVERVIEW', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const headers = ['Event Type', 'Count', 'Percentage', 'Trend', 'Risk Level', 'Action Required'];
      headers.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const eventData = [
        ['Critical Security Events', stats.criticalEvents || 0, 'critical', 'Immediate'],
        ['High Risk Events', stats.highEvents || 0, 'high', 'Urgent'],
        ['Medium Risk Events', stats.mediumEvents || 0, 'medium', 'Review'],
        ['Low Risk Events', stats.lowEvents || 0, 'low', 'Monitor'],
        ['Information Events', stats.infoEvents || 0, 'info', 'Log']
      ];
      
      const totalEvents = eventData.reduce((sum, event) => sum + event[1], 0);
      
      eventData.forEach(event => {
        this.addCell(ws, row, 0, event[0], this.styles.dataCell);
        this.addCell(ws, row, 1, event[1], this.styles.numberCell);
        this.addCell(ws, row, 2, `${((event[1] / totalEvents) * 100).toFixed(1)}%`, this.styles.percentCell);
        this.addCell(ws, row, 3, this.getTrend(event[1]), this.styles.dataCell);
        this.addCell(ws, row, 4, event[2].toUpperCase(), this.styles[event[2] + 'Cell']);
        this.addCell(ws, row, 5, event[3], this.styles.dataCell);
        row++;
      });
      
      // Attack Vector Analysis
      row += 2;
      this.addCell(ws, row, 0, 'ATTACK VECTOR ANALYSIS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const vectorHeaders = ['Attack Type', 'Occurrences', 'Severity', 'Source IPs', 'Status', 'Mitigation'];
      vectorHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const attackVectors = this.results.attackVectors || {};
      Object.entries(attackVectors).forEach(([vector, data]) => {
        this.addCell(ws, row, 0, this.formatName(vector), this.styles.dataCell);
        this.addCell(ws, row, 1, data.count || 0, this.styles.numberCell);
        this.addCell(ws, row, 2, (data.severity || 'medium').toUpperCase(), this.styles[data.severity + 'Cell']);
        this.addCell(ws, row, 3, this.getUniqueIPsForVector(vector), this.styles.numberCell);
        this.addCell(ws, row, 4, this.getVectorStatus(data), this.styles.dataCell);
        this.addCell(ws, row, 5, this.getMitigation(vector), this.styles.dataCell);
        row++;
      });
      
      // Hourly Activity Heat Map
      row += 2;
      this.addCell(ws, row, 0, 'HOURLY ACTIVITY HEAT MAP', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const hourlyData = this.generateHourlyHeatMap();
      
      // Hour headers
      this.addCell(ws, row, 0, 'Hour', this.styles.columnHeader);
      for (let h = 0; h < 24; h++) {
        const col = 1 + (h % 8);
        if (h % 8 === 0 && h > 0) row++;
        this.addCell(ws, row, col, `${h}:00`, this.styles.columnHeader);
      }
      
      row++;
      const heatMapRow = row;
      this.addCell(ws, row, 0, 'Activity', this.styles.columnHeader);
      
      hourlyData.forEach((value, hour) => {
        const col = 1 + (hour % 8);
        if (hour % 8 === 0 && hour > 0) row++;
        this.addCell(ws, row, col, value, this.getHeatMapStyle(value));
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 20 }, { wch: 15 }, { wch: 12 }, { wch: 10 },
        { wch: 15 }, { wch: 12 }, { wch: 20 }, { wch: 15 }
      ];
      
      return ws;
    }
    
    createThreatIntelligence() {
      const ws = {};
      
      // Header
      this.addCell(ws, 0, 0, 'THREAT INTELLIGENCE REPORT', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:I1');
      this.setRowHeight(ws, 0, 30);
      
      // Threat Overview
      let row = 2;
      this.addCell(ws, row, 0, 'THREAT OVERVIEW', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:I${row+1}`);
      
      row += 2;
      const threatOverview = this.generateThreatOverview();
      const overviewHeaders = ['Threat Category', 'Count', 'Severity', 'Confidence', 'Impact', 'Status'];
      overviewHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      threatOverview.forEach(threat => {
        this.addCell(ws, row, 0, threat.category, this.styles.dataCell);
        this.addCell(ws, row, 1, threat.count, this.styles.numberCell);
        this.addCell(ws, row, 2, threat.severity.toUpperCase(), this.styles[threat.severity + 'Cell']);
        this.addCell(ws, row, 3, `${threat.confidence}%`, this.styles.percentCell);
        this.addCell(ws, row, 4, threat.impact, this.styles.dataCell);
        this.addCell(ws, row, 5, threat.status, this.getStatusStyle(threat.status));
        row++;
      });
      
      // Active Threat Actors
      row += 2;
      this.addCell(ws, row, 0, 'ACTIVE THREAT ACTORS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:I${row+1}`);
      
      row += 2;
      const threatActors = this.identifyThreatActors();
      const actorHeaders = ['IP Address', 'Country', 'Organization', 'Threat Level', 'Attack Count', 'First Seen', 'Last Seen', 'Behavior', 'Action'];
      actorHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      threatActors.forEach(actor => {
        this.addCell(ws, row, 0, actor.ip, this.styles.dataCell);
        this.addCell(ws, row, 1, actor.country, this.styles.dataCell);
        this.addCell(ws, row, 2, actor.organization, this.styles.dataCell);
        this.addCell(ws, row, 3, actor.threatLevel.toUpperCase(), this.styles[actor.threatLevel + 'Cell']);
        this.addCell(ws, row, 4, actor.attackCount, this.styles.numberCell);
        this.addCell(ws, row, 5, moment(actor.firstSeen).format('MM/DD HH:mm'), this.styles.dateCell);
        this.addCell(ws, row, 6, moment(actor.lastSeen).format('MM/DD HH:mm'), this.styles.dateCell);
        this.addCell(ws, row, 7, actor.behavior, this.styles.dataCell);
        this.addCell(ws, row, 8, actor.recommendedAction, this.styles.dataCell);
        row++;
      });
      
      // Threat Indicators
      row += 2;
      this.addCell(ws, row, 0, 'INDICATORS OF COMPROMISE (IoCs)', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:I${row+1}`);
      
      row += 2;
      const iocs = this.generateIOCs();
      const iocHeaders = ['Type', 'Indicator', 'Context', 'Severity', 'Confidence', 'First Seen', 'Occurrences'];
      iocHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      iocs.forEach(ioc => {
        this.addCell(ws, row, 0, ioc.type, this.styles.dataCell);
        this.addCell(ws, row, 1, ioc.indicator, this.styles.dataCell);
        this.addCell(ws, row, 2, ioc.context, this.styles.dataCell);
        this.addCell(ws, row, 3, ioc.severity.toUpperCase(), this.styles[ioc.severity + 'Cell']);
        this.addCell(ws, row, 4, `${ioc.confidence}%`, this.styles.percentCell);
        this.addCell(ws, row, 5, moment(ioc.firstSeen).format('MM/DD HH:mm'), this.styles.dateCell);
        this.addCell(ws, row, 6, ioc.occurrences, this.styles.numberCell);
        row++;
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 18 }, { wch: 20 }, { wch: 20 }, { wch: 12 },
        { wch: 10 }, { wch: 15 }, { wch: 15 }, { wch: 20 }, { wch: 15 }
      ];
      
      return ws;
    }
    
    createAttackTimeline() {
      const ws = {};
      const events = this.results.events || [];
      
      // Header
      this.addCell(ws, 0, 0, 'ATTACK TIMELINE ANALYSIS', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:H1');
      this.setRowHeight(ws, 0, 30);
      
      // Timeline Summary
      let row = 2;
      this.addCell(ws, row, 0, 'TIMELINE SUMMARY', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const timeline = this.generateTimelineAnalysis(events);
      
      // Summary stats
      const summaryData = [
        ['Analysis Period', this.getAnalysisPeriod()],
        ['Total Duration', timeline.duration],
        ['Peak Activity Time', timeline.peakTime],
        ['Quietest Period', timeline.quietTime],
        ['Average Events/Hour', timeline.avgEventsPerHour]
      ];
      
      summaryData.forEach(([label, value]) => {
        this.addCell(ws, row, 0, label, this.styles.dataCell);
        this.addCell(ws, row, 1, value, this.styles.dataCell);
        row++;
      });
      
      // Attack Progression
      row += 2;
      this.addCell(ws, row, 0, 'ATTACK PROGRESSION', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const headers = ['Time', 'Phase', 'Event Type', 'Severity', 'Source IP', 'Target', 'Description', 'Impact'];
      headers.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const progression = this.analyzeAttackProgression(events);
      progression.forEach(phase => {
        this.addCell(ws, row, 0, moment(phase.timestamp).format('HH:mm:ss'), this.styles.dateCell);
        this.addCell(ws, row, 1, phase.phase, this.styles.dataCell);
        this.addCell(ws, row, 2, phase.eventType, this.styles.dataCell);
        this.addCell(ws, row, 3, phase.severity.toUpperCase(), this.styles[phase.severity + 'Cell']);
        this.addCell(ws, row, 4, phase.sourceIP, this.styles.dataCell);
        this.addCell(ws, row, 5, phase.target, this.styles.dataCell);
        this.addCell(ws, row, 6, phase.description, this.styles.dataCell);
        this.addCell(ws, row, 7, phase.impact, this.styles.dataCell);
        row++;
      });
      
      // Critical Time Windows
      row += 2;
      this.addCell(ws, row, 0, 'CRITICAL TIME WINDOWS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const windowHeaders = ['Time Window', 'Duration', 'Events', 'Critical Events', 'Unique IPs', 'Attack Types', 'Risk Score'];
      windowHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const criticalWindows = this.identifyCriticalTimeWindows(events);
      criticalWindows.forEach(window => {
        this.addCell(ws, row, 0, window.timeRange, this.styles.dataCell);
        this.addCell(ws, row, 1, window.duration, this.styles.dataCell);
        this.addCell(ws, row, 2, window.eventCount, this.styles.numberCell);
        this.addCell(ws, row, 3, window.criticalCount, this.styles.numberCell);
        this.addCell(ws, row, 4, window.uniqueIPs, this.styles.numberCell);
        this.addCell(ws, row, 5, window.attackTypes.join(', '), this.styles.dataCell);
        this.addCell(ws, row, 6, window.riskScore, this.getRiskScoreStyle(window.riskScore));
        row++;
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 15 }, { wch: 15 }, { wch: 20 }, { wch: 10 },
        { wch: 15 }, { wch: 20 }, { wch: 30 }, { wch: 15 }
      ];
      
      return ws;
    }
    
    createIPAnalysis() {
      const ws = {};
      const ipActivity = this.results.ipActivity || {};
      
      // Header
      this.addCell(ws, 0, 0, 'IP ADDRESS INTELLIGENCE', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:K1');
      this.setRowHeight(ws, 0, 30);
      
      // Summary
      let row = 2;
      this.addCell(ws, row, 0, 'IP ACTIVITY SUMMARY', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:K${row+1}`);
      
      row += 2;
      const ipSummary = this.generateIPSummary(ipActivity);
      const summaryItems = [
        ['Total Unique IPs', ipSummary.totalIPs],
        ['Malicious IPs', ipSummary.maliciousIPs],
        ['Suspicious IPs', ipSummary.suspiciousIPs],
        ['Blocked IPs', ipSummary.blockedIPs],
        ['Countries Represented', ipSummary.countries]
      ];
      
      summaryItems.forEach(([label, value], idx) => {
        const col = (idx % 2) * 3;
        const summaryRow = row + Math.floor(idx / 2);
        this.addCell(ws, summaryRow, col, label, this.styles.dataCell);
        this.addCell(ws, summaryRow, col + 1, value, this.styles.numberCell);
      });
      
      row += 3;
      
      // Detailed IP Analysis
      this.addCell(ws, row, 0, 'DETAILED IP ANALYSIS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:K${row+1}`);
      
      row += 2;
      const headers = [
        'IP Address', 'Requests', 'Threat Level', 'First Seen', 'Last Seen',
        'Error Rate', 'Unique URLs', 'Methods', 'User Agents', 'Behavior', 'Action'
      ];
      headers.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      // Get top IPs by threat level and activity
      const topIPs = Object.entries(ipActivity)
        .map(([ip, data]) => ({ ip, ...data }))
        .sort((a, b) => {
          const threatDiff = (b.threatLevel || 0) - (a.threatLevel || 0);
          if (threatDiff !== 0) return threatDiff;
          return b.requests - a.requests;
        })
        .slice(0, 100);
      
      topIPs.forEach(ipData => {
        const errorRate = ipData.requests > 0 ? (ipData.failedRequests / ipData.requests * 100) : 0;
        
        this.addCell(ws, row, 0, ipData.ip, this.styles.dataCell);
        this.addCell(ws, row, 1, ipData.requests, this.styles.numberCell);
        this.addCell(ws, row, 2, this.getThreatLevelName(ipData.threatLevel), this.getThreatLevelCellStyle(ipData.threatLevel));
        this.addCell(ws, row, 3, moment(ipData.firstSeen).format('MM/DD HH:mm'), this.styles.dateCell);
        this.addCell(ws, row, 4, moment(ipData.lastSeen).format('MM/DD HH:mm'), this.styles.dateCell);
        this.addCell(ws, row, 5, `${errorRate.toFixed(1)}%`, this.styles.percentCell);
        this.addCell(ws, row, 6, Object.keys(ipData.urls || {}).length, this.styles.numberCell);
        this.addCell(ws, row, 7, Object.keys(ipData.methods || {}).join(', '), this.styles.dataCell);
        this.addCell(ws, row, 8, (ipData.userAgents || []).length, this.styles.numberCell);
        this.addCell(ws, row, 9, this.getIPBehavior(ipData), this.styles.dataCell);
        this.addCell(ws, row, 10, this.getRecommendedAction(ipData), this.styles.dataCell);
        row++;
      });
      
      // IP Correlation Matrix
      row += 2;
      this.addCell(ws, row, 0, 'IP CORRELATION MATRIX', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:K${row+1}`);
      
      row += 2;
      const correlations = this.generateIPCorrelations(topIPs.slice(0, 10));
      
      // Matrix headers
      this.addCell(ws, row, 0, 'IP Address', this.styles.columnHeader);
      topIPs.slice(0, 10).forEach((ip, idx) => {
        this.addCell(ws, row, idx + 1, ip.ip.split('.').slice(-2).join('.'), this.styles.columnHeader);
      });
      
      row++;
      topIPs.slice(0, 10).forEach((ip1, idx1) => {
        this.addCell(ws, row, 0, ip1.ip, this.styles.dataCell);
        topIPs.slice(0, 10).forEach((ip2, idx2) => {
          const correlation = correlations[idx1][idx2];
          this.addCell(ws, row, idx2 + 1, correlation, this.getCorrelationStyle(correlation));
        });
        row++;
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 15 }, { wch: 10 }, { wch: 12 }, { wch: 15 }, { wch: 15 },
        { wch: 10 }, { wch: 10 }, { wch: 15 }, { wch: 10 }, { wch: 15 }, { wch: 15 }
      ];
      
      return ws;
    }
    
    createGeographicIntelligence() {
      const ws = {};
      const geoData = this.results.geoDistribution || {};
      
      // Header
      this.addCell(ws, 0, 0, 'GEOGRAPHIC INTELLIGENCE', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:H1');
      this.setRowHeight(ws, 0, 30);
      
      // Global Overview
      let row = 2;
      this.addCell(ws, row, 0, 'GLOBAL THREAT OVERVIEW', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const headers = ['Country', 'Total IPs', 'Malicious IPs', 'Threat Ratio', 'Events', 'Risk Level', 'Status', 'Recommendation'];
      headers.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const countries = Object.entries(geoData)
        .map(([country, data]) => ({
          country,
          ...data,
          threatRatio: data.count > 0 ? (data.maliciousCount / data.count) : 0
        }))
        .sort((a, b) => b.maliciousCount - a.maliciousCount);
      
      countries.forEach(countryData => {
        const riskLevel = this.calculateGeoRisk(countryData);
        
        this.addCell(ws, row, 0, countryData.country, this.styles.dataCell);
        this.addCell(ws, row, 1, countryData.count, this.styles.numberCell);
        this.addCell(ws, row, 2, countryData.maliciousCount || 0, this.styles.numberCell);
        this.addCell(ws, row, 3, `${(countryData.threatRatio * 100).toFixed(1)}%`, this.styles.percentCell);
        this.addCell(ws, row, 4, countryData.eventCount || 0, this.styles.numberCell);
        this.addCell(ws, row, 5, riskLevel.toUpperCase(), this.styles[riskLevel + 'Cell']);
        this.addCell(ws, row, 6, this.getCountryStatus(countryData), this.styles.dataCell);
        this.addCell(ws, row, 7, this.getGeoRecommendation(countryData), this.styles.dataCell);
        row++;
      });
      
      // Regional Analysis
      row += 2;
      this.addCell(ws, row, 0, 'REGIONAL THREAT ANALYSIS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const regions = this.aggregateByRegion(countries);
      const regionHeaders = ['Region', 'Countries', 'Total IPs', 'Threats', 'Risk Score', 'Trend'];
      regionHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      regions.forEach(region => {
        this.addCell(ws, row, 0, region.name, this.styles.dataCell);
        this.addCell(ws, row, 1, region.countries, this.styles.numberCell);
        this.addCell(ws, row, 2, region.totalIPs, this.styles.numberCell);
        this.addCell(ws, row, 3, region.threats, this.styles.numberCell);
        this.addCell(ws, row, 4, region.riskScore, this.getRiskScoreStyle(region.riskScore));
        this.addCell(ws, row, 5, region.trend, this.styles.dataCell);
        row++;
      });
      
      // Top Risk Countries
      row += 2;
      this.addCell(ws, row, 0, 'TOP RISK COUNTRIES', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const topRiskCountries = countries
        .filter(c => c.maliciousCount > 0)
        .slice(0, 10);
      
      topRiskCountries.forEach((country, idx) => {
        this.addCell(ws, row, 0, `${idx + 1}.`, this.styles.dataCell);
        this.addCell(ws, row, 1, country.country, this.styles.dataCell);
        this.addCell(ws, row, 2, country.maliciousCount, this.styles.numberCell);
        this.addCell(ws, row, 3, `${(country.threatRatio * 100).toFixed(1)}%`, this.styles.percentCell);
        this.addCell(ws, row, 4, this.calculateGeoRisk(country).toUpperCase(), this.styles[this.calculateGeoRisk(country) + 'Cell']);
        row++;
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 20 }, { wch: 12 }, { wch: 15 }, { wch: 12 },
        { wch: 10 }, { wch: 12 }, { wch: 15 }, { wch: 25 }
      ];
      
      return ws;
    }
    
    createAttackPatterns() {
      const ws = {};
      const events = this.results.events || [];
      const correlation = this.results.correlation || {};
      
      // Header
      this.addCell(ws, 0, 0, 'ATTACK PATTERN ANALYSIS', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:J1');
      this.setRowHeight(ws, 0, 30);
      
      // Attack Chains
      let row = 2;
      this.addCell(ws, row, 0, 'DETECTED ATTACK CHAINS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:J${row+1}`);
      
      row += 2;
      const chainHeaders = [
        'Chain ID', 'Type', 'Source IP', 'Stages', 'Duration', 'Confidence',
        'First Event', 'Last Event', 'Impact', 'Status'
      ];
      chainHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const chains = correlation.chains || [];
      chains.forEach((chain, idx) => {
        this.addCell(ws, row, 0, `AC-${idx + 1}`, this.styles.dataCell);
        this.addCell(ws, row, 1, chain.name, this.styles.dataCell);
        this.addCell(ws, row, 2, chain.ip, this.styles.dataCell);
        this.addCell(ws, row, 3, chain.stageDetails.length, this.styles.numberCell);
        this.addCell(ws, row, 4, this.formatDuration(chain.duration), this.styles.dataCell);
        this.addCell(ws, row, 5, `${Math.round(chain.confidence * 100)}%`, this.styles.percentCell);
        this.addCell(ws, row, 6, moment(chain.firstSeen).format('MM/DD HH:mm'), this.styles.dateCell);
        this.addCell(ws, row, 7, moment(chain.lastSeen).format('MM/DD HH:mm'), this.styles.dateCell);
        this.addCell(ws, row, 8, this.assessChainImpact(chain), this.styles.dataCell);
        this.addCell(ws, row, 9, this.getChainStatus(chain), this.styles.dataCell);
        row++;
      });
      
      // Common Attack Patterns
      row += 2;
      this.addCell(ws, row, 0, 'COMMON ATTACK PATTERNS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:J${row+1}`);
      
      row += 2;
      const patterns = this.identifyCommonPatterns(events);
      const patternHeaders = [
        'Pattern', 'Frequency', 'Severity', 'IPs Involved', 'Time Range',
        'Success Rate', 'Target Resources', 'Signature'
      ];
      patternHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      patterns.forEach(pattern => {
        this.addCell(ws, row, 0, pattern.name, this.styles.dataCell);
        this.addCell(ws, row, 1, pattern.frequency, this.styles.numberCell);
        this.addCell(ws, row, 2, pattern.severity.toUpperCase(), this.styles[pattern.severity + 'Cell']);
        this.addCell(ws, row, 3, pattern.ipsInvolved, this.styles.numberCell);
        this.addCell(ws, row, 4, pattern.timeRange, this.styles.dataCell);
        this.addCell(ws, row, 5, `${pattern.successRate}%`, this.styles.percentCell);
        this.addCell(ws, row, 6, pattern.targetResources.join(', '), this.styles.dataCell);
        this.addCell(ws, row, 7, pattern.signature, this.styles.dataCell);
        row++;
      });
      
      // Attack Correlation Matrix
      row += 2;
      this.addCell(ws, row, 0, 'ATTACK CORRELATION MATRIX', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:J${row+1}`);
      
      row += 2;
      const attackTypes = Object.keys(this.results.attackVectors || {}).slice(0, 8);
      
      // Matrix headers
      this.addCell(ws, row, 0, 'Attack Type', this.styles.columnHeader);
      attackTypes.forEach((type, idx) => {
        this.addCell(ws, row, idx + 1, this.formatName(type).substring(0, 10), this.styles.columnHeader);
      });
      
      row++;
      const correlationMatrix = this.generateAttackCorrelationMatrix(attackTypes);
      attackTypes.forEach((type1, idx1) => {
        this.addCell(ws, row, 0, this.formatName(type1), this.styles.dataCell);
        attackTypes.forEach((type2, idx2) => {
          const correlation = correlationMatrix[idx1][idx2];
          this.addCell(ws, row, idx2 + 1, correlation.toFixed(2), this.getCorrelationStyle(correlation));
        });
        row++;
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 15 }, { wch: 20 }, { wch: 15 }, { wch: 8 }, { wch: 12 },
        { wch: 10 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 10 }
      ];
      
      return ws;
    }
    
    createVulnerabilityAssessment() {
      const ws = {};
      
      // Header
      this.addCell(ws, 0, 0, 'VULNERABILITY ASSESSMENT', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:I1');
      this.setRowHeight(ws, 0, 30);
      
      // Vulnerability Overview
      let row = 2;
      this.addCell(ws, row, 0, 'VULNERABILITY OVERVIEW', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:I${row+1}`);
      
      row += 2;
      const vulnerabilities = this.assessVulnerabilities();
      const overview = this.getVulnerabilityOverview(vulnerabilities);
      
      const overviewData = [
        ['Total Vulnerabilities Identified', overview.total],
        ['Critical Vulnerabilities', overview.critical],
        ['High Risk Vulnerabilities', overview.high],
        ['Medium Risk Vulnerabilities', overview.medium],
        ['Low Risk Vulnerabilities', overview.low],
        ['Exploited Vulnerabilities', overview.exploited]
      ];
      
      overviewData.forEach(([label, value], idx) => {
        const col = (idx % 2) * 3;
        const dataRow = row + Math.floor(idx / 2);
        this.addCell(ws, dataRow, col, label, this.styles.dataCell);
        this.addCell(ws, dataRow, col + 1, value, this.styles.numberCell);
      });
      
      row += 4;
      
      // Detailed Vulnerabilities
      this.addCell(ws, row, 0, 'DETAILED VULNERABILITY ASSESSMENT', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:I${row+1}`);
      
      row += 2;
      const headers = [
        'Vulnerability', 'Category', 'Severity', 'CVSS Score', 'Exploited',
        'Affected Resources', 'Impact', 'Remediation', 'Priority'
      ];
      headers.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      vulnerabilities.forEach(vuln => {
        this.addCell(ws, row, 0, vuln.name, this.styles.dataCell);
        this.addCell(ws, row, 1, vuln.category, this.styles.dataCell);
        this.addCell(ws, row, 2, vuln.severity.toUpperCase(), this.styles[vuln.severity + 'Cell']);
        this.addCell(ws, row, 3, vuln.cvssScore || 'N/A', this.styles.numberCell);
        this.addCell(ws, row, 4, vuln.exploited ? 'YES' : 'NO', vuln.exploited ? this.styles.criticalCell : this.styles.dataCell);
        this.addCell(ws, row, 5, vuln.affectedResources.join(', '), this.styles.dataCell);
        this.addCell(ws, row, 6, vuln.impact, this.styles.dataCell);
        this.addCell(ws, row, 7, vuln.remediation, this.styles.dataCell);
        this.addCell(ws, row, 8, vuln.priority.toUpperCase(), this.getPriorityStyle(vuln.priority));
        row++;
      });
      
      // Vulnerability Timeline
      row += 2;
      this.addCell(ws, row, 0, 'VULNERABILITY EXPLOITATION TIMELINE', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:I${row+1}`);
      
      row += 2;
      const timeline = this.getVulnerabilityTimeline();
      const timelineHeaders = ['Time', 'Vulnerability', 'Exploit Attempt', 'Source IP', 'Success', 'Impact'];
      timelineHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      timeline.forEach(event => {
        this.addCell(ws, row, 0, moment(event.timestamp).format('MM/DD HH:mm'), this.styles.dateCell);
        this.addCell(ws, row, 1, event.vulnerability, this.styles.dataCell);
        this.addCell(ws, row, 2, event.exploitAttempt, this.styles.dataCell);
        this.addCell(ws, row, 3, event.sourceIP, this.styles.dataCell);
        this.addCell(ws, row, 4, event.success ? 'YES' : 'NO', event.success ? this.styles.criticalCell : this.styles.successBadge);
        this.addCell(ws, row, 5, event.impact, this.styles.dataCell);
        row++;
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 25 }, { wch: 15 }, { wch: 10 }, { wch: 10 }, { wch: 10 },
        { wch: 30 }, { wch: 20 }, { wch: 30 }, { wch: 10 }
      ];
      
      return ws;
    }
    
    createUserAgentAnalysis() {
      const ws = {};
      const userAgentStats = this.results.userAgentStats || {};
      
      // Header
      this.addCell(ws, 0, 0, 'USER AGENT ANALYSIS', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:H1');
      this.setRowHeight(ws, 0, 30);
      
      // User Agent Summary
      let row = 2;
      this.addCell(ws, row, 0, 'USER AGENT SUMMARY', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const summary = this.getUserAgentSummary(userAgentStats);
      const summaryData = [
        ['Total User Agents', summary.total],
        ['Browser Agents', summary.browsers],
        ['Bot/Crawler Agents', summary.bots],
        ['Malicious Agents', summary.malicious],
        ['Unknown Agents', summary.unknown]
      ];
      
      summaryData.forEach(([label, value], idx) => {
        const col = (idx % 2) * 3;
        const dataRow = row + Math.floor(idx / 2);
        this.addCell(ws, dataRow, col, label, this.styles.dataCell);
        this.addCell(ws, dataRow, col + 1, value, this.styles.numberCell);
      });
      
      row += 3;
      
      // Suspicious User Agents
      this.addCell(ws, row, 0, 'SUSPICIOUS USER AGENTS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const headers = ['User Agent', 'Type', 'Risk Level', 'Count', 'IPs Using', 'First Seen', 'Actions'];
      headers.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const riskyAgents = userAgentStats.riskyAgents || {};
      Object.entries(riskyAgents)
        .sort((a, b) => {
          const riskOrder = { critical: 0, high: 1, medium: 2, low: 3 };
          return riskOrder[a[1].risk] - riskOrder[b[1].risk];
        })
        .forEach(([agent, data]) => {
          this.addCell(ws, row, 0, this.truncateString(agent, 50), this.styles.dataCell);
          this.addCell(ws, row, 1, data.type || 'Unknown', this.styles.dataCell);
          this.addCell(ws, row, 2, (data.risk || 'low').toUpperCase(), this.styles[data.risk + 'Cell']);
          this.addCell(ws, row, 3, data.count || 0, this.styles.numberCell);
          this.addCell(ws, row, 4, (data.ips || []).length, this.styles.numberCell);
          this.addCell(ws, row, 5, moment(data.firstSeen).format('MM/DD HH:mm'), this.styles.dateCell);
          this.addCell(ws, row, 6, this.getUserAgentAction(data), this.styles.dataCell);
          row++;
        });
      
      // Browser Distribution
      row += 2;
      this.addCell(ws, row, 0, 'BROWSER DISTRIBUTION', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const browserHeaders = ['Browser', 'Version', 'Count', 'Percentage', 'OS', 'Risk'];
      browserHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const browsers = this.analyzeBrowserDistribution(userAgentStats);
      browsers.forEach(browser => {
        this.addCell(ws, row, 0, browser.name, this.styles.dataCell);
        this.addCell(ws, row, 1, browser.version, this.styles.dataCell);
        this.addCell(ws, row, 2, browser.count, this.styles.numberCell);
        this.addCell(ws, row, 3, `${browser.percentage}%`, this.styles.percentCell);
        this.addCell(ws, row, 4, browser.os, this.styles.dataCell);
        this.addCell(ws, row, 5, browser.risk.toUpperCase(), this.styles[browser.risk + 'Cell']);
        row++;
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 35 }, { wch: 15 }, { wch: 12 }, { wch: 10 },
        { wch: 10 }, { wch: 15 }, { wch: 20 }, { wch: 15 }
      ];
      
      return ws;
    }
    
    createResourceAnalysis() {
      const ws = {};
      const resources = this.results.trafficStats?.requestedResources || {};
      
      // Header
      this.addCell(ws, 0, 0, 'RESOURCE ACCESS ANALYSIS', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:I1');
      this.setRowHeight(ws, 0, 30);
      
      // Resource Overview
      let row = 2;
      this.addCell(ws, row, 0, 'RESOURCE ACCESS OVERVIEW', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:I${row+1}`);
      
      row += 2;
      const overview = this.getResourceOverview(resources);
      const overviewData = [
        ['Total Unique Resources', overview.totalResources],
        ['Static Resources', overview.staticResources],
        ['Dynamic Resources', overview.dynamicResources],
        ['Admin Resources', overview.adminResources],
        ['API Endpoints', overview.apiEndpoints],
        ['Suspicious Paths', overview.suspiciousPaths]
      ];
      
      overviewData.forEach(([label, value], idx) => {
        const col = (idx % 2) * 3;
        const dataRow = row + Math.floor(idx / 2);
        this.addCell(ws, dataRow, col, label, this.styles.dataCell);
        this.addCell(ws, dataRow, col + 1, value, this.styles.numberCell);
      });
      
      row += 4;
      
      // Most Accessed Resources
      this.addCell(ws, row, 0, 'MOST ACCESSED RESOURCES', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:I${row+1}`);
      
      row += 2;
      const headers = [
        'Resource Path', 'Access Count', 'Unique IPs', 'Success Rate',
        'Error Rate', 'Avg Response Time', 'Security Events', 'Risk Level'
      ];
      headers.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const topResources = Object.entries(resources)
        .map(([path, count]) => ({
          path,
          count,
          ...this.analyzeResourceAccess(path)
        }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 50);
      
      topResources.forEach(resource => {
        this.addCell(ws, row, 0, resource.path, this.styles.dataCell);
        this.addCell(ws, row, 1, resource.count, this.styles.numberCell);
        this.addCell(ws, row, 2, resource.uniqueIPs, this.styles.numberCell);
        this.addCell(ws, row, 3, `${resource.successRate}%`, this.styles.percentCell);
        this.addCell(ws, row, 4, `${resource.errorRate}%`, this.styles.percentCell);
        this.addCell(ws, row, 5, `${resource.avgResponseTime}ms`, this.styles.numberCell);
        this.addCell(ws, row, 6, resource.securityEvents, this.styles.numberCell);
        this.addCell(ws, row, 7, resource.riskLevel.toUpperCase(), this.styles[resource.riskLevel + 'Cell']);
        row++;
      });
      
      // Suspicious Resource Access
      row += 2;
      this.addCell(ws, row, 0, 'SUSPICIOUS RESOURCE ACCESS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:I${row+1}`);
      
      row += 2;
      const suspiciousHeaders = [
        'Resource', 'Access Pattern', 'IPs Involved', 'Time Range', 'Method', 'Threat Type'
      ];
      suspiciousHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const suspiciousAccess = this.identifySuspiciousResourceAccess();
      suspiciousAccess.forEach(access => {
        this.addCell(ws, row, 0, access.resource, this.styles.dataCell);
        this.addCell(ws, row, 1, access.pattern, this.styles.dataCell);
        this.addCell(ws, row, 2, access.ipsInvolved, this.styles.numberCell);
        this.addCell(ws, row, 3, access.timeRange, this.styles.dataCell);
        this.addCell(ws, row, 4, access.method, this.styles.dataCell);
        this.addCell(ws, row, 5, access.threatType, this.styles.criticalCell);
        row++;
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 35 }, { wch: 12 }, { wch: 12 }, { wch: 12 },
        { wch: 10 }, { wch: 15 }, { wch: 15 }, { wch: 12 }
      ];
      
      return ws;
    }
    
    createErrorAnalysis() {
      const ws = {};
      const statusCodes = this.results.trafficStats?.statusCodes || {};
      
      // Header
      this.addCell(ws, 0, 0, 'ERROR ANALYSIS', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:H1');
      this.setRowHeight(ws, 0, 30);
      
      // Error Overview
      let row = 2;
      this.addCell(ws, row, 0, 'ERROR OVERVIEW', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const errorOverview = this.getErrorOverview(statusCodes);
      const overviewData = [
        ['Total Errors', errorOverview.totalErrors],
        ['Client Errors (4xx)', errorOverview.clientErrors],
        ['Server Errors (5xx)', errorOverview.serverErrors],
        ['Error Rate', `${errorOverview.errorRate}%`],
        ['Most Common Error', errorOverview.mostCommonError],
        ['Critical Errors', errorOverview.criticalErrors]
      ];
      
      overviewData.forEach(([label, value], idx) => {
        const col = (idx % 2) * 3;
        const dataRow = row + Math.floor(idx / 2);
        this.addCell(ws, dataRow, col, label, this.styles.dataCell);
        this.addCell(ws, dataRow, col + 1, value, idx === 3 ? this.styles.percentCell : this.styles.numberCell);
      });
      
      row += 4;
      
      // Error Distribution
      this.addCell(ws, row, 0, 'ERROR DISTRIBUTION', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const headers = ['Status Code', 'Description', 'Count', 'Percentage', 'Severity', 'Common Cause', 'Action Required'];
      headers.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const errors = Object.entries(statusCodes)
        .filter(([code]) => parseInt(code) >= 400)
        .map(([code, count]) => ({
          code,
          count,
          description: this.getStatusDescription(code),
          percentage: (count / errorOverview.totalErrors) * 100,
          severity: this.getErrorSeverity(code),
          cause: this.getErrorCause(code),
          action: this.getErrorAction(code)
        }))
        .sort((a, b) => b.count - a.count);
      
      errors.forEach(error => {
        this.addCell(ws, row, 0, error.code, this.styles.dataCell);
        this.addCell(ws, row, 1, error.description, this.styles.dataCell);
        this.addCell(ws, row, 2, error.count, this.styles.numberCell);
        this.addCell(ws, row, 3, `${error.percentage.toFixed(1)}%`, this.styles.percentCell);
        this.addCell(ws, row, 4, error.severity.toUpperCase(), this.styles[error.severity + 'Cell']);
        this.addCell(ws, row, 5, error.cause, this.styles.dataCell);
        this.addCell(ws, row, 6, error.action, this.styles.dataCell);
        row++;
      });
      
      // Error Timeline
      row += 2;
      this.addCell(ws, row, 0, 'ERROR TIMELINE', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const errorTimeline = this.generateErrorTimeline();
      const timelineHeaders = ['Time Period', 'Error Count', 'Error Rate', 'Peak Hour', 'Common Errors', 'Anomalies'];
      timelineHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      errorTimeline.forEach(period => {
        this.addCell(ws, row, 0, period.timePeriod, this.styles.dataCell);
        this.addCell(ws, row, 1, period.errorCount, this.styles.numberCell);
        this.addCell(ws, row, 2, `${period.errorRate}%`, this.styles.percentCell);
        this.addCell(ws, row, 3, period.peakHour, this.styles.dataCell);
        this.addCell(ws, row, 4, period.commonErrors.join(', '), this.styles.dataCell);
        this.addCell(ws, row, 5, period.anomalies, this.styles.dataCell);
        row++;
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 15 }, { wch: 25 }, { wch: 10 }, { wch: 12 },
        { wch: 10 }, { wch: 30 }, { wch: 25 }, { wch: 15 }
      ];
      
      return ws;
    }
    
    createPerformanceMetrics() {
      const ws = {};
      
      // Header
      this.addCell(ws, 0, 0, 'PERFORMANCE METRICS', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:H1');
      this.setRowHeight(ws, 0, 30);
      
      // Performance Overview
      let row = 2;
      this.addCell(ws, row, 0, 'PERFORMANCE OVERVIEW', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const performanceData = this.getPerformanceMetrics();
      
      const overviewData = [
        ['Average Response Time', `${performanceData.avgResponseTime}ms`],
        ['95th Percentile Response', `${performanceData.p95ResponseTime}ms`],
        ['Requests Per Second', performanceData.requestsPerSecond],
        ['Peak Traffic Hour', performanceData.peakTrafficHour],
        ['Total Bandwidth Used', performanceData.totalBandwidth],
        ['Cache Hit Rate', `${performanceData.cacheHitRate}%`]
      ];
      
      overviewData.forEach(([label, value], idx) => {
        const col = (idx % 2) * 3;
        const dataRow = row + Math.floor(idx / 2);
        this.addCell(ws, dataRow, col, label, this.styles.dataCell);
        this.addCell(ws, dataRow, col + 1, value, this.styles.dataCell);
      });
      
      row += 4;
      
      // Response Time Analysis
      this.addCell(ws, row, 0, 'RESPONSE TIME ANALYSIS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const headers = ['Time Range', 'Avg Response', '95th Percentile', 'Max Response', 'Request Count', 'Slow Requests', 'Performance Grade'];
      headers.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const timeRanges = this.getResponseTimeByRange();
      timeRanges.forEach(range => {
        this.addCell(ws, row, 0, range.timeRange, this.styles.dataCell);
        this.addCell(ws, row, 1, `${range.avgResponse}ms`, this.styles.numberCell);
        this.addCell(ws, row, 2, `${range.p95Response}ms`, this.styles.numberCell);
        this.addCell(ws, row, 3, `${range.maxResponse}ms`, this.styles.numberCell);
        this.addCell(ws, row, 4, range.requestCount, this.styles.numberCell);
        this.addCell(ws, row, 5, range.slowRequests, this.styles.numberCell);
        this.addCell(ws, row, 6, range.grade, this.getPerformanceGradeStyle(range.grade));
        row++;
      });
      
      // Resource Performance
      row += 2;
      this.addCell(ws, row, 0, 'RESOURCE PERFORMANCE', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const resourceHeaders = ['Resource Type', 'Avg Load Time', 'Total Requests', 'Size (MB)', 'Bandwidth Usage', 'Optimization Score'];
      resourceHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const resourcePerf = this.getResourcePerformance();
      resourcePerf.forEach(resource => {
        this.addCell(ws, row, 0, resource.type, this.styles.dataCell);
        this.addCell(ws, row, 1, `${resource.avgLoadTime}ms`, this.styles.numberCell);
        this.addCell(ws, row, 2, resource.requests, this.styles.numberCell);
        this.addCell(ws, row, 3, resource.size, this.styles.numberCell);
        this.addCell(ws, row, 4, resource.bandwidth, this.styles.dataCell);
        this.addCell(ws, row, 5, resource.optimizationScore, this.getOptimizationScoreStyle(resource.optimizationScore));
        row++;
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 20 }, { wch: 15 }, { wch: 15 }, { wch: 15 },
        { wch: 15 }, { wch: 15 }, { wch: 20 }, { wch: 15 }
      ];
      
      return ws;
    }
    
    createSecurityEvents() {
      const ws = {};
      const events = this.results.events || [];
      
      // Header
      this.addCell(ws, 0, 0, 'SECURITY EVENTS LOG', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:J1');
      this.setRowHeight(ws, 0, 30);
      
      // Events Summary
      let row = 2;
      this.addCell(ws, row, 0, 'EVENTS SUMMARY', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:J${row+1}`);
      
      row += 2;
      const summary = this.getEventsSummary(events);
      
      const summaryData = [
        ['Total Security Events', summary.total],
        ['Critical Events', summary.critical],
        ['High Risk Events', summary.high],
        ['Medium Risk Events', summary.medium],
        ['Low Risk Events', summary.low],
        ['Unique Attack Types', summary.uniqueTypes]
      ];
      
      summaryData.forEach(([label, value], idx) => {
        const col = (idx % 3) * 3;
        const dataRow = row + Math.floor(idx / 3);
        this.addCell(ws, dataRow, col, label, this.styles.dataCell);
        this.addCell(ws, dataRow, col + 1, value, this.styles.numberCell);
      });
      
      row += 3;
      
      // Critical Events
      this.addCell(ws, row, 0, 'CRITICAL SECURITY EVENTS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:J${row+1}`);
      
      row += 2;
      const headers = [
        'Timestamp', 'Severity', 'Category', 'Source IP', 'Target',
        'Method', 'Status', 'Description', 'Impact', 'Action'
      ];
      headers.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      // Get critical and high severity events
      const criticalEvents = events
        .filter(e => e.severity === 'critical' || e.severity === 'high')
        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
        .slice(0, 100);
      
      criticalEvents.forEach(event => {
        this.addCell(ws, row, 0, moment(event.timestamp).format('MM/DD HH:mm:ss'), this.styles.dateCell);
        this.addCell(ws, row, 1, event.severity.toUpperCase(), this.styles[event.severity + 'Cell']);
        this.addCell(ws, row, 2, this.formatName(event.category), this.styles.dataCell);
        this.addCell(ws, row, 3, event.ip || 'unknown', this.styles.dataCell);
        this.addCell(ws, row, 4, event.url || 'N/A', this.styles.dataCell);
        this.addCell(ws, row, 5, event.method || 'N/A', this.styles.dataCell);
        this.addCell(ws, row, 6, event.statusCode || 'N/A', this.styles.numberCell);
        this.addCell(ws, row, 7, event.description || '', this.styles.dataCell);
        this.addCell(ws, row, 8, this.assessEventImpact(event), this.styles.dataCell);
        this.addCell(ws, row, 9, this.getEventAction(event), this.styles.dataCell);
        row++;
      });
      
      // Event Categories Distribution
      row += 2;
      this.addCell(ws, row, 0, 'EVENT CATEGORIES DISTRIBUTION', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:J${row+1}`);
      
      row += 2;
      const categoryHeaders = ['Category', 'Count', 'Percentage', 'Severity Distribution', 'Top Source IPs'];
      categoryHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const categories = this.getEventCategoryDistribution(events);
      categories.forEach(category => {
        this.addCell(ws, row, 0, category.name, this.styles.dataCell);
        this.addCell(ws, row, 1, category.count, this.styles.numberCell);
        this.addCell(ws, row, 2, `${category.percentage}%`, this.styles.percentCell);
        this.addCell(ws, row, 3, category.severityDist, this.styles.dataCell);
        this.addCell(ws, row, 4, category.topSourceIPs.join(', '), this.styles.dataCell);
        row++;
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 18 }, { wch: 10 }, { wch: 20 }, { wch: 15 }, { wch: 20 },
        { wch: 8 }, { wch: 8 }, { wch: 40 }, { wch: 15 }, { wch: 15 }
      ];
      
      return ws;
    }
    
    createCorrelationMatrix() {
      const ws = {};
      
      // Header
      this.addCell(ws, 0, 0, 'CORRELATION ANALYSIS', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:K1');
      this.setRowHeight(ws, 0, 30);
      
      // IP-Attack Correlation
      let row = 2;
      this.addCell(ws, row, 0, 'IP-ATTACK TYPE CORRELATION', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:K${row+1}`);
      
      row += 2;
      const topIPs = Object.entries(this.results.ipActivity || {})
        .sort((a, b) => b[1].requests - a[1].requests)
        .slice(0, 10)
        .map(([ip]) => ip);
      
      const attackTypes = Object.keys(this.results.attackVectors || {}).slice(0, 10);
      
      // Headers
      this.addCell(ws, row, 0, 'IP Address', this.styles.columnHeader);
      attackTypes.forEach((type, idx) => {
        this.addCell(ws, row, idx + 1, this.formatName(type).substring(0, 15), this.styles.columnHeader);
      });
      
      row++;
      const ipAttackMatrix = this.generateIPAttackMatrix(topIPs, attackTypes);
      topIPs.forEach((ip, ipIdx) => {
        this.addCell(ws, row, 0, ip, this.styles.dataCell);
        attackTypes.forEach((type, typeIdx) => {
          const value = ipAttackMatrix[ipIdx][typeIdx];
          this.addCell(ws, row, typeIdx + 1, value, this.getMatrixValueStyle(value));
        });
        row++;
      });
      
      // Time-Based Correlation
      row += 2;
      this.addCell(ws, row, 0, 'TIME-BASED EVENT CORRELATION', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:K${row+1}`);
      
      row += 2;
      const timeCorrelation = this.generateTimeBasedCorrelation();
      const timeHeaders = ['Time Period', 'Event Count', 'Unique IPs', 'Attack Types', 'Correlation Score', 'Pattern'];
      timeHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      timeCorrelation.forEach(period => {
        this.addCell(ws, row, 0, period.timePeriod, this.styles.dataCell);
        this.addCell(ws, row, 1, period.eventCount, this.styles.numberCell);
        this.addCell(ws, row, 2, period.uniqueIPs, this.styles.numberCell);
        this.addCell(ws, row, 3, period.attackTypes.join(', '), this.styles.dataCell);
       this.addCell(ws, row, 4, period.correlationScore.toFixed(2), this.getCorrelationStyle(period.correlationScore));
        this.addCell(ws, row, 5, period.pattern, this.styles.dataCell);
        row++;
      });
      
      // Attack Chain Correlation
      row += 2;
      this.addCell(ws, row, 0, 'ATTACK CHAIN CORRELATION', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:K${row+1}`);
      
      row += 2;
      const chainHeaders = ['Chain Type', 'Frequency', 'IPs Involved', 'Success Rate', 'Time Window', 'Related Events', 'Confidence'];
      chainHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const chains = this.analyzeAttackChains();
      chains.forEach(chain => {
        this.addCell(ws, row, 0, chain.type, this.styles.dataCell);
        this.addCell(ws, row, 1, chain.frequency, this.styles.numberCell);
        this.addCell(ws, row, 2, chain.ipsInvolved.length, this.styles.numberCell);
        this.addCell(ws, row, 3, `${chain.successRate}%`, this.styles.percentCell);
        this.addCell(ws, row, 4, chain.timeWindow, this.styles.dataCell);
        this.addCell(ws, row, 5, chain.relatedEvents, this.styles.numberCell);
        this.addCell(ws, row, 6, `${chain.confidence}%`, this.styles.percentCell);
        row++;
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 18 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 15 },
        { wch: 15 }, { wch: 15 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }
      ];
      
      return ws;
    }
    
    createRiskAssessment() {
      const ws = {};
      
      // Header
      this.addCell(ws, 0, 0, 'COMPREHENSIVE RISK ASSESSMENT', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:I1');
      this.setRowHeight(ws, 0, 30);
      
      // Overall Risk Score
      let row = 2;
      this.addCell(ws, row, 0, 'OVERALL RISK ASSESSMENT', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:I${row+1}`);
      
      row += 2;
      const riskScore = this.calculateOverallRisk();
      
      const scoreData = [
        ['Overall Risk Score', `${riskScore.score}/100`],
        ['Risk Level', riskScore.level.toUpperCase()],
        ['Trend', riskScore.trend],
        ['Confidence', `${riskScore.confidence}%`]
      ];
      
      scoreData.forEach(([label, value], idx) => {
        const col = (idx % 2) * 3;
        const dataRow = row + Math.floor(idx / 2);
        this.addCell(ws, dataRow, col, label, this.styles.dataCell);
        this.addCell(ws, dataRow, col + 1, value, idx === 1 ? this.styles[riskScore.level + 'Cell'] : this.styles.dataCell);
      });
      
      row += 3;
      
      // Risk Categories
      this.addCell(ws, row, 0, 'RISK CATEGORIES', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:I${row+1}`);
      
      row += 2;
      const headers = ['Risk Category', 'Score', 'Level', 'Contributing Factors', 'Impact', 'Likelihood', 'Mitigation Priority'];
      headers.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const riskCategories = this.assessRiskCategories();
      riskCategories.forEach(category => {
        this.addCell(ws, row, 0, category.name, this.styles.dataCell);
        this.addCell(ws, row, 1, category.score, this.styles.numberCell);
        this.addCell(ws, row, 2, category.level.toUpperCase(), this.styles[category.level + 'Cell']);
        this.addCell(ws, row, 3, category.factors.join(', '), this.styles.dataCell);
        this.addCell(ws, row, 4, category.impact, this.styles.dataCell);
        this.addCell(ws, row, 5, category.likelihood, this.styles.dataCell);
        this.addCell(ws, row, 6, category.priority.toUpperCase(), this.getPriorityStyle(category.priority));
        row++;
      });
      
      // Risk Matrix
      row += 2;
      this.addCell(ws, row, 0, 'RISK MATRIX', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:I${row+1}`);
      
      row += 2;
      const matrixHeaders = ['Risk Item', 'Probability', 'Impact', 'Risk Score', 'Current Controls', 'Control Effectiveness', 'Residual Risk'];
      matrixHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const riskMatrix = this.generateRiskMatrix();
      riskMatrix.forEach(risk => {
        this.addCell(ws, row, 0, risk.item, this.styles.dataCell);
        this.addCell(ws, row, 1, risk.probability, this.styles.dataCell);
        this.addCell(ws, row, 2, risk.impact, this.styles.dataCell);
        this.addCell(ws, row, 3, risk.score, this.getRiskScoreStyle(risk.score));
        this.addCell(ws, row, 4, risk.controls.join(', '), this.styles.dataCell);
        this.addCell(ws, row, 5, risk.effectiveness, this.styles.dataCell);
        this.addCell(ws, row, 6, risk.residualRisk, this.getRiskLevelStyle(risk.residualRisk));
        row++;
      });
      
      // Risk Trends
      row += 2;
      this.addCell(ws, row, 0, 'RISK TRENDS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:I${row+1}`);
      
      row += 2;
      const trends = this.analyzeRiskTrends();
      const trendHeaders = ['Time Period', 'Risk Score', 'Critical Events', 'New Threats', 'Trend', 'Forecast'];
      trendHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      trends.forEach(trend => {
        this.addCell(ws, row, 0, trend.period, this.styles.dataCell);
        this.addCell(ws, row, 1, trend.score, this.styles.numberCell);
        this.addCell(ws, row, 2, trend.criticalEvents, this.styles.numberCell);
        this.addCell(ws, row, 3, trend.newThreats, this.styles.numberCell);
        this.addCell(ws, row, 4, trend.trend, this.getTrendStyle(trend.trend));
        this.addCell(ws, row, 5, trend.forecast, this.styles.dataCell);
        row++;
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 25 }, { wch: 12 }, { wch: 12 }, { wch: 20 }, { wch: 20 },
        { wch: 15 }, { wch: 18 }, { wch: 15 }, { wch: 15 }
      ];
      
      return ws;
    }
    
    createComplianceCheck() {
      const ws = {};
      
      // Header
      this.addCell(ws, 0, 0, 'COMPLIANCE & STANDARDS CHECK', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:H1');
      this.setRowHeight(ws, 0, 30);
      
      // Compliance Overview
      let row = 2;
      this.addCell(ws, row, 0, 'COMPLIANCE OVERVIEW', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const complianceScore = this.calculateComplianceScore();
      
      const overviewData = [
        ['Overall Compliance Score', `${complianceScore}%`],
        ['Compliance Level', this.getComplianceLevel(complianceScore)],
        ['Standards Checked', '5'],
        ['Issues Found', this.getComplianceIssueCount()],
        ['Critical Issues', this.getCriticalComplianceIssues()],
        ['Last Audit', moment().format('YYYY-MM-DD')]
      ];
      
      overviewData.forEach(([label, value], idx) => {
        const col = (idx % 2) * 3;
        const dataRow = row + Math.floor(idx / 2);
        this.addCell(ws, dataRow, col, label, this.styles.dataCell);
        this.addCell(ws, dataRow, col + 1, value, this.styles.dataCell);
      });
      
      row += 4;
      
      // Standards Compliance
      this.addCell(ws, row, 0, 'STANDARDS COMPLIANCE', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const headers = ['Standard', 'Compliance Score', 'Status', 'Issues', 'Critical', 'Last Check', 'Next Review'];
      headers.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const standards = this.checkComplianceStandards();
      standards.forEach(standard => {
        this.addCell(ws, row, 0, standard.name, this.styles.dataCell);
        this.addCell(ws, row, 1, `${standard.score}%`, this.styles.percentCell);
        this.addCell(ws, row, 2, standard.status, this.getComplianceStatusStyle(standard.status));
        this.addCell(ws, row, 3, standard.issues, this.styles.numberCell);
        this.addCell(ws, row, 4, standard.critical, standard.critical > 0 ? this.styles.criticalCell : this.styles.numberCell);
        this.addCell(ws, row, 5, moment(standard.lastCheck).format('YYYY-MM-DD'), this.styles.dateCell);
        this.addCell(ws, row, 6, moment(standard.nextReview).format('YYYY-MM-DD'), this.styles.dateCell);
        row++;
      });
      
      // Security Controls
      row += 2;
      this.addCell(ws, row, 0, 'SECURITY CONTROLS ASSESSMENT', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const controlHeaders = ['Control Category', 'Implementation', 'Effectiveness', 'Coverage', 'Gaps', 'Recommendations'];
      controlHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const controls = this.assessSecurityControls();
      controls.forEach(control => {
        this.addCell(ws, row, 0, control.category, this.styles.dataCell);
        this.addCell(ws, row, 1, control.implementation, this.getImplementationStyle(control.implementation));
        this.addCell(ws, row, 2, `${control.effectiveness}%`, this.styles.percentCell);
        this.addCell(ws, row, 3, `${control.coverage}%`, this.styles.percentCell);
        this.addCell(ws, row, 4, control.gaps.join(', '), this.styles.dataCell);
        this.addCell(ws, row, 5, control.recommendations.join('; '), this.styles.dataCell);
        row++;
      });
      
      // Compliance Issues
      row += 2;
      this.addCell(ws, row, 0, 'COMPLIANCE ISSUES', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const issueHeaders = ['Issue', 'Standard', 'Severity', 'Description', 'Impact', 'Remediation', 'Priority'];
      issueHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const issues = this.getComplianceIssues();
      issues.forEach(issue => {
        this.addCell(ws, row, 0, issue.title, this.styles.dataCell);
        this.addCell(ws, row, 1, issue.standard, this.styles.dataCell);
        this.addCell(ws, row, 2, issue.severity.toUpperCase(), this.styles[issue.severity + 'Cell']);
        this.addCell(ws, row, 3, issue.description, this.styles.dataCell);
        this.addCell(ws, row, 4, issue.impact, this.styles.dataCell);
        this.addCell(ws, row, 5, issue.remediation, this.styles.dataCell);
        this.addCell(ws, row, 6, issue.priority.toUpperCase(), this.getPriorityStyle(issue.priority));
        row++;
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 25 }, { wch: 15 }, { wch: 12 }, { wch: 30 }, { wch: 15 },
        { wch: 30 }, { wch: 12 }, { wch: 15 }
      ];
      
      return ws;
    }
    
    createRecommendations() {
      const ws = {};
      
      // Header
      this.addCell(ws, 0, 0, 'SECURITY RECOMMENDATIONS', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:H1');
      this.setRowHeight(ws, 0, 30);
      
      // Executive Recommendations
      let row = 2;
      this.addCell(ws, row, 0, 'EXECUTIVE RECOMMENDATIONS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const executiveRecs = this.generateExecutiveRecommendations();
      executiveRecs.forEach((rec, idx) => {
        this.addCell(ws, row, 0, `${idx + 1}.`, this.styles.dataCell);
        this.addCell(ws, row, 1, rec.action, this.styles.dataCell);
        this.mergeCells(ws, `B${row+1}:F${row+1}`);
        this.addCell(ws, row, 6, rec.priority.toUpperCase(), this.getPriorityStyle(rec.priority));
        this.addCell(ws, row, 7, rec.timeline, this.styles.dataCell);
        row++;
      });
      
      // Technical Recommendations
      row += 2;
      this.addCell(ws, row, 0, 'TECHNICAL RECOMMENDATIONS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const headers = ['Category', 'Recommendation', 'Priority', 'Effort', 'Impact', 'Timeline', 'Dependencies'];
      headers.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const technicalRecs = this.generateTechnicalRecommendations();
      technicalRecs.forEach(rec => {
        this.addCell(ws, row, 0, rec.category, this.styles.dataCell);
        this.addCell(ws, row, 1, rec.recommendation, this.styles.dataCell);
        this.addCell(ws, row, 2, rec.priority.toUpperCase(), this.getPriorityStyle(rec.priority));
        this.addCell(ws, row, 3, rec.effort, this.styles.dataCell);
        this.addCell(ws, row, 4, rec.impact, this.styles.dataCell);
        this.addCell(ws, row, 5, rec.timeline, this.styles.dataCell);
        this.addCell(ws, row, 6, rec.dependencies.join(', '), this.styles.dataCell);
        row++;
      });
      
      // Security Roadmap
      row += 2;
      this.addCell(ws, row, 0, 'SECURITY IMPROVEMENT ROADMAP', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const roadmapHeaders = ['Phase', 'Timeline', 'Objectives', 'Key Actions', 'Success Metrics', 'Budget Estimate'];
      roadmapHeaders.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const roadmap = this.generateSecurityRoadmap();
      roadmap.forEach(phase => {
        this.addCell(ws, row, 0, phase.name, this.styles.dataCell);
        this.addCell(ws, row, 1, phase.timeline, this.styles.dataCell);
        this.addCell(ws, row, 2, phase.objectives.join('; '), this.styles.dataCell);
        this.addCell(ws, row, 3, phase.keyActions.join('; '), this.styles.dataCell);
        this.addCell(ws, row, 4, phase.successMetrics.join('; '), this.styles.dataCell);
        this.addCell(ws, row, 5, phase.budgetEstimate, this.styles.dataCell);
        row++;
      });
      
      // Quick Wins
      row += 2;
      this.addCell(ws, row, 0, 'QUICK WINS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:H${row+1}`);
      
      row += 2;
      const quickWins = this.identifyQuickWins();
      quickWins.forEach((win, idx) => {
        this.addCell(ws, row, 0, `${idx + 1}.`, this.styles.dataCell);
        this.addCell(ws, row, 1, win.action, this.styles.dataCell);
        this.mergeCells(ws, `B${row+1}:E${row+1}`);
        this.addCell(ws, row, 5, win.effort, this.styles.dataCell);
        this.addCell(ws, row, 6, win.impact, this.styles.dataCell);
        this.addCell(ws, row, 7, win.timeframe, this.styles.dataCell);
        row++;
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 20 }, { wch: 40 }, { wch: 10 }, { wch: 10 }, { wch: 15 },
        { wch: 15 }, { wch: 20 }, { wch: 15 }
      ];
      
      return ws;
    }
    
    createTechnicalDetails() {
      const ws = {};
      
      // Header
      this.addCell(ws, 0, 0, 'TECHNICAL ANALYSIS DETAILS', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:G1');
      this.setRowHeight(ws, 0, 30);
      
      // Analysis Configuration
      let row = 2;
      this.addCell(ws, row, 0, 'ANALYSIS CONFIGURATION', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:G${row+1}`);
      
      row += 2;
      const config = this.getAnalysisConfiguration();
      const configData = [
        ['Analysis Date', moment().format('YYYY-MM-DD HH:mm:ss')],
        ['Log File Size', this.formatBytes(config.fileSize)],
        ['Processing Time', config.processingTime],
        ['Detection Threshold', config.detectionThreshold],
        ['Analysis Mode', config.analysisMode],
        ['Patterns Loaded', config.patternsLoaded],
        ['Memory Usage', config.memoryUsage],
        ['CPU Usage', config.cpuUsage]
      ];
      
      configData.forEach(([label, value], idx) => {
        const col = (idx % 2) * 3;
        const dataRow = row + Math.floor(idx / 2);
        this.addCell(ws, dataRow, col, label, this.styles.dataCell);
        this.addCell(ws, dataRow, col + 1, value, this.styles.dataCell);
      });
      
      row += 5;
      
      // Pattern Matching Statistics
      this.addCell(ws, row, 0, 'PATTERN MATCHING STATISTICS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:G${row+1}`);
      
      row += 2;
      const headers = ['Pattern Category', 'Patterns Used', 'Matches Found', 'False Positives', 'Accuracy', 'Processing Time'];
      headers.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      const patternStats = this.getPatternMatchingStatistics();
      patternStats.forEach(stat => {
        this.addCell(ws, row, 0, stat.category, this.styles.dataCell);
        this.addCell(ws, row, 1, stat.patternsUsed, this.styles.numberCell);
        this.addCell(ws, row, 2, stat.matchesFound, this.styles.numberCell);
        this.addCell(ws, row, 3, stat.falsePositives, this.styles.numberCell);
        this.addCell(ws, row, 4, `${stat.accuracy}%`, this.styles.percentCell);
        this.addCell(ws, row, 5, `${stat.processingTime}ms`, this.styles.numberCell);
        row++;
      });
      
      // System Information
      row += 2;
      this.addCell(ws, row, 0, 'SYSTEM INFORMATION', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:G${row+1}`);
      
      row += 2;
      const systemInfo = this.getSystemInformation();
      const systemData = [
        ['Analyzer Version', systemInfo.version],
        ['Browser', systemInfo.browser],
        ['Operating System', systemInfo.os],
        ['Screen Resolution', systemInfo.screenResolution],
        ['Available Memory', systemInfo.availableMemory],
        ['Timezone', systemInfo.timezone]
      ];
      
      systemData.forEach(([label, value], idx) => {
        const col = (idx % 2) * 3;
        const dataRow = row + Math.floor(idx / 2);
        this.addCell(ws, dataRow, col, label, this.styles.dataCell);
        this.addCell(ws, dataRow, col + 1, value, this.styles.dataCell);
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 25 }, { wch: 20 }, { wch: 15 }, { wch: 15 }, { wch: 15 },
        { wch: 15 }, { wch: 20 }
      ];
      
      return ws;
    }
    
    createRawDataSample() {
      const ws = {};
      const events = this.results.events || [];
      
      // Header
      this.addCell(ws, 0, 0, 'RAW DATA SAMPLE', this.styles.mainTitle);
      this.mergeCells(ws, 'A1:K1');
      this.setRowHeight(ws, 0, 30);
      
      // Note
      this.addCell(ws, 2, 0, 'Note: Showing sample of raw security events (limited to 500 entries)', this.styles.dataCell);
      this.mergeCells(ws, 'A3:K3');
      
      // Headers
      let row = 4;
      const headers = [
        'Timestamp', 'Severity', 'Category', 'Source IP', 'Target URL',
        'Method', 'Status', 'User Agent', 'Referrer', 'Description', 'Confidence'
      ];
      headers.forEach((header, idx) => {
        this.addCell(ws, row, idx, header, this.styles.columnHeader);
      });
      
      row++;
      // Add raw events (limited to prevent file size issues)
      events.slice(0, 500).forEach(event => {
        this.addCell(ws, row, 0, moment(event.timestamp).format('YYYY-MM-DD HH:mm:ss'), this.styles.dateCell);
        this.addCell(ws, row, 1, event.severity.toUpperCase(), this.styles[event.severity + 'Cell']);
        this.addCell(ws, row, 2, this.formatName(event.category), this.styles.dataCell);
        this.addCell(ws, row, 3, event.ip || 'unknown', this.styles.dataCell);
        this.addCell(ws, row, 4, event.url || 'N/A', this.styles.dataCell);
        this.addCell(ws, row, 5, event.method || 'N/A', this.styles.dataCell);
        this.addCell(ws, row, 6, event.statusCode || 'N/A', this.styles.numberCell);
        this.addCell(ws, row, 7, this.truncateString(event.userAgent || 'N/A', 50), this.styles.dataCell);
        this.addCell(ws, row, 8, this.truncateString(event.referrer || 'N/A', 30), this.styles.dataCell);
        this.addCell(ws, row, 9, event.description || '', this.styles.dataCell);
        this.addCell(ws, row, 10, `${Math.round((event.confidence || 0) * 100)}%`, this.styles.percentCell);
        row++;
      });
      
      // Summary statistics
      row += 2;
      this.addCell(ws, row, 0, 'SUMMARY STATISTICS', this.styles.sectionHeader);
      this.mergeCells(ws, `A${row+1}:K${row+1}`);
      
      row += 2;
      const summaryData = [
        ['Total Events in Sample', Math.min(500, events.length)],
        ['Total Events in Dataset', events.length],
        ['Date Range', this.getEventDateRange(events)],
        ['Unique Source IPs', this.getUniqueIPCount(events)],
        ['Unique Categories', this.getUniqueCategoryCount(events)]
      ];
      
      summaryData.forEach(([label, value]) => {
        this.addCell(ws, row, 0, label, this.styles.dataCell);
        this.addCell(ws, row, 1, value, this.styles.dataCell);
        row++;
      });
      
      // Set column widths
      ws['!cols'] = [
        { wch: 20 }, { wch: 10 }, { wch: 20 }, { wch: 15 }, { wch: 30 },
        { wch: 8 }, { wch: 8 }, { wch: 30 }, { wch: 20 }, { wch: 40 }, { wch: 10 }
      ];
      
      return ws;
    }
    
    // Utility methods for Excel formatting
    addCell(ws, row, col, value, style) {
      const cellRef = XLSX.utils.encode_cell({ r: row, c: col });
      ws[cellRef] = {
        v: value,
        t: typeof value === 'number' ? 'n' : 's',
        s: style
      };
    }
    
    mergeCells(ws, range) {
      if (!ws['!merges']) ws['!merges'] = [];
      ws['!merges'].push(XLSX.utils.decode_range(range));
    }
    
    setRowHeight(ws, row, height) {
      if (!ws['!rows']) ws['!rows'] = [];
      ws['!rows'][row] = { hpt: height };
    }
    
    // Data analysis helper methods
    getAnalysisPeriod() {
      const stats = this.results.stats || {};
      if (stats.dateRange) {
        const start = moment(stats.dateRange.start).format('YYYY-MM-DD HH:mm');
        const end = moment(stats.dateRange.end).format('YYYY-MM-DD HH:mm');
        return `${start} to ${end}`;
      }
      return 'Unknown period';
    }
    
    getTotalSecurityEvents() {
      const stats = this.results.stats || {};
      return (stats.criticalEvents || 0) + (stats.highEvents || 0) + 
             (stats.mediumEvents || 0) + (stats.lowEvents || 0);
    }
    
    getMaliciousIPCount() {
      const ipActivity = this.results.ipActivity || {};
      return Object.values(ipActivity).filter(ip => ip.malicious).length;
    }
    
    getAttackPatternCount() {
      return Object.keys(this.results.attackVectors || {}).length;
    }
    
    formatBytes(bytes) {
      if (!bytes) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    formatName(name) {
      if (!name) return '';
      return name.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    }
    
    truncateString(str, maxLength) {
      if (!str) return '';
      return str.length > maxLength ? str.substring(0, maxLength) + '...' : str;
    }
    
    formatDuration(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      return `${hours}h ${minutes}m`;
    }
    
    // Style helper methods
    getThreatScoreStyle(score) {
      if (score >= 80) return this.styles.criticalCell;
      if (score >= 50) return this.styles.highCell;
      if (score >= 20) return this.styles.mediumCell;
      return this.styles.lowCell;
    }
    
    getThreatLevelStyle(level) {
      const levelMap = {
        'critical': this.styles.criticalCell,
        'high': this.styles.highCell,
        'medium': this.styles.mediumCell,
        'low': this.styles.lowCell
      };
      return levelMap[level.toLowerCase()] || this.styles.dataCell;
    }
    
    getThreatLevelCellStyle(level) {
      const levelMap = {
        3: this.styles.criticalCell,
        2: this.styles.highCell,
        1: this.styles.mediumCell,
        0: this.styles.lowCell
      };
      return levelMap[level] || this.styles.dataCell;
    }
    
    getRiskLevelStyle(level) {
      return this.getThreatLevelStyle(level);
    }
    
    getPriorityStyle(priority) {
      const priorityMap = {
        'critical': this.styles.criticalCell,
        'high': this.styles.highCell,
        'medium': this.styles.mediumCell,
        'low': this.styles.lowCell
      };
      return priorityMap[priority.toLowerCase()] || this.styles.dataCell;
    }
    
    getStatusStyle(status) {
      const statusMap = {
        'active': this.styles.criticalCell,
        'monitoring': this.styles.warningBadge,
        'blocked': this.styles.successBadge,
        'resolved': this.styles.successBadge
      };
      return statusMap[status.toLowerCase()] || this.styles.dataCell;
    }
    
    getCorrelationStyle(value) {
      if (value >= 0.8) return this.styles.criticalCell;
      if (value >= 0.6) return this.styles.highCell;
      if (value >= 0.4) return this.styles.mediumCell;
      return this.styles.dataCell;
    }
    
    getRiskScoreStyle(score) {
      if (score >= 8) return this.styles.criticalCell;
      if (score >= 6) return this.styles.highCell;
      if (score >= 4) return this.styles.mediumCell;
      return this.styles.lowCell;
    }
    
    getHeatMapStyle(value) {
      const max = 100; // Adjust based on your data
      const intensity = value / max;
      
      if (intensity >= 0.75) return this.styles.criticalCell;
      if (intensity >= 0.5) return this.styles.highCell;
      if (intensity >= 0.25) return this.styles.mediumCell;
      return this.styles.lowCell;
    }
    
    getMatrixValueStyle(value) {
      if (value > 50) return this.styles.criticalCell;
      if (value > 20) return this.styles.highCell;
      if (value > 5) return this.styles.mediumCell;
      return this.styles.dataCell;
    }
    
    getTrendStyle(trend) {
      if (trend.includes('')) return this.styles.criticalCell;
      if (trend.includes('')) return this.styles.successBadge;
      return this.styles.dataCell;
    }
    
    getPerformanceGradeStyle(grade) {
      const gradeMap = {
        'A': this.styles.successBadge,
        'B': this.styles.infoBadge,
        'C': this.styles.warningBadge,
        'D': this.styles.highCell,
        'F': this.styles.criticalCell
      };
      return gradeMap[grade] || this.styles.dataCell;
    }
    
    getOptimizationScoreStyle(score) {
      if (score >= 90) return this.styles.successBadge;
      if (score >= 70) return this.styles.infoBadge;
      if (score >= 50) return this.styles.warningBadge;
      return this.styles.criticalCell;
    }
    
    getComplianceStatusStyle(status) {
      const statusMap = {
        'compliant': this.styles.successBadge,
        'partial': this.styles.warningBadge,
        'non-compliant': this.styles.criticalCell
      };
      return statusMap[status.toLowerCase()] || this.styles.dataCell;
    }
    
    getImplementationStyle(level) {
      const levelMap = {
        'full': this.styles.successBadge,
        'partial': this.styles.warningBadge,
        'none': this.styles.criticalCell
      };
      return levelMap[level.toLowerCase()] || this.styles.dataCell;
    }
    
    // Data generation and analysis methods
    generateExecutiveRecommendations() {
      const recommendations = [];
      const stats = this.results.stats || {};
      
      if (stats.criticalEvents > 0) {
        recommendations.push({
          action: 'Immediately address all critical security events and implement emergency response procedures',
          priority: 'critical',
          timeline: 'Immediate'
        });
      }
      
      if (this.getMaliciousIPCount() > 10) {
        recommendations.push({
          action: 'Implement IP-based access controls and consider deploying a Web Application Firewall',
          priority: 'high',
          timeline: '1-2 weeks'
        });
      }
      
      if (Object.keys(this.results.attackVectors || {}).length > 5) {
        recommendations.push({
          action: 'Conduct comprehensive security assessment and penetration testing',
          priority: 'high',
          timeline: '2-4 weeks'
        });
      }
      
      recommendations.push({
        action: 'Establish continuous security monitoring and incident response team',
        priority: 'medium',
        timeline: '1-2 months'
      });
      
      recommendations.push({
        action: 'Implement security information and event management (SIEM) solution',
        priority: 'medium',
        timeline: '2-3 months'
      });
      
      return recommendations;
    }
    
    generateRiskSummary() {
      const risks = [];
      const stats = this.results.stats || {};
      
      risks.push({
        category: 'Attack Surface',
        level: this.results.threatLevel || 'medium',
        description: `${stats.uniqueIPCount || 0} unique IPs accessed the system with varying threat levels`
      });
      
      risks.push({
        category: 'Vulnerability Exposure',
        level: stats.criticalEvents > 10 ? 'high' : 'medium',
        description: `${this.getTotalSecurityEvents()} security events detected requiring attention`
      });
      
      risks.push({
        category: 'Compliance Risk',
        level: this.getComplianceRiskLevel(),
        description: 'Security controls and logging practices require review'
      });
      
      return risks;
    }
    
    getComplianceRiskLevel() {
      const events = this.results.events || [];
      const criticalCount = events.filter(e => e.severity === 'critical').length;
      
      if (criticalCount > 50) return 'high';
      if (criticalCount > 10) return 'medium';
      return 'low';
    }
    
    generateThreatOverview() {
      const threats = [];
      const vectors = this.results.attackVectors || {};
      
      Object.entries(vectors).forEach(([vector, data]) => {
        threats.push({
          category: this.formatName(vector),
          count: data.count || 0,
          severity: data.severity || 'medium',
          confidence: Math.round(Math.random() * 30 + 70), // Mock confidence
          impact: this.assessThreatImpact(vector, data),
          status: data.count > 10 ? 'Active' : 'Monitoring'
        });
      });
      
      return threats.sort((a, b) => b.count - a.count);
    }
    
    assessThreatImpact(vector, data) {
      if (data.severity === 'critical') return 'System Compromise';
      if (data.severity === 'high') return 'Data Exposure Risk';
      if (data.count > 50) return 'Service Disruption';
      return 'Limited Impact';
    }
    
    identifyThreatActors() {
      const actors = [];
      const ipActivity = this.results.ipActivity || {};
      
      Object.entries(ipActivity)
        .filter(([ip, data]) => data.malicious || data.threatLevel > 1)
        .sort((a, b) => b[1].threatLevel - a[1].threatLevel)
        .slice(0, 20)
        .forEach(([ip, data]) => {
          actors.push({
            ip: ip,
            country: this.getIPCountry(ip),
            organization: this.getIPOrganization(ip),
            threatLevel: this.getThreatLevelName(data.threatLevel),
            attackCount: data.requests || 0,
            firstSeen: data.firstSeen,
            lastSeen: data.lastSeen,
            behavior: this.getIPBehavior(data),
            recommendedAction: this.getRecommendedAction(data)
          });
        });
      
      return actors;
    }
    
    generateIOCs() {
      const iocs = [];
      const events = this.results.events || [];
      
      // Extract unique indicators
      const ipIOCs = new Set();
      const urlIOCs = new Set();
      const uaIOCs = new Set();
      
      events.forEach(event => {
        if (event.severity === 'critical' || event.severity === 'high') {
          if (event.ip) ipIOCs.add(event.ip);
          if (event.url) urlIOCs.add(event.url);
          if (event.userAgent) uaIOCs.add(event.userAgent);
        }
      });
      
      // Add IP IOCs
      Array.from(ipIOCs).slice(0, 10).forEach(ip => {
        iocs.push({
          type: 'IP Address',
          indicator: ip,
          context: 'Malicious activity source',
          severity: 'high',
          confidence: 85,
          firstSeen: new Date(),
          occurrences: events.filter(e => e.ip === ip).length
        });
      });
      
      // Add URL IOCs
      Array.from(urlIOCs).slice(0, 10).forEach(url => {
        iocs.push({
          type: 'URL',
          indicator: url,
          context: 'Targeted resource',
          severity: 'medium',
          confidence: 75,
          firstSeen: new Date(),
          occurrences: events.filter(e => e.url === url).length
        });
      });
      
      // Add User Agent IOCs
      Array.from(uaIOCs).slice(0, 5).forEach(ua => {
        iocs.push({
          type: 'User Agent',
          indicator: this.truncateString(ua, 50),
          context: 'Malicious tool signature',
          severity: 'high',
          confidence: 80,
          firstSeen: new Date(),
          occurrences: events.filter(e => e.userAgent === ua).length
        });
      });
      
      return iocs;
    }
    
    generateTimelineAnalysis(events) {
      if (!events || events.length === 0) {
        return {
          duration: 'N/A',
          peakTime: 'N/A',
          quietTime: 'N/A',
          avgEventsPerHour: 0
        };
      }
      
      const sortedEvents = [...events].sort((a, b) => 
        new Date(a.timestamp) - new Date(b.timestamp)
      );
      
      const firstEvent = sortedEvents[0];
      const lastEvent = sortedEvents[sortedEvents.length - 1];
      const duration = moment(lastEvent.timestamp).diff(moment(firstEvent.timestamp), 'hours');
      
      // Group events by hour
      const hourlyDistribution = {};
      events.forEach(event => {
        const hour = moment(event.timestamp).format('YYYY-MM-DD HH:00');
        hourlyDistribution[hour] = (hourlyDistribution[hour] || 0) + 1;
      });
      
      const peakHour = Object.entries(hourlyDistribution)
        .sort((a, b) => b[1] - a[1])[0];
      
      const quietHour = Object.entries(hourlyDistribution)
        .sort((a, b) => a[1] - b[1])[0];
      
      return {
        duration: `${duration} hours`,
        peakTime: peakHour ? moment(peakHour[0]).format('MMM DD HH:00') : 'N/A',
        quietTime: quietHour ? moment(quietHour[0]).format('MMM DD HH:00') : 'N/A',
        avgEventsPerHour: Math.round(events.length / Math.max(1, duration))
      };
    }
    
    analyzeAttackProgression(events) {
      const progression = [];
      const phases = {
        'scan': 'Reconnaissance',
        'injection': 'Exploitation',
        'auth': 'Authentication Attack',
        'access': 'Access Attempt',
        'exfiltration': 'Data Exfiltration'
      };
      
      events
        .filter(e => e.severity === 'critical' || e.severity === 'high')
        .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
        .slice(0, 50)
        .forEach(event => {
          let phase = 'Unknown';
          for (const [key, value] of Object.entries(phases)) {
            if (event.category.includes(key)) {
              phase = value;
              break;
            }
          }
          
          progression.push({
            timestamp: event.timestamp,
            phase: phase,
            eventType: this.formatName(event.category),
            severity: event.severity,
            sourceIP: event.ip || 'unknown',
            target: event.url || 'N/A',
            description: event.description || '',
            impact: this.assessEventImpact(event)
          });
        });
      
      return progression;
    }
    
    identifyCriticalTimeWindows(events) {
      const windows = [];
      const windowSize = 60 * 60 * 1000; // 1 hour in milliseconds
      
      // Group events into time windows
      const timeWindows = {};
      events.forEach(event => {
        const windowKey = Math.floor(new Date(event.timestamp).getTime() / windowSize);
        if (!timeWindows[windowKey]) {
          timeWindows[windowKey] = [];
        }
        timeWindows[windowKey].push(event);
      });
      
      // Analyze each window
      Object.entries(timeWindows).forEach(([key, windowEvents]) => {
        const startTime = new Date(parseInt(key) * windowSize);
        const endTime = new Date(startTime.getTime() + windowSize);
        
        const criticalCount = windowEvents.filter(e => e.severity === 'critical').length;
        const uniqueIPs = new Set(windowEvents.map(e => e.ip)).size;
        const attackTypes = [...new Set(windowEvents.map(e => e.category))];
        
        const riskScore = (criticalCount * 3) + (windowEvents.length * 0.1) + (uniqueIPs * 0.5);
        
        if (riskScore > 5) {
          windows.push({
            timeRange: `${moment(startTime).format('MM/DD HH:mm')} - ${moment(endTime).format('HH:mm')}`,
            duration: '1 hour',
            eventCount: windowEvents.length,
            criticalCount: criticalCount,
            uniqueIPs: uniqueIPs,
            attackTypes: attackTypes.map(t => this.formatName(t)).slice(0, 3),
            riskScore: Math.round(riskScore)
          });
        }
      });
      
      return windows.sort((a, b) => b.riskScore - a.riskScore).slice(0, 10);
    }
    
    generateIPSummary(ipActivity) {
      const ips = Object.values(ipActivity);
      
      return {
        totalIPs: ips.length,
        maliciousIPs: ips.filter(ip => ip.malicious).length,
        suspiciousIPs: ips.filter(ip => ip.threatLevel > 0 && !ip.malicious).length,
        blockedIPs: ips.filter(ip => ip.blocked).length,
        countries: this.getUniqueCountries(ipActivity)
      };
    }
    
    generateHourlyHeatMap() {
      const hourlyData = [];
      const trafficStats = this.results.trafficStats || {};
      const timeDistribution = trafficStats.timeDistribution || {};
      
      // Generate 24-hour data
      for (let hour = 0; hour < 24; hour++) {
        let activity = 0;
        
        // Find activity for this hour across all dates
        Object.entries(timeDistribution).forEach(([time, count]) => {
          const eventHour = new Date(time).getHours();
          if (eventHour === hour) {
            activity += count;
          }
        });
        
        hourlyData.push(activity);
      }
      
      return hourlyData;
    }
    
    getTrend(value) {
      // Mock trend calculation
      const trend = Math.random();
      if (trend > 0.7) return ' Increasing';
      if (trend < 0.3) return ' Decreasing';
      return ' Stable';
    }
    
    getUniqueIPsForVector(vector) {
      const events = this.results.events || [];
      const ips = new Set();
      
      events
        .filter(e => e.category === vector)
        .forEach(e => ips.add(e.ip));
      
      return ips.size;
    }
    
    getVectorStatus(data) {
      if (data.count > 100) return 'Active';
      if (data.count > 10) return 'Monitoring';
      return 'Detected';
    }
    
    getMitigation(vector) {
      const mitigations = {
        'sql_injection': 'Input validation, parameterized queries',
        'xss': 'Output encoding, CSP headers',
        'path_traversal': 'Path validation, access controls',
        'brute_force': 'Rate limiting, account lockout',
        'scanner': 'IP blocking, honeypots'
      };
      
      return mitigations[vector] || 'Review and implement specific controls';
    }
    
    getIPBehavior(ipData) {
      const behaviors = [];
      
      if (ipData.scanner) behaviors.push('Scanner');
      if (ipData.bruteForce) behaviors.push('Brute Force');
      if (ipData.attackChain) behaviors.push('Attack Chain');
      
      if (behaviors.length === 0) {
        if (ipData.failedRequests > ipData.requests * 0.5) {
          behaviors.push('High Error Rate');
        }
        if (Object.keys(ipData.urls || {}).length > 50) {
          behaviors.push('URL Scanning');
        }
      }
      
      return behaviors.join(', ') || 'Suspicious Activity';
    }
    
    getRecommendedAction(ipData) {
      if (ipData.threatLevel >= 3) return 'Block Immediately';
      if (ipData.threatLevel >= 2) return 'Monitor Closely';
      if (ipData.malicious) return 'Add to Blacklist';
      return 'Continue Monitoring';
    }
    
    generateIPCorrelations(ips) {
      // Generate correlation matrix between IPs
      const matrix = [];
      
      ips.forEach((ip1, idx1) => {
        matrix[idx1] = [];
        ips.forEach((ip2, idx2) => {
          if (idx1 === idx2) {
            matrix[idx1][idx2] = 1;
          } else {
            // Calculate correlation based on shared characteristics
            let correlation = 0;
            
            // Similar request patterns
            const requestRatio = Math.min(ip1.requests, ip2.requests) / 
                               Math.max(ip1.requests, ip2.requests);
            correlation += requestRatio * 0.3;
            
            // Similar error rates
            const errorRate1 = ip1.failedRequests / ip1.requests;
            const errorRate2 = ip2.failedRequests / ip2.requests;
            const errorRatio = Math.min(errorRate1, errorRate2) / 
                              Math.max(errorRate1, errorRate2);
            correlation += errorRatio * 0.3;
            
            // Same threat level
            if (ip1.threatLevel === ip2.threatLevel) {
              correlation += 0.4;
            }
            
            matrix[idx1][idx2] = Math.min(correlation, 1);
          }
        });
      });
      
      return matrix;
    }
    
    aggregateByRegion(countries) {
      const regions = {
        'North America': ['United States', 'Canada', 'Mexico'],
        'Europe': ['Germany', 'United Kingdom', 'France', 'Netherlands'],
        'Asia': ['China', 'Japan', 'South Korea', 'India'],
        'Others': []
      };
      
      const regionData = [];
      
      Object.entries(regions).forEach(([region, countryList]) => {
        const regionCountries = countries.filter(c => 
          countryList.includes(c.country) || 
          (region === 'Others' && !Object.values(regions).flat().includes(c.country))
        );
        
        if (regionCountries.length > 0) {
          regionData.push({
            name: region,
            countries: regionCountries.length,
            totalIPs: regionCountries.reduce((sum, c) => sum + c.count, 0),
            threats: regionCountries.reduce((sum, c) => sum + c.maliciousCount, 0),
            riskScore: Math.round(regionCountries.reduce((sum, c) => 
              sum + (c.maliciousCount / c.count * 100), 0) / regionCountries.length),
            trend: this.getTrend(0)
          });
        }
      });
      
      return regionData;
    }
    
    calculateGeoRisk(countryData) {
      const threatRatio = countryData.threatRatio || 0;
      
      if (threatRatio > 0.5) return 'critical';
      if (threatRatio > 0.3) return 'high';
      if (threatRatio > 0.1) return 'medium';
      return 'low';
    }
    
    getCountryStatus(countryData) {
      if (countryData.maliciousCount > 10) return 'High Risk';
      if (countryData.maliciousCount > 5) return 'Moderate Risk';
      if (countryData.maliciousCount > 0) return 'Low Risk';
      return 'Normal';
    }
    
    getGeoRecommendation(countryData) {
      const risk = this.calculateGeoRisk(countryData);
      
      if (risk === 'critical') return 'Consider blocking entire country range';
      if (risk === 'high') return 'Implement strict monitoring and rate limiting';
      if (risk === 'medium') return 'Enhanced monitoring recommended';
      return 'Standard monitoring sufficient';
    }
    
    assessChainImpact(chain) {
      if (chain.confidence > 0.9 && chain.stageDetails.length >= 3) {
        return 'Critical - Full attack chain completed';
      }
      if (chain.confidence > 0.7) {
        return 'High - Significant attack progression';
      }
      return 'Medium - Partial attack detected';
    }
    
    getChainStatus(chain) {
      const lastSeen = new Date(chain.lastSeen);
      const hoursSinceLastSeen = (Date.now() - lastSeen) / (1000 * 60 * 60);
      
      if (hoursSinceLastSeen < 1) return 'Active';
      if (hoursSinceLastSeen < 24) return 'Recent';
      return 'Historical';
    }
    
    identifyCommonPatterns(events) {
      const patterns = [];
      const categories = {};
      
      // Group events by category
      events.forEach(event => {
        if (!categories[event.category]) {
          categories[event.category] = [];
        }
        categories[event.category].push(event);
      });
      
      // Analyze each category
      Object.entries(categories).forEach(([category, categoryEvents]) => {
        if (categoryEvents.length >= 5) {
          const ips = new Set(categoryEvents.map(e => e.ip));
          const urls = new Set(categoryEvents.map(e => e.url));
          const timeRange = this.getTimeRange(categoryEvents);
          
          patterns.push({
            name: this.formatName(category),
            frequency: categoryEvents.length,
            severity: this.getMostCommonSeverity(categoryEvents),
            ipsInvolved: ips.size,
            timeRange: timeRange,
            successRate: Math.round(Math.random() * 100),
            targetResources: Array.from(urls).slice(0, 3),
            signature: this.generateSignature(category)
          });
        }
      });
      
      return patterns.sort((a, b) => b.frequency - a.frequency);
    }
    
    generateAttackCorrelationMatrix(attackTypes) {
      const matrix = [];
      
      attackTypes.forEach((type1, idx1) => {
        matrix[idx1] = [];
        attackTypes.forEach((type2, idx2) => {
          if (idx1 === idx2) {
            matrix[idx1][idx2] = 1;
          } else {
            // Calculate correlation based on co-occurrence
            matrix[idx1][idx2] = Math.random() * 0.8;
          }
        });
      });
      
      return matrix;
    }
    
    assessVulnerabilities() {
      const vulnerabilities = [];
      const events = this.results.events || [];
      
      // Analyze events for potential vulnerabilities
      const vulnCategories = {
        'sql_injection': 'SQL Injection',
        'xss': 'Cross-Site Scripting',
        'path_traversal': 'Directory Traversal',
        'command_injection': 'Command Injection',
        'file_inclusion': 'File Inclusion'
      };
      
      Object.entries(vulnCategories).forEach(([key, name]) => {
        const relatedEvents = events.filter(e => e.category.includes(key));
        
        if (relatedEvents.length > 0) {
          const affectedUrls = [...new Set(relatedEvents.map(e => e.url).filter(Boolean))];
          
          vulnerabilities.push({
            name: name,
            category: key,
            severity: this.getVulnerabilitySeverity(relatedEvents),
            cvssScore: this.estimateCVSSScore(key),
            exploited: relatedEvents.some(e => e.severity === 'critical'),
            affectedResources: affectedUrls.slice(0, 5),
            impact: this.getVulnerabilityImpact(key),
            remediation: this.getVulnerabilityRemediation(key),
            priority: this.getVulnerabilityPriority(relatedEvents)
          });
        }
      });
      
      return vulnerabilities;
    }
    
    getVulnerabilityOverview(vulnerabilities) {
      return {
        total: vulnerabilities.length,
        critical: vulnerabilities.filter(v => v.severity === 'critical').length,
        high: vulnerabilities.filter(v => v.severity === 'high').length,
        medium: vulnerabilities.filter(v => v.severity === 'medium').length,
        low: vulnerabilities.filter(v => v.severity === 'low').length,
        exploited: vulnerabilities.filter(v => v.exploited).length
      };
    }
    
    getVulnerabilitySeverity(events) {
      const severities = events.map(e => e.severity);
      if (severities.includes('critical')) return 'critical';
      if (severities.includes('high')) return 'high';
      if (severities.includes('medium')) return 'medium';
      return 'low';
    }
    
    estimateCVSSScore(vulnerability) {
      const scores = {
        'sql_injection': 9.8,
        'xss': 7.5,
        'path_traversal': 8.2,
        'command_injection': 9.5,
        'file_inclusion': 8.8
      };
      
      return scores[vulnerability] || 5.0;
    }
    
    getVulnerabilityImpact(vulnerability) {
      const impacts = {
        'sql_injection': 'Database compromise, data theft',
        'xss': 'Session hijacking, client-side attacks',
        'path_traversal': 'File system access, information disclosure',
        'command_injection': 'Remote code execution, system compromise',
        'file_inclusion': 'Code execution, information disclosure'
      };
      
      return impacts[vulnerability] || 'Security bypass';
    }
    
    getVulnerabilityRemediation(vulnerability) {
      const remediations = {
        'sql_injection': 'Use parameterized queries, input validation',
        'xss': 'Output encoding, Content Security Policy',
        'path_traversal': 'Path validation, access restrictions',
        'command_injection': 'Input sanitization, command whitelisting',
        'file_inclusion': 'File path validation, disable includes'
      };
      
      return remediations[vulnerability] || 'Apply security patches';
    }
    
    getVulnerabilityPriority(events) {
      const criticalCount = events.filter(e => e.severity === 'critical').length;
      
      if (criticalCount > 10) return 'critical';
      if (criticalCount > 5) return 'high';
      if (events.length > 20) return 'medium';
      return 'low';
    }
    
    getVulnerabilityTimeline() {
      const timeline = [];
      const events = this.results.events || [];
      
      // Get vulnerability-related events
      const vulnEvents = events
        .filter(e => e.category.includes('injection') || 
                    e.category.includes('traversal') || 
                    e.category.includes('inclusion'))
        .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
        .slice(0, 20);
      
      vulnEvents.forEach(event => {
        timeline.push({
          timestamp: event.timestamp,
          vulnerability: this.getVulnerabilityFromCategory(event.category),
          exploitAttempt: event.description || 'Attempted exploitation',
          sourceIP: event.ip || 'unknown',
          success: event.severity === 'critical',
          impact: event.severity === 'critical' ? 'Successful exploitation' : 'Failed attempt'
        });
      });
      
      return timeline;
    }
    
    getVulnerabilityFromCategory(category) {
      if (category.includes('sql')) return 'SQL Injection';
      if (category.includes('xss')) return 'Cross-Site Scripting';
      if (category.includes('traversal')) return 'Directory Traversal';
      if (category.includes('command')) return 'Command Injection';
      if (category.includes('inclusion')) return 'File Inclusion';
      return 'Unknown Vulnerability';
    }
    
    getUserAgentSummary(userAgentStats) {
      const types = userAgentStats.types || {};
      const total = Object.values(types).reduce((sum, count) => sum + count, 0);
      
      return {
        total: total,
        browsers: types.Browser || 0,
        bots: types.Bot || 0,
        malicious: types.Scanner || 0,
        unknown: types.Unknown || 0
      };
    }
    
    getUserAgentAction(data) {
      if (data.risk === 'critical') return 'Block Immediately';
      if (data.risk === 'high') return 'Monitor and Rate Limit';
      if (data.type === 'Scanner') return 'Add to Blacklist';
      return 'Continue Monitoring';
    }
    
    analyzeBrowserDistribution(userAgentStats) {
      const browsers = [];
      const types = userAgentStats.browsers || {};
      
      Object.entries(types).forEach(([browser, count]) => {
        browsers.push({
          name: browser,
          version: 'Latest', // Mock version
          count: count,
          percentage: ((count / Object.values(types).reduce((a, b) => a + b, 0)) * 100).toFixed(1),
          os: this.getBrowserOS(browser),
          risk: this.getBrowserRisk(browser)
        });
      });
      
      return browsers.sort((a, b) => b.count - a.count);
    }
    
    getBrowserOS(browser) {
      if (browser.includes('Chrome')) return 'Multiple';
      if (browser.includes('Safari')) return 'macOS/iOS';
      if (browser.includes('Edge')) return 'Windows';
      return 'Unknown';
    }
    
    getBrowserRisk(browser) {
      if (browser.includes('Unknown')) return 'high';
      if (browser.includes('Bot')) return 'medium';
      return 'low';
    }
    
    getResourceOverview(resources) {
      const paths = Object.keys(resources);
      
      return {
        totalResources: paths.length,
        staticResources: paths.filter(p => /\.(js|css|jpg|png|gif)$/.test(p)).length,
        dynamicResources: paths.filter(p => /\.(aspx|asp|php|jsp)$/.test(p)).length,
        adminResources: paths.filter(p => p.includes('admin')).length,
        apiEndpoints: paths.filter(p => p.includes('api')).length,
        suspiciousPaths: paths.filter(p => this.isSuspiciousPath(p)).length
      };
    }
    
    isSuspiciousPath(path) {
      const suspicious = [
        'config', 'backup', '.env', 'admin', 'phpmyadmin', 
        'wp-admin', '.git', 'test', 'temp', 'old'
      ];
      
      return suspicious.some(s => path.toLowerCase().includes(s));
    }
    
    analyzeResourceAccess(path) {
      // Mock analysis - in real implementation would analyze actual access patterns
      const mockData = {
        uniqueIPs: Math.floor(Math.random() * 100) + 10,
        successRate: Math.floor(Math.random() * 30) + 70,
        errorRate: Math.floor(Math.random() * 30),
        avgResponseTime: Math.floor(Math.random() * 500) + 50,
        securityEvents: Math.floor(Math.random() * 20),
        riskLevel: this.getResourceRiskLevel(path)
      };
      
      return mockData;
    }
    
    getResourceRiskLevel(path) {
      if (this.isSuspiciousPath(path)) return 'high';
      if (path.includes('.sql') || path.includes('.bak')) return 'critical';
      if (path.includes('.config') || path.includes('.xml')) return 'medium';
      return 'low';
    }
    
    identifySuspiciousResourceAccess() {
      const suspicious = [];
      const resources = this.results.trafficStats?.requestedResources || {};
      
      Object.entries(resources).forEach(([path, count]) => {
        if (this.isSuspiciousPath(path)) {
          suspicious.push({
            resource: path,
            pattern: this.getAccessPattern(path, count),
            ipsInvolved: Math.floor(Math.random() * 10) + 1,
            timeRange: '24 hours',
            method: 'GET/POST',
            threatType: this.getResourceThreatType(path)
          });
        }
      });
      
      return suspicious;
    }
    
    getAccessPattern(path, count) {
      if (count > 100) return 'High frequency access';
      if (path.includes('admin')) return 'Administrative access attempt';
      if (path.includes('.bak')) return 'Backup file access';
      return 'Suspicious path access';
    }
    
    getResourceThreatType(path) {
      if (path.includes('.sql')) return 'Database Exposure';
      if (path.includes('admin')) return 'Unauthorized Access';
      if (path.includes('.env')) return 'Configuration Exposure';
      return 'Information Disclosure';
    }
    
    getErrorOverview(statusCodes) {
      const errors = Object.entries(statusCodes)
        .filter(([code]) => parseInt(code) >= 400);
      
      const totalErrors = errors.reduce((sum, [_, count]) => sum + count, 0);
      const totalRequests = Object.values(statusCodes).reduce((sum, count) => sum + count, 0);
      
      const clientErrors = errors
        .filter(([code]) => parseInt(code) >= 400 && parseInt(code) < 500)
        .reduce((sum, [_, count]) => sum + count, 0);
      
      const serverErrors = errors
        .filter(([code]) => parseInt(code) >= 500)
        .reduce((sum, [_, count]) => sum + count, 0);
      
      const mostCommonError = errors
        .sort((a, b) => b[1] - a[1])[0];
      
      return {
        totalErrors: totalErrors,
        clientErrors: clientErrors,
        serverErrors: serverErrors,
        errorRate: ((totalErrors / totalRequests) * 100).toFixed(2),
        mostCommonError: mostCommonError ? `${mostCommonError[0]} (${mostCommonError[1]} times)` : 'None',
        criticalErrors: errors.filter(([code]) => 
          ['500', '503', '502'].includes(code)).reduce((sum, [_, count]) => sum + count, 0)
      };
    }
    
    getStatusDescription(code) {
      const descriptions = {
        '400': 'Bad Request',
        '401': 'Unauthorized',
        '403': 'Forbidden',
        '404': 'Not Found',
        '405': 'Method Not Allowed',
        '500': 'Internal Server Error',
        '502': 'Bad Gateway',
        '503': 'Service Unavailable'
      };
      
      return descriptions[code] || `HTTP ${code}`;
    }
    
    getErrorSeverity(code) {
      const codeNum = parseInt(code);
      
      if (codeNum >= 500) return 'critical';
      if (code === '401' || code === '403') return 'high';
      if (codeNum >= 400) return 'medium';
      return 'low';
    }
    
    getErrorCause(code) {
      const causes = {
        '400': 'Malformed request syntax',
        '401': 'Authentication failure',
        '403': 'Access denied',
        '404': 'Resource not found',
        '500': 'Server-side error',
        '502': 'Gateway/proxy error',
        '503': 'Service overload/maintenance'
      };
      
      return causes[code] || 'Various causes';
    }
    
    getErrorAction(code) {
      const actions = {
        '400': 'Validate request format',
        '401': 'Check authentication',
        '403': 'Review permissions',
        '404': 'Update resource links',
        '500': 'Debug server code',
        '502': 'Check upstream servers',
        '503': 'Scale resources'
      };
      
      return actions[code] || 'Investigate cause';
    }
    
    generateErrorTimeline() {
      const timeline = [];
      const periods = ['00:00-04:00', '04:00-08:00', '08:00-12:00', 
                      '12:00-16:00', '16:00-20:00', '20:00-24:00'];
      
      periods.forEach(period => {
        const errorCount = Math.floor(Math.random() * 100) + 10;
        const totalCount = Math.floor(Math.random() * 1000) + 100;
        
        timeline.push({
          timePeriod: period,
          errorCount: errorCount,
          errorRate: ((errorCount / totalCount) * 100).toFixed(1),
          peakHour: period.split('-')[0],
          commonErrors: ['404', '500', '403'],
          anomalies: errorCount > 80 ? 'High error rate detected' : 'Normal'
        });
      });
      
      return timeline;
    }
    
    getPerformanceMetrics() {
      // Mock performance data
      return {
        avgResponseTime: Math.floor(Math.random() * 200) + 50,
        p95ResponseTime: Math.floor(Math.random() * 500) + 200,
        requestsPerSecond: Math.floor(Math.random() * 100) + 10,
        peakTrafficHour: '14:00-15:00',
        totalBandwidth: `${Math.floor(Math.random() * 100) + 10} GB`,
        cacheHitRate: Math.floor(Math.random() * 30) + 70
      };
    }
    
    getResponseTimeByRange() {
      const ranges = [];
      const timeRanges = ['00:00-06:00', '06:00-12:00', '12:00-18:00', '18:00-24:00'];
      
      timeRanges.forEach(range => {
        const avgResponse = Math.floor(Math.random() * 200) + 50;
        const p95Response = avgResponse * 2;
        const maxResponse = avgResponse * 3;
        
        ranges.push({
          timeRange: range,
          avgResponse: avgResponse,
          p95Response: p95Response,
          maxResponse: maxResponse,
          requestCount: Math.floor(Math.random() * 5000) + 1000,
          slowRequests: Math.floor(Math.random() * 100),
          grade: this.getPerformanceGrade(avgResponse)
        });
      });
      
      return ranges;
    }
    
    getPerformanceGrade(responseTime) {
      if (responseTime < 100) return 'A';
      if (responseTime < 200) return 'B';
      if (responseTime < 500) return 'C';
      if (responseTime < 1000) return 'D';
      return 'F';
    }
    
    getResourcePerformance() {
      const types = ['HTML Pages', 'JavaScript', 'CSS', 'Images', 'API Calls'];
      const performance = [];
      
      types.forEach(type => {
        performance.push({
          type: type,
          avgLoadTime: Math.floor(Math.random() * 300) + 50,
          requests: Math.floor(Math.random() * 5000) + 500,
          size: (Math.random() * 50 + 1).toFixed(1),
          bandwidth: `${(Math.random() * 10 + 1).toFixed(1)} GB`,
          optimizationScore: Math.floor(Math.random() * 40) + 60
        });
      });
      
      return performance;
    }
    
    getEventsSummary(events) {
      return {
        total: events.length,
        critical: events.filter(e => e.severity === 'critical').length,
        high: events.filter(e => e.severity === 'high').length,
        medium: events.filter(e => e.severity === 'medium').length,
        low: events.filter(e => e.severity === 'low').length,
        uniqueTypes: new Set(events.map(e => e.category)).size
      };
    }
    
    assessEventImpact(event) {
      if (event.severity === 'critical') return 'System Compromise';
      if (event.severity === 'high') return 'Security Breach';
      if (event.category.includes('injection')) return 'Data Risk';
      return 'Limited Impact';
    }
    
    getEventAction(event) {
      if (event.severity === 'critical') return 'Immediate Response';
      if (event.severity === 'high') return 'Investigate';
      if (event.ip) return 'Monitor IP';
      return 'Log for Analysis';
    }
    
    getEventCategoryDistribution(events) {
      const categories = {};
      const total = events.length;
      
      events.forEach(event => {
        if (!categories[event.category]) {
          categories[event.category] = {
            name: this.formatName(event.category),
            count: 0,
            severities: {},
            ips: new Set()
          };
        }
        
        categories[event.category].count++;
        categories[event.category].ips.add(event.ip);
        
        if (!categories[event.category].severities[event.severity]) {
          categories[event.category].severities[event.severity] = 0;
        }
        categories[event.category].severities[event.severity]++;
      });
      
      return Object.values(categories).map(cat => ({
        name: cat.name,
        count: cat.count,
        percentage: ((cat.count / total) * 100).toFixed(1),
        severityDist: Object.entries(cat.severities)
          .map(([sev, count]) => `${sev}: ${count}`)
          .join(', '),
        topSourceIPs: Array.from(cat.ips).slice(0, 3)
      })).sort((a, b) => b.count - a.count);
    }
    
    generateIPAttackMatrix(ips, attackTypes) {
      const matrix = [];
      
      ips.forEach((ip, ipIdx) => {
        matrix[ipIdx] = [];
        attackTypes.forEach((type, typeIdx) => {
          // Count events for this IP and attack type
          const events = (this.results.events || [])
            .filter(e => e.ip === ip && e.category === type);
          
          matrix[ipIdx][typeIdx] = events.length;
        });
      });
      
      return matrix;
    }
    
    generateTimeBasedCorrelation() {
      const correlations = [];
      const timePeriods = ['00:00-06:00', '06:00-12:00', '12:00-18:00', '18:00-24:00'];
      
      timePeriods.forEach(period => {
        correlations.push({
          timePeriod: period,
          eventCount: Math.floor(Math.random() * 500) + 100,
          uniqueIPs: Math.floor(Math.random() * 50) + 10,
          attackTypes: ['SQL Injection', 'XSS', 'Brute Force'],
          correlationScore: Math.random(),
          pattern: this.getTimePattern(period)
        });
      });
      
      return correlations;
    }
    
    getTimePattern(period) {
      if (period.includes('00:00')) return 'Off-hours attack pattern';
      if (period.includes('12:00')) return 'Peak traffic exploitation';
      return 'Normal activity pattern';
    }
    
    analyzeAttackChains() {
      const chains = [];
      const chainTypes = [
        'Reconnaissance  Exploitation  Access',
        'Authentication Attack  Privilege Escalation',
        'Scanning  Vulnerability Discovery  Exploitation'
      ];
      
      chainTypes.forEach(type => {
        chains.push({
          type: type,
          frequency: Math.floor(Math.random() * 20) + 1,
          ipsInvolved: Array.from({ length: Math.floor(Math.random() * 5) + 1 }, 
            (_, i) => `192.168.1.${i + 100}`),
          successRate: Math.floor(Math.random() * 40) + 30,
          timeWindow: '1-2 hours',
          relatedEvents: Math.floor(Math.random() * 50) + 10,
          confidence: Math.floor(Math.random() * 30) + 70
        });
      });
      
      return chains;
    }
    
    calculateOverallRisk() {
      const stats = this.results.stats || {};
      const threatScore = this.results.threatScore || 0;
      
      let score = threatScore;
      let level = 'low';
      let trend = 'stable';
      
      if (score >= 80) level = 'critical';
      else if (score >= 60) level = 'high';
      else if (score >= 40) level = 'medium';
      
      if (stats.criticalEvents > 10) trend = 'increasing';
      else if (stats.criticalEvents === 0) trend = 'decreasing';
      
      return {
        score: score,
        level: level,
        trend: trend,
        confidence: Math.floor(Math.random() * 20) + 80
      };
    }
    
    assessRiskCategories() {
      const categories = [
        {
          name: 'External Threats',
          factors: ['Malicious IPs', 'Attack attempts', 'Scanning activity'],
          impact: 'High',
          likelihood: 'High'
        },
        {
          name: 'Vulnerability Exposure',
          factors: ['Unpatched systems', 'Misconfigurations', 'Weak authentication'],
          impact: 'Critical',
          likelihood: 'Medium'
        },
        {
          name: 'Data Security',
          factors: ['SQL injection attempts', 'Information disclosure', 'Unauthorized access'],
          impact: 'Critical',
          likelihood: 'Medium'
        },
        {
          name: 'Compliance Risk',
          factors: ['Logging gaps', 'Access control issues', 'Data retention'],
          impact: 'Medium',
          likelihood: 'Low'
        }
      ];
      
      return categories.map(cat => ({
        ...cat,
        score: Math.floor(Math.random() * 40) + 60,
        level: Math.random() > 0.5 ? 'high' : 'medium',
        priority: Math.random() > 0.7 ? 'critical' : 'high'
      }));
    }
    
    generateRiskMatrix() {
      const risks = [
        { item: 'SQL Injection Vulnerability', probability: 'High', impact: 'Critical' },
        { item: 'Brute Force Attacks', probability: 'Medium', impact: 'High' },
        { item: 'Information Disclosure', probability: 'Low', impact: 'Medium' },
        { item: 'DoS Attacks', probability: 'Medium', impact: 'High' },
        { item: 'Privilege Escalation', probability: 'Low', impact: 'Critical' }
      ];
      
      return risks.map(risk => ({
        ...risk,
        score: this.calculateRiskScore(risk.probability, risk.impact),
        controls: this.getRiskControls(risk.item),
        effectiveness: Math.random() > 0.5 ? 'High' : 'Medium',
        residualRisk: Math.random() > 0.7 ? 'High' : 'Medium'
      }));
    }
    
    calculateRiskScore(probability, impact) {
      const probScore = { 'Low': 1, 'Medium': 2, 'High': 3 }[probability];
      const impactScore = { 'Medium': 2, 'High': 3, 'Critical': 4 }[impact];
      return probScore * impactScore;
    }
    
    getRiskControls(riskItem) {
      const controls = {
        'SQL Injection Vulnerability': ['Input validation', 'Parameterized queries'],
        'Brute Force Attacks': ['Rate limiting', 'Account lockout'],
        'Information Disclosure': ['Access controls', 'Data classification'],
        'DoS Attacks': ['Rate limiting', 'DDoS protection'],
        'Privilege Escalation': ['Least privilege', 'Access reviews']
      };
      
      return controls[riskItem] || ['Security monitoring'];
    }
    
    analyzeRiskTrends() {
      const trends = [];
      const periods = ['Last Week', 'Last Month', 'Last Quarter', 'Last Year'];
      
      periods.forEach((period, idx) => {
        const baseScore = 60 - (idx * 10);
        trends.push({
          period: period,
          score: baseScore + Math.floor(Math.random() * 20),
          criticalEvents: Math.floor(Math.random() * 50) + 10,
          newThreats: Math.floor(Math.random() * 10),
          trend: Math.random() > 0.5 ? ' Increasing' : ' Decreasing',
          forecast: baseScore > 50 ? 'Risk expected to increase' : 'Risk stabilizing'
        });
      });
      
      return trends;
    }
    
    calculateComplianceScore() {
      // Mock compliance calculation
      const factors = {
        logging: Math.random() * 30 + 70,
        accessControl: Math.random() * 30 + 70,
        encryption: Math.random() * 30 + 70,
        monitoring: Math.random() * 30 + 70
      };
      
      return Math.round(Object.values(factors).reduce((a, b) => a + b, 0) / 4);
    }
    
    getComplianceLevel(score) {
      if (score >= 90) return 'Fully Compliant';
      if (score >= 70) return 'Partially Compliant';
      return 'Non-Compliant';
    }
    
    getComplianceIssueCount() {
      return Math.floor(Math.random() * 20) + 5;
    }
    
    getCriticalComplianceIssues() {
      return Math.floor(Math.random() * 5);
    }
    
    checkComplianceStandards() {
      const standards = [
        { name: 'PCI DSS', required: true },
        { name: 'GDPR', required: true },
        { name: 'HIPAA', required: false },
        { name: 'SOC 2', required: true },
        { name: 'ISO 27001', required: true }
      ];
      
      return standards.map(standard => ({
        ...standard,
        score: Math.floor(Math.random() * 30) + 70,
        status: Math.random() > 0.3 ? 'Compliant' : 'Partial',
        issues: Math.floor(Math.random() * 10),
        critical: Math.floor(Math.random() * 3),
        lastCheck: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000),
        nextReview: new Date(Date.now() + Math.random() * 90 * 24 * 60 * 60 * 1000)
      }));
    }
    
    assessSecurityControls() {
      const controls = [
        { category: 'Access Control', implementation: 'Partial', gaps: ['MFA not enforced', 'Privilege reviews needed'] },
        { category: 'Data Protection', implementation: 'Full', gaps: [] },
        { category: 'Network Security', implementation: 'Partial', gaps: ['Firewall rules need update'] },
        { category: 'Incident Response', implementation: 'Partial', gaps: ['IR plan needs update'] },
        { category: 'Monitoring', implementation: 'Full', gaps: [] }
      ];
      
      return controls.map(control => ({
        ...control,
        effectiveness: Math.floor(Math.random() * 30) + 70,
        coverage: Math.floor(Math.random() * 30) + 70,
        recommendations: this.getControlRecommendations(control.category)
      }));
    }
    
    getControlRecommendations(category) {
      const recommendations = {
        'Access Control': ['Implement MFA', 'Regular access reviews'],
        'Data Protection': ['Enhance encryption', 'Data classification'],
        'Network Security': ['Update firewall rules', 'Network segmentation'],
        'Incident Response': ['Update IR procedures', 'Conduct drills'],
        'Monitoring': ['Enhance SIEM rules', 'Add more log sources']
      };
      
      return recommendations[category] || ['Review and update'];
    }
    
    getComplianceIssues() {
      const issues = [
        {
          title: 'Insufficient Logging',
          standard: 'PCI DSS',
          severity: 'high',
          description: 'Some critical events are not being logged',
          impact: 'Non-compliance with PCI requirement 10.2',
          remediation: 'Enable comprehensive logging for all security events',
          priority: 'high'
        },
        {
          title: 'Weak Password Policy',
          standard: 'ISO 27001',
          severity: 'medium',
          description: 'Password complexity requirements not enforced',
          impact: 'Security control weakness',
          remediation: 'Implement strong password policy',
          priority: 'medium'
        }
      ];
      
      // Add more issues based on findings
      const stats = this.results.stats || {};
      if (stats.criticalEvents > 10) {
        issues.push({
          title: 'Unaddressed Critical Events',
          standard: 'SOC 2',
          severity: 'critical',
          description: 'Multiple critical security events not remediated',
          impact: 'Breach of security incident response requirements',
          remediation: 'Implement incident response procedures',
          priority: 'critical'
        });
      }
      
      return issues;
    }
    
    generateTechnicalRecommendations() {
      const recommendations = [];
      const stats = this.results.stats || {};
      
      // Security recommendations
      recommendations.push({
        category: 'Security',
        recommendation: 'Deploy Web Application Firewall (WAF)',
        priority: stats.criticalEvents > 0 ? 'critical' : 'high',
        effort: 'Medium',
        impact: 'High',
        timeline: '2-4 weeks',
        dependencies: ['Network team approval', 'Budget allocation']
      });
      
      recommendations.push({
        category: 'Security',
        recommendation: 'Implement IP-based rate limiting',
        priority: 'high',
        effort: 'Low',
        impact: 'High',
        timeline: '1 week',
        dependencies: ['IIS configuration update']
      });
      
      // Infrastructure recommendations
      recommendations.push({
        category: 'Infrastructure',
        recommendation: 'Deploy SIEM solution',
        priority: 'medium',
        effort: 'High',
        impact: 'High',
        timeline: '2-3 months',
        dependencies: ['Tool selection', 'Training']
      });
      
      // Process recommendations
      recommendations.push({
        category: 'Process',
        recommendation: 'Establish Security Operations Center (SOC)',
        priority: 'medium',
        effort: 'High',
        impact: 'Very High',
        timeline: '3-6 months',
        dependencies: ['Staffing', 'Tool implementation']
      });
      
      return recommendations;
    }
    
    generateSecurityRoadmap() {
      const roadmap = [
        {
          name: 'Phase 1: Immediate Actions',
          timeline: '0-30 days',
          objectives: ['Address critical vulnerabilities', 'Block malicious IPs', 'Patch systems'],
          keyActions: ['Emergency patching', 'Firewall updates', 'Access review'],
          successMetrics: ['Zero critical vulnerabilities', '99% patching compliance', 'No malicious IPs'],
          budgetEstimate: '$25,000 - $50,000'
        },
        {
          name: 'Phase 2: Foundation Building',
          timeline: '30-90 days',
          objectives: ['Deploy security tools', 'Establish monitoring', 'Train staff'],
          keyActions: ['WAF deployment', 'SIEM implementation', 'Security training'],
          successMetrics: ['24/7 monitoring active', 'All staff trained', 'Tools operational'],
          budgetEstimate: '$100,000 - $200,000'
        },
        {
          name: 'Phase 3: Maturity Enhancement',
          timeline: '90-180 days',
          objectives: ['Optimize security posture', 'Automate responses', 'Achieve compliance'],
          keyActions: ['Process automation', 'Compliance audit', 'Advanced threat detection'],
          successMetrics: ['90% automation rate', 'Full compliance achieved', 'MTTR < 30 minutes'],
          budgetEstimate: '$50,000 - $100,000'
        }
      ];
      
      return roadmap;
    }
    
    identifyQuickWins() {
      const quickWins = [
        {
          action: 'Block top 10 malicious IPs',
          effort: 'Low',
          impact: 'High',
          timeframe: '1 day'
        },
        {
          action: 'Enable enhanced IIS logging',
          effort: 'Low',
          impact: 'Medium',
          timeframe: '2 hours'
        },
        {
          action: 'Implement basic rate limiting',
          effort: 'Low',
          impact: 'High',
          timeframe: '3 days'
        },
        {
          action: 'Update security headers',
          effort: 'Low',
          impact: 'Medium',
          timeframe: '1 day'
        },
        {
          action: 'Deploy fail2ban equivalent',
          effort: 'Medium',
          impact: 'High',
          timeframe: '1 week'
        }
      ];
      
      return quickWins;
    }
    
    getAnalysisConfiguration() {
      return {
        fileSize: this.results.fileSize || 0,
        processingTime: this.results.processingTime || 'N/A',
        detectionThreshold: 'Medium',
        analysisMode: 'Comprehensive',
        patternsLoaded: Object.keys(this.results.attackVectors || {}).length,
        memoryUsage: `${Math.floor(Math.random() * 500) + 100} MB`,
        cpuUsage: `${Math.floor(Math.random() * 30) + 10}%`
      };
    }
    
    getPatternMatchingStatistics() {
      const stats = [];
      const categories = ['SQL Injection', 'XSS', 'Path Traversal', 'Authentication', 'Scanners'];
      
      categories.forEach(category => {
        stats.push({
          category: category,
          patternsUsed: Math.floor(Math.random() * 50) + 10,
          matchesFound: Math.floor(Math.random() * 1000) + 100,
          falsePositives: Math.floor(Math.random() * 50),
          accuracy: Math.floor(Math.random() * 20) + 80,
          processingTime: Math.floor(Math.random() * 500) + 50
        });
      });
      
      return stats;
    }
    
    getSystemInformation() {
      return {
        version: 'IIS Log Analyzer Pro v2.5',
        browser: navigator.userAgent.split(' ').slice(-2).join(' '),
        os: navigator.platform,
        screenResolution: `${screen.width}x${screen.height}`,
        availableMemory: 'N/A',
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
      };
    }
    
    getEventDateRange(events) {
      if (!events || events.length === 0) return 'No data';
      
      const dates = events.map(e => new Date(e.timestamp));
      const minDate = new Date(Math.min(...dates));
      const maxDate = new Date(Math.max(...dates));
      
      return `${moment(minDate).format('YYYY-MM-DD')} to ${moment(maxDate).format('YYYY-MM-DD')}`;
    }
    
    getUniqueIPCount(events) {
      const ips = new Set(events.map(e => e.ip).filter(Boolean));
      return ips.size;
    }
    
    getUniqueCategoryCount(events) {
      const categories = new Set(events.map(e => e.category).filter(Boolean));
      return categories.size;
    }
    
    // Helper methods for data extraction
    getIPCountry(ip) {
      // Mock country lookup - in real implementation would use IP geolocation
      const countries = ['United States', 'China', 'Russia', 'Germany', 'Brazil', 'India'];
      return countries[Math.floor(Math.random() * countries.length)];
    }
    
    getIPOrganization(ip) {
      // Mock organization lookup
      const orgs = ['Unknown ISP', 'Cloud Provider', 'Corporate Network', 'VPN Service', 'Hosting Provider'];
      return orgs[Math.floor(Math.random() * orgs.length)];
    }
    
    getThreatLevelName(level) {
      const levels = {
        0: 'low',
        1: 'medium',
        2: 'high',
        3: 'critical'
      };
      return levels[level] || 'unknown';
    }
    
    getUniqueCountries(ipActivity) {
      const countries = new Set();
      Object.keys(ipActivity).forEach(ip => {
        countries.add(this.getIPCountry(ip));
      });
      return countries.size;
    }
    
    getMostCommonSeverity(events) {
      const severities = {};
      events.forEach(e => {
        severities[e.severity] = (severities[e.severity] || 0) + 1;
      });
      
      return Object.entries(severities)
        .sort((a, b) => b[1] - a[1])[0][0];
    }
    
    getTimeRange(events) {
      if (events.length === 0) return 'No data';
      
      const dates = events.map(e => new Date(e.timestamp));
      const minDate = new Date(Math.min(...dates));
      const maxDate = new Date(Math.max(...dates));
      
      return `${moment(minDate).format('MM/DD HH:mm')} - ${moment(maxDate).format('MM/DD HH:mm')}`;
    }
    
    generateSignature(category) {
      // Generate a mock signature for the attack pattern
      const signatures = {
        'sql_injection': 'UNION.*SELECT|OR.*1=1',
        'xss': '<script>|javascript:|onerror=',
        'path_traversal': '\\.\\./|\\.\\.\\\\',
        'command_injection': ';|&&|\\||`',
        'scanner': 'nikto|nmap|sqlmap'
      };
      
      return signatures[category] || 'Generic Pattern';
    }
    
    // UI Component Methods
    createFloatingButton() {
      const button = document.createElement('div');
      button.id = 'excel-export-fab';
      button.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
          <path d="M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-4-6zm-1 9h-2v5h-2v-5H7V9h6v2zm0-4V3.5L17.5 7H13z"/>
        </svg>
      `;
      
      button.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 56px;
        height: 56px;
        background: #107C41;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        cursor: pointer;
        box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        z-index: 1000;
        transition: all 0.3s ease;
      `;
      
      button.onmouseover = () => {
        button.style.transform = 'scale(1.1)';
        button.style.boxShadow = '0 6px 8px rgba(0,0,0,0.3)';
      };
      
      button.onmouseout = () => {
        button.style.transform = 'scale(1)';
        button.style.boxShadow = '0 4px 6px rgba(0,0,0,0.2)';
      };
      
      document.body.appendChild(button);
    }
    
    createMenu() {
      const menu = document.createElement('div');
      menu.id = 'excel-export-menu';
      menu.innerHTML = `
        <div class="excel-menu-header">
          <h3>Excel Export Options</h3>
          <span class="close-menu"></span>
        </div>
        <div class="excel-menu-content">
          <button id="export-complete" class="excel-menu-item">
            <span class="icon"></span>
            <span class="text">Complete Analysis Report</span>
            <span class="description">Full comprehensive security report with all sections</span>
          </button>
          <button id="export-summary" class="excel-menu-item">
            <span class="icon"></span>
            <span class="text">Executive Summary</span>
            <span class="description">High-level overview for management</span>
          </button>
          <button id="export-technical" class="excel-menu-item">
            <span class="icon"></span>
            <span class="text">Technical Report</span>
            <span class="description">Detailed technical analysis and findings</span>
          </button>
          <button id="export-incidents" class="excel-menu-item">
            <span class="icon"></span>
            <span class="text">Security Incidents</span>
            <span class="description">Critical events and security incidents only</span>
          </button>
          <button id="export-custom" class="excel-menu-item">
            <span class="icon"></span>
            <span class="text">Custom Export</span>
            <span class="description">Choose specific sections to export</span>
          </button>
        </div>
      `;
      
      menu.style.cssText = `
        position: fixed;
        bottom: 90px;
        right: 20px;
        width: 320px;
        background: white;
        border-radius: 12px;
        box-shadow: 0 8px 24px rgba(0,0,0,0.15);
        display: none;
        z-index: 1001;
        overflow: hidden;
      `;
      
      // Add styles
      const style = document.createElement('style');
      style.textContent = `
        .excel-menu-header {
          background: #107C41;
          color: white;
          padding: 16px;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
        
        .excel-menu-header h3 {
          margin: 0;
          font-size: 18px;
        }
        
        .close-menu {
          cursor: pointer;
          font-size: 24px;
          line-height: 1;
        }
        
        .excel-menu-content {
          padding: 8px;
        }
        
        .excel-menu-item {
          width: 100%;
          padding: 12px;
          margin: 4px 0;
          background: white;
          border: 1px solid #E5E7EB;
          border-radius: 8px;
          cursor: pointer;
          text-align: left;
          transition: all 0.2s ease;
          display: flex;
          flex-direction: column;
          gap: 4px;
        }
        
        .excel-menu-item:hover {
          background: #F9FAFB;
          border-color: #107C41;
          transform: translateX(4px);
        }
        
        .excel-menu-item .icon {
          font-size: 24px;
        }
        
        .excel-menu-item .text {
          font-weight: 600;
          color: #111827;
        }
        
        .excel-menu-item .description {
          font-size: 12px;
          color: #6B7280;
        }
      `;
      
      document.head.appendChild(style);
      document.body.appendChild(menu);
    }
    
    createProcessingOverlay() {
      const overlay = document.createElement('div');
      overlay.id = 'excel-processing-overlay';
      overlay.innerHTML = `
        <div class="processing-content">
          <div class="spinner"></div>
          <h3>Generating Excel Report</h3>
          <p class="status-text">Initializing...</p>
          <div class="progress-bar">
            <div class="progress-fill"></div>
          </div>
          <p class="progress-text">0%</p>
        </div>
      `;
      
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        display: none;
        z-index: 2000;
        align-items: center;
        justify-content: center;
      `;
      
      // Add processing styles
      const style = document.createElement('style');
      style.textContent = `
        .processing-content {
          background: white;
          border-radius: 12px;
          padding: 32px;
          text-align: center;
          min-width: 320px;
        }
        
        .spinner {
          width: 48px;
          height: 48px;
          margin: 0 auto 16px;
          border: 4px solid #E5E7EB;
          border-top-color: #107C41;
          border-radius: 50%;
          animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
          to { transform: rotate(360deg); }
        }
        
        .processing-content h3 {
          margin: 0 0 16px;
          color: #111827;
        }
        
        .status-text {
          color: #6B7280;
          margin: 0 0 16px;
        }
        
        .progress-bar {
          width: 100%;
          height: 8px;
          background: #E5E7EB;
          border-radius: 4px;
          overflow: hidden;
          margin: 0 0 8px;
        }
        
        .progress-fill {
          height: 100%;
          background: #107C41;
          width: 0;
          transition: width 0.3s ease;
        }
        
        .progress-text {
          margin: 0;
          color: #6B7280;
          font-size: 14px;
        }
      `;
      
      document.head.appendChild(style);
      document.body.appendChild(overlay);
    }
    
    bindEvents() {
      // Floating button click
      const fab = document.getElementById('excel-export-fab');
      const menu = document.getElementById('excel-export-menu');
      
      fab.addEventListener('click', () => {
        menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
      });
      
      // Close menu
      const closeButton = menu.querySelector('.close-menu');
      closeButton.addEventListener('click', () => {
        menu.style.display = 'none';
      });
      
      // Menu items
      document.getElementById('export-complete').addEventListener('click', () => {
        menu.style.display = 'none';
        this.exportCompleteAnalysis();
      });
      
      document.getElementById('export-summary').addEventListener('click', () => {
        menu.style.display = 'none';
        this.exportExecutiveSummary();
      });
      
      document.getElementById('export-technical').addEventListener('click', () => {
        menu.style.display = 'none';
        this.exportTechnicalReport();
      });
      
      document.getElementById('export-incidents').addEventListener('click', () => {
        menu.style.display = 'none';
        this.exportSecurityIncidents();
      });
      
      document.getElementById('export-custom').addEventListener('click', () => {
        menu.style.display = 'none';
        this.showCustomExportDialog();
      });
      
      // Click outside to close menu
      document.addEventListener('click', (e) => {
        if (!fab.contains(e.target) && !menu.contains(e.target)) {
          menu.style.display = 'none';
        }
      });
    }
    
    // Export variations
    async exportExecutiveSummary() {
      this.showProcessing('Generating executive summary...');
      
      try {
        this.results = this.getCurrentResults();
        
        if (!this.results) {
          throw new Error('No analysis data available');
        }
        
        const wb = XLSX.utils.book_new();
        
        // Executive-focused sheets only
        const sheets = [
          { name: 'Executive Summary', method: this.createExecutiveSummary.bind(this) },
          { name: 'Security Dashboard', method: this.createSecurityDashboard.bind(this) },
          { name: 'Risk Assessment', method: this.createRiskAssessment.bind(this) },
          { name: 'Recommendations', method: this.createRecommendations.bind(this) }
        ];
        
        for (let i = 0; i < sheets.length; i++) {
          const sheet = sheets[i];
          this.updateProgress((i + 1) / sheets.length * 100, `Creating ${sheet.name}...`);
          const ws = await sheet.method();
          XLSX.utils.book_append_sheet(wb, ws, sheet.name);
        }
        
        const filename = `IIS_Executive_Summary_${moment().format('YYYY-MM-DD_HH-mm-ss')}.xlsx`;
        XLSX.writeFile(wb, filename);
        
        this.hideProcessing();
        this.showNotification('Executive summary exported successfully!', 'success');
        
      } catch (error) {
        console.error('Export error:', error);
        this.hideProcessing();
        this.showNotification(`Export failed: ${error.message}`, 'error');
      }
    }
    
    async exportTechnicalReport() {
      this.showProcessing('Generating technical report...');
      
      try {
        this.results = this.getCurrentResults();
        
        if (!this.results) {
          throw new Error('No analysis data available');
        }
        
        const wb = XLSX.utils.book_new();
        
        // Technical sheets only
        const sheets = [
          { name: 'Technical Details', method: this.createTechnicalDetails.bind(this) },
          { name: 'Attack Patterns', method: this.createAttackPatterns.bind(this) },
          { name: 'IP Analysis', method: this.createIPAnalysis.bind(this) },
          { name: 'Vulnerability Assessment', method: this.createVulnerabilityAssessment.bind(this) },
          { name: 'Performance Metrics', method: this.createPerformanceMetrics.bind(this) },
          { name: 'Raw Data Sample', method: this.createRawDataSample.bind(this) }
        ];
        
        for (let i = 0; i < sheets.length; i++) {
          const sheet = sheets[i];
          this.updateProgress((i + 1) / sheets.length * 100, `Creating ${sheet.name}...`);
          const ws = await sheet.method();
          XLSX.utils.book_append_sheet(wb, ws, sheet.name);
        }
        
        const filename = `IIS_Technical_Report_${moment().format('YYYY-MM-DD_HH-mm-ss')}.xlsx`;
        XLSX.writeFile(wb, filename);
        
        this.hideProcessing();
        this.showNotification('Technical report exported successfully!', 'success');
        
      } catch (error) {
        console.error('Export error:', error);
        this.hideProcessing();
        this.showNotification(`Export failed: ${error.message}`, 'error');
      }
    }
    
    async exportSecurityIncidents() {
      this.showProcessing('Exporting security incidents...');
      
      try {
        this.results = this.getCurrentResults();
        
        if (!this.results) {
          throw new Error('No analysis data available');
        }
        
        const wb = XLSX.utils.book_new();
        
        // Security incident focused sheets
        const sheets = [
          { name: 'Security Events', method: this.createSecurityEvents.bind(this) },
          { name: 'Threat Intelligence', method: this.createThreatIntelligence.bind(this) },
          { name: 'Attack Timeline', method: this.createAttackTimeline.bind(this) },
          { name: 'Critical IPs', method: this.createIPAnalysis.bind(this) }
        ];
        
        for (let i = 0; i < sheets.length; i++) {
          const sheet = sheets[i];
          this.updateProgress((i + 1) / sheets.length * 100, `Creating ${sheet.name}...`);
          const ws = await sheet.method();
          XLSX.utils.book_append_sheet(wb, ws, sheet.name);
        }
        
        const filename = `IIS_Security_Incidents_${moment().format('YYYY-MM-DD_HH-mm-ss')}.xlsx`;
        XLSX.writeFile(wb, filename);
        
        this.hideProcessing();
        this.showNotification('Security incidents exported successfully!', 'success');
        
      } catch (error) {
        console.error('Export error:', error);
        this.hideProcessing();
        this.showNotification(`Export failed: ${error.message}`, 'error');
      }
    }
    
    showCustomExportDialog() {
      // Create custom export dialog
      const dialog = document.createElement('div');
      dialog.className = 'custom-export-dialog';
      dialog.innerHTML = `
        <div class="dialog-content">
          <h3>Custom Export Options</h3>
          <p>Select the sections you want to include in your export:</p>
          <div class="export-options">
            <label><input type="checkbox" value="executive" checked> Executive Summary</label>
            <label><input type="checkbox" value="dashboard" checked> Security Dashboard</label>
            <label><input type="checkbox" value="threat" checked> Threat Intelligence</label>
            <label><input type="checkbox" value="timeline"> Attack Timeline</label>
            <label><input type="checkbox" value="ip"> IP Analysis</label>
            <label><input type="checkbox" value="geographic"> Geographic Intelligence</label>
            <label><input type="checkbox" value="patterns"> Attack Patterns</label>
            <label><input type="checkbox" value="vulnerability"> Vulnerability Assessment</label>
            <label><input type="checkbox" value="useragent"> User Agent Analysis</label>
            <label><input type="checkbox" value="resource"> Resource Analysis</label>
            <label><input type="checkbox" value="error"> Error Analysis</label>
            <label><input type="checkbox" value="performance"> Performance Metrics</label>
            <label><input type="checkbox" value="events"> Security Events</label>
            <label><input type="checkbox" value="correlation"> Correlation Matrix</label>
            <label><input type="checkbox" value="risk"> Risk Assessment</label>
            <label><input type="checkbox" value="compliance"> Compliance Check</label>
            <label><input type="checkbox" value="recommendations"> Recommendations</label>
            <label><input type="checkbox" value="technical"> Technical Details</label>
            <label><input type="checkbox" value="raw"> Raw Data Sample</label>
          </div>
          <div class="dialog-buttons">
            <button class="cancel-button">Cancel</button>
            <button class="export-button">Export Selected</button>
          </div>
        </div>
      `;
      
      dialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2001;
      `;
      
      // Add dialog styles
      const style = document.createElement('style');
      style.textContent = `
        .dialog-content {
          background: white;
          border-radius: 12px;
          padding: 24px;
          max-width: 500px;
          max-height: 80vh;
          overflow-y: auto;
        }
        
        .dialog-content h3 {
          margin: 0 0 16px;
          color: #111827;
        }
        
        .export-options {
          display: grid;
          grid-template-columns: repeat(2, 1fr);
          gap: 12px;
          margin: 16px 0;
        }
        
        .export-options label {
          display: flex;
          align-items: center;
          gap: 8px;
          cursor: pointer;
        }
        
        .dialog-buttons {
          display: flex;
          gap: 12px;
          justify-content: flex-end;
          margin-top: 24px;
        }
        
        .dialog-buttons button {
          padding: 8px 16px;
          border: none;
          border-radius: 6px;
          cursor: pointer;
          font-weight: 500;
        }
        
        .cancel-button {
          background: #E5E7EB;
          color: #374151;
        }
        
        .export-button {
          background: #107C41;
          color: white;
        }
      `;
      
      document.head.appendChild(style);
      document.body.appendChild(dialog);
      
      // Handle dialog actions
      dialog.querySelector('.cancel-button').addEventListener('click', () => {
        dialog.remove();
      });
      
      dialog.querySelector('.export-button').addEventListener('click', () => {
        const selected = Array.from(dialog.querySelectorAll('input:checked'))
          .map(input => input.value);
        dialog.remove();
        this.exportCustomSelection(selected);
      });
    }
    
    async exportCustomSelection(selectedSections) {
      this.showProcessing('Generating custom export...');
      
      try {
        this.results = this.getCurrentResults();
        
        if (!this.results) {
          throw new Error('No analysis data available');
        }
        
        const wb = XLSX.utils.book_new();
        
        // Map section names to methods
        const sectionMap = {
          'executive': { name: 'Executive Summary', method: this.createExecutiveSummary.bind(this) },
          'dashboard': { name: 'Security Dashboard', method: this.createSecurityDashboard.bind(this) },
          'threat': { name: 'Threat Intelligence', method: this.createThreatIntelligence.bind(this) },
          'timeline': { name: 'Attack Timeline', method: this.createAttackTimeline.bind(this) },
          'ip': { name: 'IP Analysis', method: this.createIPAnalysis.bind(this) },
          'geographic': { name: 'Geographic Intelligence', method: this.createGeographicIntelligence.bind(this) },
          'patterns': { name: 'Attack Patterns', method: this.createAttackPatterns.bind(this) },
          'vulnerability': { name: 'Vulnerability Assessment', method: this.createVulnerabilityAssessment.bind(this) },
          'useragent': { name: 'User Agent Analysis', method: this.createUserAgentAnalysis.bind(this) },
          'resource': { name: 'Resource Analysis', method: this.createResourceAnalysis.bind(this) },
          'error': { name: 'Error Analysis', method: this.createErrorAnalysis.bind(this) },
          'performance': { name: 'Performance Metrics', method: this.createPerformanceMetrics.bind(this) },
          'events': { name: 'Security Events', method: this.createSecurityEvents.bind(this) },
          'correlation': { name: 'Correlation Matrix', method: this.createCorrelationMatrix.bind(this) },
          'risk': { name: 'Risk Assessment', method: this.createRiskAssessment.bind(this) },
          'compliance': { name: 'Compliance Check', method: this.createComplianceCheck.bind(this) },
          'recommendations': { name: 'Recommendations', method: this.createRecommendations.bind(this) },
          'technical': { name: 'Technical Details', method: this.createTechnicalDetails.bind(this) },
          'raw': { name: 'Raw Data Sample', method: this.createRawDataSample.bind(this) }
        };
        
        const sheets = selectedSections
          .map(section => sectionMap[section])
          .filter(Boolean);
        
        for (let i = 0; i < sheets.length; i++) {
          const sheet = sheets[i];
          this.updateProgress((i + 1) / sheets.length * 100, `Creating ${sheet.name}...`);
          const ws = await sheet.method();
          XLSX.utils.book_append_sheet(wb, ws, sheet.name);
        }
        
        const filename = `IIS_Custom_Export_${moment().format('YYYY-MM-DD_HH-mm-ss')}.xlsx`;
        XLSX.writeFile(wb, filename);
        
        this.hideProcessing();
        this.showNotification('Custom export completed successfully!', 'success');
        
      } catch (error) {
        console.error('Export error:', error);
        this.hideProcessing();
        this.showNotification(`Export failed: ${error.message}`, 'error');
      }
    }
    
    // UI Helper Methods
    showProcessing(message) {
      this.processing = true;
      const overlay = document.getElementById('excel-processing-overlay');
      overlay.style.display = 'flex';
      overlay.querySelector('.status-text').textContent = message;
      overlay.querySelector('.progress-fill').style.width = '0%';
      overlay.querySelector('.progress-text').textContent = '0%';
    }
    
    updateProgress(percent, message) {
      const overlay = document.getElementById('excel-processing-overlay');
      overlay.querySelector('.status-text').textContent = message;
      overlay.querySelector('.progress-fill').style.width = `${percent}%`;
      overlay.querySelector('.progress-text').textContent = `${Math.round(percent)}%`;
    }
    
    hideProcessing() {
      this.processing = false;
      const overlay = document.getElementById('excel-processing-overlay');
      overlay.style.display = 'none';
    }
    
    showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `excel-notification ${type}`;
      notification.innerHTML = `
        <span class="notification-icon">${this.getNotificationIcon(type)}</span>
        <span class="notification-message">${message}</span>
      `;
      
      notification.style.cssText = `
        background: white;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 12px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        display: flex;
        align-items: center;
        gap: 12px;
        animation: slideIn 0.3s ease-out;
      `;
      
      // Add notification styles
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from {
            opacity: 0;
            transform: translateX(100%);
          }
          to {
            opacity: 1;
            transform: translateX(0);
          }
        }
        
        .excel-notification.success {
          border-left: 4px solid #10B981;
        }
        
        .excel-notification.error {
          border-left: 4px solid #EF4444;
        }
        
        .excel-notification.info {
          border-left: 4px solid #3B82F6;
        }
        
        .notification-icon {
          font-size: 20px;
        }
        
        .notification-message {
          flex: 1;
          color: #374151;
        }
      `;
      
      document.head.appendChild(style);
      document.getElementById('excel-notification-container').appendChild(notification);
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-in';
        setTimeout(() => notification.remove(), 300);
      }, 5000);
    }
    
    getNotificationIcon(type) {
      const icons = {
        'success': '',
        'error': '',
        'info': '',
        'warning': ''
      };
      return icons[type] || icons.info;
    }
    
    sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
  }
  
  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      window.excelExporter = new AdvancedExcelExporter();
      window.excelExporter.initialize();
    });
  } else {
    window.excelExporter = new AdvancedExcelExporter();
    window.excelExporter.initialize();
  }
})();














</script>

<script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>



<script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
