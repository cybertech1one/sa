<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enterprise Cybersecurity Risk Intelligence Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.9/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.9/plugin/relativeTime.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@2.0.1/dist/chartjs-chart-matrix.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jstat@1.9.6/dist/jstat.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        :root {
            --primary-color: #4f46e5;
            --primary-hover: #4338ca;
            --critical-color: #ef4444;
            --high-color: #f97316;
            --medium-color: #eab308;
            --low-color: #22c55e;
            --card-bg: #ffffff;
            --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --card-border-radius: 0.75rem;
            --animation-timing: 0.3s ease;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            color: #1f2937;
            line-height: 1.6;
        }

        /* Modern Card Design */
        .dashboard-card {
            background-color: var(--card-bg);
            border-radius: var(--card-border-radius);
            box-shadow: var(--card-shadow);
            transition: transform var(--animation-timing), box-shadow var(--animation-timing);
            margin-bottom: 1.5rem;
            padding: 1.5rem;
            border: 1px solid rgba(229, 231, 235, 0.5);
        }

        .dashboard-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        /* Metric Card Design */
        .metric-card {
            background-color: #f9fafb;
            border-left: 4px solid var(--primary-color);
            transition: transform var(--animation-timing), box-shadow var(--animation-timing);
            padding: 1.25rem;
            margin-bottom: 1rem;
            border-radius: 0.5rem;
        }

        .metric-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        /* Trend Indicators */
        .trend-up {
            color: var(--critical-color);
        }

        .trend-down {
            color: var(--low-color);
        }

        .trend-indicator {
            font-size: 1.2em;
            margin-right: 0.5em;
        }

        /* Chart Container */
        .chart-container {
            position: relative;
            height: 50vh;
            width: 100%;
            max-height: 400px;
            margin-bottom: 1.5rem;
        }

        /* Progress Bar */
        .progress-bar {
            height: 8px;
            border-radius: 4px;
            background-color: #e5e7eb;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease-out;
        }

        /* Tooltips */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: pointer;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 250px;
            background-color: #334155;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 100;
            bottom: 125%;
            left: 50%;
            margin-left: -125px;
            opacity: 0;
            transition: opacity 0.3s, visibility 0.3s;
            font-size: 0.875rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.375rem;
            font-weight: 500;
            padding: 0.5rem 1rem;
            transition: all 0.2s;
            cursor: pointer;
            text-align: center;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--primary-hover);
        }

        .btn-secondary {
            background-color: #cbd5e1;
            color: #334155;
        }

        .btn-secondary:hover {
            background-color: #94a3b8;
        }

        .btn-success {
            background-color: var(--low-color);
            color: white;
        }

        .btn-success:hover {
            background-color: #16a34a;
        }

        .btn-danger {
            background-color: var(--critical-color);
            color: white;
        }

        .btn-danger:hover {
            background-color: #dc2626;
        }

        .btn-icon {
            margin-right: 0.5rem;
        }

        /* Filters */
        .filter-dropdown {
            appearance: none;
            background-color: white;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            padding: 0.5rem 2rem 0.5rem 0.75rem;
            font-size: 0.875rem;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
        }

        /* Modals */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 2rem;
            border: 1px solid #f1f5f9;
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            border-radius: 1rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .close {
            color: #64748b;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s;
        }

        .close:hover,
        .close:focus {
            color: #0f172a;
            text-decoration: none;
        }

        /* Loader */
        #loader {
            display: none;
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            backdrop-filter: blur(5px);
        }

        .loader-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
        }

        .spinner {
            width: 70px;
            text-align: center;
            margin: 0 auto 20px;
        }

        .spinner > div {
            width: 18px;
            height: 18px;
            background-color: #fff;
            border-radius: 100%;
            display: inline-block;
            animation: bounce 1.4s infinite ease-in-out both;
            margin: 0 4px;
        }

        .spinner .bounce1 {
            animation-delay: -0.32s;
        }

        .spinner .bounce2 {
            animation-delay: -0.16s;
        }

        @keyframes bounce {
            0%, 80%, 100% { 
                transform: scale(0);
            } 40% { 
                transform: scale(1.0);
            }
        }

        /* Severity colors */
        .bg-critical { background-color: rgba(239, 68, 68, 0.15); }
        .bg-high { background-color: rgba(249, 115, 22, 0.15); }
        .bg-medium { background-color: rgba(234, 179, 8, 0.15); }
        .bg-low { background-color: rgba(34, 197, 94, 0.15); }

        .text-critical { color: var(--critical-color); }
        .text-high { color: var(--high-color); }
        .text-medium { color: var(--medium-color); }
        .text-low { color: var(--low-color); }

        /* Tables */
        .table-container {
            overflow-x: auto;
            margin-bottom: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            background-color: #f8fafc;
            text-align: left;
            padding: 1rem;
            font-weight: 600;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.025em;
            color: #475569;
            border-bottom: 1px solid #e2e8f0;
        }

        td {
            padding: 1rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.875rem;
        }

        tr:hover {
            background-color: #f1f5f9;
        }

        /* Status badges */
        .status-badge {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .status-remediated {
            background-color: rgba(34, 197, 94, 0.1);
            color: #16a34a;
        }

        .status-new {
            background-color: rgba(239, 68, 68, 0.1);
            color: #dc2626;
        }

        .status-persisting {
            background-color: rgba(234, 179, 8, 0.1);
            color: #ca8a04;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                margin: 10% auto;
                padding: 1rem;
            }

            .dashboard-card {
                padding: 1rem;
            }

            .chart-container {
                height: 40vh;
            }

            th, td {
                padding: 0.75rem 0.5rem;
            }
        }

        /* AI Analysis Section */
        .ai-insight-card {
            border-left: 4px solid #8b5cf6;
            background-color: #f5f3ff;
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 0.5rem;
        }

        .ai-insight-header {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #6d28d9;
        }

        .ai-insight-icon {
            margin-right: 0.5rem;
            font-size: 1.25rem;
        }

        /* Timeline */
        .timeline {
            position: relative;
            max-width: 1200px;
            margin: 0 auto;
        }

        .timeline::after {
            content: '';
            position: absolute;
            width: 3px;
            background-color: #e2e8f0;
            top: 0;
            bottom: 0;
            left: 50%;
            margin-left: -1.5px;
        }

        .timeline-container {
            padding: 10px 40px;
            position: relative;
            background-color: inherit;
            width: 50%;
        }

        .timeline-container::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: white;
            border: 3px solid var(--primary-color);
            top: 15px;
            border-radius: 50%;
            z-index: 1;
        }

        .timeline-left {
            left: 0;
        }

        .timeline-right {
            left: 50%;
        }

        .timeline-left::after {
            right: -10px;
        }

        .timeline-right::after {
            left: -10px;
        }

        .timeline-content {
            padding: 15px;
            background-color: white;
            position: relative;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
        }

        /* Tabs */
        .tabs {
            display: flex;
            border-bottom: 1px solid #e2e8f0;
            margin-bottom: 1.5rem;
        }

        .tab {
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }

        .tab:hover {
            color: var(--primary-color);
        }

        .tab.active {
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            font-weight: 600;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Heatmap custom styles */
        .heatmap-cell {
            transition: all 0.2s;
        }

        .heatmap-cell:hover {
            transform: scale(1.1);
            stroke: #ffffff;
            stroke-width: 2px;
        }

        /* Animation utilities */
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: .5;
            }
        }

        .animate-bounce {
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 100% {
                transform: translateY(-10%);
                animation-timing-function: cubic-bezier(0.8, 0, 1, 1);
            }
            50% {
                transform: translateY(0);
                animation-timing-function: cubic-bezier(0, 0, 0.2, 1);
            }
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
    </style>
</head>
<body class="bg-gray-100">
    <!-- Header -->
    <header class="bg-gray-800 text-white shadow-lg sticky top-0 z-50">
        <div class="container mx-auto px-6 py-4">
            <div class="flex flex-col md:flex-row justify-between items-center">
                <div class="flex items-center mb-4 md:mb-0">
                    <i class="fas fa-shield-alt text-indigo-400 text-3xl mr-3"></i>
                    <h1 class="text-2xl font-bold">Enterprise Cybersecurity Risk Intelligence Dashboard</h1>
                </div>
                <nav class="flex space-x-6">
                    <button class="hover:text-indigo-300 transition-colors" onclick="openModal('trendAnalysisModal')">
                        <i class="fas fa-chart-line mr-2"></i>Trend Analysis
                    </button>
                    <button class="hover:text-indigo-300 transition-colors" onclick="openModal('predictiveAnalyticsModal')">
                        <i class="fas fa-robot mr-2"></i>AI Predictions
                    </button>
                    <button class="hover:text-indigo-300 transition-colors" onclick="openModal('riskScoreModal')">
                        <i class="fas fa-calculator mr-2"></i>Risk Score
                    </button>
                    <button class="hover:text-indigo-300 transition-colors" onclick="openModal('comparativeAnalysisModal')">
                        <i class="fas fa-balance-scale mr-2"></i>Compare Scans
                    </button>
                </nav>
            </div>
        </div>
    </header>

    <!-- Modal templates -->
    <div id="modalOverlay" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2 id="modalTitle" class="text-2xl font-bold mb-4"></h2>
            <div id="modalBody"></div>
        </div>
    </div>

    <!-- Main content -->
    <div class="container mx-auto p-6">
        <!-- Upload Section -->
        <div class="mb-6 bg-white p-6 rounded-lg shadow dashboard-card">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-xl font-bold">Data Upload and Processing</h2>
                <button id="toggleUpload" class="btn btn-primary flex items-center">
                    <i class="fas fa-upload mr-2"></i>
                    <span>Toggle Upload Section</span>
                </button>
            </div>
            <div id="uploadSections" class="hidden">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                    <div class="bg-gray-50 p-4 rounded-lg">
                        <h3 class="font-semibold mb-2 text-gray-700">Current Vulnerabilities</h3>
                        <p class="text-sm text-gray-600 mb-3">Upload your current vulnerability scan report (XLSX, CSV)</p>
                        <input type="file" id="currentFileInput" accept=".xlsx,.xls,.csv" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
                        <div class="text-xs text-gray-500 mt-2">Supported formats: CSV, XLS, XLSX</div>
                    </div>
                    <div class="bg-gray-50 p-4 rounded-lg">
                        <h3 class="font-semibold mb-2 text-gray-700">Previous Vulnerabilities</h3>
                        <p class="text-sm text-gray-600 mb-3">Upload a previous vulnerability scan for comparison</p>
                        <div class="flex flex-col space-y-3">
                            <input type="file" id="previousFileInput0" accept=".xlsx,.xls,.csv" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-purple-50 file:text-purple-700 hover:file:bg-purple-100">
                            <input type="text" id="previousFileLabel0" placeholder="Enter a label for this report (e.g. 'Last Month')" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        </div>
                    </div>
                </div>
                <div class="flex justify-between">
                    <button id="addPreviousBtn" class="btn btn-secondary flex items-center">
                        <i class="fas fa-plus mr-2"></i>
                        <span>Add Another Previous Report</span>
                    </button>
                    <button id="uploadBtn" class="btn btn-primary flex items-center">
                        <i class="fas fa-cloud-upload-alt mr-2"></i>
                        <span>Upload and Analyze</span>
                    </button>
                </div>
                <div class="mt-4 text-sm text-gray-600">
                    <p><i class="fas fa-info-circle mr-1"></i> Upload your current vulnerability scan and optionally previous scan(s) for comparison. The dashboard will analyze the data and provide insights.</p>
                </div>
            </div>
            <div id="lastUpdated" class="text-sm text-gray-600 mt-2"></div>
        </div>

        <!-- Loader -->
        <div id="loader">
            <div class="loader-content">
                <div class="spinner">
                    <div class="bounce1"></div>
                    <div class="bounce2"></div>
                    <div class="bounce3"></div>
                </div>
                <p class="text-lg font-semibold mb-2">Processing your data...</p>
                <p id="processingStatus" class="text-sm"></p>
                <p class="text-xs mt-4 max-w-md mx-auto">This may take a few moments depending on the size of your data files. The dashboard is performing in-depth analysis to provide you with comprehensive insights.</p>
            </div>
        </div>

        <!-- Filters -->
        <div id="filters" class="mb-6 bg-white p-6 rounded-lg shadow dashboard-card hidden">
            <h2 class="text-xl font-bold mb-4">Filters and Views</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-4">
                <div>
                    <label for="severityFilter" class="block text-sm font-medium text-gray-700 mb-1">Severity</label>
                    <select id="severityFilter" class="filter-dropdown w-full">
                        <option value="">All Severities</option>
                        <option value="Critical">Critical</option>
                        <option value="High">High</option>
                        <option value="Medium">Medium</option>
                        <option value="Low">Low</option>
                    </select>
                </div>
                <div>
                    <label for="missionFilter" class="block text-sm font-medium text-gray-700 mb-1">Mission/Business Unit</label>
                    <select id="missionFilter" class="filter-dropdown w-full">
                        <option value="">All Missions</option>
                    </select>
                </div>
                <div>
                    <label for="ipRangeFilter" class="block text-sm font-medium text-gray-700 mb-1">IP Range</label>
                    <input type="text" id="ipRangeFilter" placeholder="e.g. 192.168.1.0/24" class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                </div>
                <div>
                    <label for="assetTypeFilter" class="block text-sm font-medium text-gray-700 mb-1">Asset Type</label>
                    <select id="assetTypeFilter" class="filter-dropdown w-full">
                        <option value="">All Asset Types</option>
                    </select>
                </div>
            </div>
            <div class="flex justify-between">
                <div class="space-x-2">
                    <div class="inline-flex items-center">
                        <input type="radio" id="viewNormal" name="viewType" value="normal" checked class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500">
                        <label for="viewNormal" class="ml-2 text-sm text-gray-700">Standard View</label>
                    </div>
                    <div class="inline-flex items-center">
                        <input type="radio" id="viewExecutive" name="viewType" value="executive" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500">
                        <label for="viewExecutive" class="ml-2 text-sm text-gray-700">Executive View</label>
                    </div>
                    <div class="inline-flex items-center">
                        <input type="radio" id="viewTechnical" name="viewType" value="technical" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500">
                        <label for="viewTechnical" class="ml-2 text-sm text-gray-700">Technical View</label>
                    </div>
                </div>
                <button id="applyFilters" class="btn btn-primary flex items-center">
                    <i class="fas fa-filter mr-2"></i>
                    <span>Apply Filters</span>
                </button>
            </div>
        </div>

        <!-- Executive Summary -->
        <div id="executiveSummary" class="hidden dashboard-card"></div>

        <!-- AI Insights -->
        <div id="aiInsights" class="hidden dashboard-card"></div>

        <!-- Risk Score Overview -->
        <div id="riskScoreOverview" class="hidden dashboard-card"></div>

        <!-- Overall Summary -->
        <div id="overallSummary" class="hidden dashboard-card"></div>

        <!-- Comparisons -->
        <div id="comparisons" class="hidden dashboard-card"></div>

        <!-- Mission Analysis -->
        <div id="missionAnalysis" class="hidden dashboard-card"></div>

        <!-- Severity Analysis -->
        <div id="severityAnalysis" class="hidden dashboard-card"></div>

        <!-- Plugin Analysis -->
        <div id="pluginAnalysis" class="hidden dashboard-card"></div>

        <!-- IP Analysis -->
        <div id="ipAnalysis" class="hidden dashboard-card"></div>

        <!-- Remediated Vulnerabilities -->
        <div id="remediatedVulnerabilities" class="hidden dashboard-card"></div>

        <!-- New Vulnerabilities -->
        <div id="newVulnerabilities" class="hidden dashboard-card"></div>

        <!-- Asset Risk Heatmap -->
        <div id="assetRiskHeatmap" class="hidden dashboard-card"></div>

        <!-- Vulnerability Aging -->
        <div id="vulnerabilityAging" class="hidden dashboard-card"></div>

        <!-- Predictive Analysis -->
        <div id="predictiveAnalysis" class="hidden dashboard-card"></div>

        <!-- Recommended Actions -->
        <div id="recommendedActions" class="hidden dashboard-card"></div>
    </div>

    <!-- Footer -->
    <footer class="bg-gray-800 text-white py-6">
        <div class="container mx-auto px-6">
            <div class="flex flex-col md:flex-row justify-between items-center">
                <div class="mb-4 md:mb-0">
                    <p class="text-sm">Enterprise Cybersecurity Risk Intelligence Dashboard</p>
                    <p class="text-xs text-gray-400">Powered by advanced analytics and machine learning</p>
                </div>
                <div class="flex space-x-4">
                    <button id="exportDataBtn" class="btn btn-secondary text-sm flex items-center">
                        <i class="fas fa-file-export mr-2"></i>
                        <span>Export Data</span>
                    </button>
                    <button id="generateReportBtn" class="btn btn-primary text-sm flex items-center">
                        <i class="fas fa-file-pdf mr-2"></i>
                        <span>Generate Report</span>
                    </button>
                </div>
            </div>
        </div>
    </footer>

    <script>
    // Global variables
    let currentVulnerabilityData = [];
    let previousVulnerabilityData = [];
    let processedData = {};
    let previousFileCount = 1;
    let filteredData = {};
    let modalCharts = {};
    let aiInsightsGenerated = false;
    let currentViewType = 'normal';

    // Initialize when document is loaded
    document.addEventListener('DOMContentLoaded', function() {
        // Setup event listeners
        document.getElementById('uploadBtn').addEventListener('click', handleFileUpload);
        document.getElementById('addPreviousBtn').addEventListener('click', addPreviousFileInput);
        document.getElementById('toggleUpload').addEventListener('click', toggleUploadSection);
        document.getElementById('applyFilters').addEventListener('click', applyFilters);
        document.getElementById('exportDataBtn').addEventListener('click', exportAllData);
        document.getElementById('generateReportBtn').addEventListener('click', generateReport);
        
        // Setup view type radio buttons
        document.querySelectorAll('input[name="viewType"]').forEach(radio => {
            radio.addEventListener('change', function() {
                currentViewType = this.value;
                if (processedData.executiveSummary) {
                    renderDashboard(processedData);
                }
            });
        });
        
        // Setup the tooltips
        setupTooltips();
        
        // Initialize charts
        initializeCharts();
        
        // Set current date in last updated
        updateLastUpdatedTimestamp();
    });

    // Update the timestamp
    function updateLastUpdatedTimestamp() {
        const timestamp = new Date();
        document.getElementById('lastUpdated').textContent = `Last updated: ${timestamp.toLocaleString()}`;
    }

    // Toggle the upload section
    function toggleUploadSection() {
        const uploadSections = document.getElementById('uploadSections');
        uploadSections.classList.toggle('hidden');
    }

    // Add another previous file input
    function addPreviousFileInput() {
        const uploadSections = document.getElementById('uploadSections');
        const newSection = document.createElement('div');
        newSection.className = 'grid grid-cols-1 md:grid-cols-2 gap-6 mt-4';
        newSection.innerHTML = `
            <div class="bg-gray-50 p-4 rounded-lg col-span-2">
                <h3 class="font-semibold mb-2 text-gray-700">Previous Vulnerabilities ${previousFileCount + 1}</h3>
                <div class="flex flex-col space-y-3">
                    <input type="file" id="previousFileInput${previousFileCount}" accept=".xlsx,.xls,.csv" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-purple-50 file:text-purple-700 hover:file:bg-purple-100">
                    <input type="text" id="previousFileLabel${previousFileCount}" placeholder="Enter a label for this report" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                </div>
            </div>
        `;
        uploadSections.appendChild(newSection);
        previousFileCount++;
    }

    // Handle file upload
    async function handleFileUpload() {
        try {
            showLoader("Reading files...");
            
            const currentFileInput = document.getElementById('currentFileInput');
            if (!currentFileInput || !currentFileInput.files || currentFileInput.files.length === 0) {
                throw new Error("No current vulnerability file selected");
            }
            
            currentVulnerabilityData = await readFile(currentFileInput.files[0]);
            
            previousVulnerabilityData = [];
            for (let i = 0; i < previousFileCount; i++) {
                const fileInput = document.getElementById(`previousFileInput${i}`);
                const labelInput = document.getElementById(`previousFileLabel${i}`);
                if (fileInput && fileInput.files && fileInput.files[0]) {
                    const data = await readFile(fileInput.files[0]);
                    const label = labelInput && labelInput.value ? labelInput.value : `Previous ${i + 1}`;
                    previousVulnerabilityData.push({ data, label });
                }
            }

            if (previousVulnerabilityData.length === 0) {
                // Create synthetic previous data for demonstration if no previous file was uploaded
                previousVulnerabilityData.push({
                    data: generateSyntheticPreviousData(currentVulnerabilityData),
                    label: "Synthetic Previous Data"
                });
                console.log("Generated synthetic previous data for comparison");
            }

            showLoader("Processing data...");
            processedData = await processDataInChunks(currentVulnerabilityData, previousVulnerabilityData.map(pv => pv.data));

            showLoader("Analyzing data patterns...");
            processedData = enhanceDataWithAdvancedAnalytics(processedData);

            showLoader("Generating AI insights...");
            if (!aiInsightsGenerated) {
                processedData.aiInsights = generateAIInsights(processedData);
                aiInsightsGenerated = true;
            }

            showLoader("Rendering dashboard...");
            populateFilterDropdowns();
            renderDashboard(processedData);
            document.getElementById('filters').classList.remove('hidden');
            updateLastUpdatedTimestamp();
            hideLoader();
        } catch (error) {
            hideLoader();
            console.error('Error processing files:', error);
            alert('Error processing files: ' + error.message);
        }
    }

    // Generate synthetic previous data for demonstration
    function generateSyntheticPreviousData(currentData) {
        return currentData.map(vuln => {
            // Deep clone the vulnerability
            const syntheticVuln = JSON.parse(JSON.stringify(vuln));
            
            // Randomly modify some values to create differences
            const random = Math.random();
            if (random < 0.3) {
                // 30% chance to change severity (simulate remediation or increasing severity)
                const severities = ['Critical', 'High', 'Medium', 'Low'];
                const currentIndex = severities.indexOf(syntheticVuln.SEVERITY);
                const newIndex = Math.floor(Math.random() * severities.length);
                syntheticVuln.SEVERITY = severities[newIndex !== currentIndex ? newIndex : (newIndex + 1) % severities.length];
            }
            
            return syntheticVuln;
        }).filter(() => Math.random() > 0.2); // Remove about 20% of items to simulate remediated vulnerabilities
    }

    // Read file (CSV, XLS, XLSX)
async function readFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        let data;
        const extension = file.name.split('.').pop().toLowerCase();
        
        if (extension === 'csv') {
          // Parse CSV
          const result = Papa.parse(e.target.result, {
            header: true,
            skipEmptyLines: true
          });
          data = result.data;
        } else {
          // Parse Excel
          const arrayBuffer = e.target.result;
          const uint8Array = new Uint8Array(arrayBuffer); // Use different variable name
          const workbook = XLSX.read(uint8Array, { type: 'array' });
          const sheetName = workbook.SheetNames[0];
          const sheet = workbook.Sheets[sheetName];
          data = XLSX.utils.sheet_to_json(sheet, { raw: false, defval: "" });
        }
        
        // Standardize column names
        data = standardizeColumnNames(data);
        
        resolve(data);
      } catch (error) {
        reject(error);
      }
    };
    reader.onerror = (error) => reject(error);
    
    const extension = file.name.split('.').pop().toLowerCase();
    if (extension === 'csv') {
      reader.readAsText(file);
    } else {
      reader.readAsArrayBuffer(file);
    }
  });
}

    // Standardize column names to handle different formats
    function standardizeColumnNames(data) {
        if (!data || data.length === 0) return data;
        
        const columnMapping = {
            // Map various column names to standardized names
            'IP': 'IP ADDRESS',
            'IP_ADDRESS': 'IP ADDRESS',
            'HOST': 'IP ADDRESS',
            'HOST_IP': 'IP ADDRESS',
            'ADDRESS': 'IP ADDRESS',
            
            'PLUGIN': 'PLUGIN NAME',
            'PLUGIN_NAME': 'PLUGIN NAME',
            'VULNERABILITY': 'PLUGIN NAME',
            'VULN_NAME': 'PLUGIN NAME',
            'ISSUE': 'PLUGIN NAME',
            
            'RISK': 'SEVERITY',
            'CRITICALITY': 'SEVERITY',
            'PRIORITY': 'SEVERITY',
            
            'BUSINESS_UNIT': 'MISSION',
            'DEPARTMENT': 'MISSION',
            'ORG': 'MISSION',
            'ORGANIZATION': 'MISSION',
            
            'DEVICE_TYPE': 'ASSET_TYPE',
            'TYPE': 'ASSET_TYPE',
            'CATEGORY': 'ASSET_TYPE',
            
            'SYSTEM': 'ASSET',
            'DEVICE': 'ASSET',
            'HOST_NAME': 'ASSET'
        };
        
        return data.map(item => {
            const standardizedItem = {};
            
            Object.keys(item).forEach(key => {
                const standardKey = columnMapping[key.toUpperCase()] || key;
                standardizedItem[standardKey] = item[key];
            });
            
            // Ensure required fields exist
            if (!standardizedItem['IP ADDRESS'] && standardizedItem['ASSET']) {
                standardizedItem['IP ADDRESS'] = standardizedItem['ASSET'];
            }
            
            if (!standardizedItem['SEVERITY']) {
                standardizedItem['SEVERITY'] = 'Medium'; // Default severity if not specified
            }
            
            // Standardize severity values
            if (standardizedItem['SEVERITY']) {
                const severity = standardizedItem['SEVERITY'].toString().toLowerCase();
                if (severity.includes('critical') || severity.includes('crit') || severity === '4' || severity === '10') {
                    standardizedItem['SEVERITY'] = 'Critical';
                } else if (severity.includes('high') || severity === '3' || severity === '8') {
                    standardizedItem['SEVERITY'] = 'High';
                } else if (severity.includes('medium') || severity.includes('med') || severity === '2' || severity === '5') {
                    standardizedItem['SEVERITY'] = 'Medium';
                } else if (severity.includes('low') || severity === '1' || severity === '3') {
                    standardizedItem['SEVERITY'] = 'Low';
                }
            }
            
            return standardizedItem;
        });
    }

    // Process data in chunks to avoid browser freezing
    async function processDataInChunks(current, previousArray) {
        const chunkSize = 5000;
        const totalChunks = Math.ceil(current.length / chunkSize);
        let processedData = initializeProcessedData(previousArray.length);

        for (let i = 0; i < totalChunks; i++) {
            await new Promise(resolve => {
                setTimeout(() => {
                    showLoader(`Processing chunk ${i + 1} of ${totalChunks}...`);
                    const start = i * chunkSize;
                    const end = Math.min((i + 1) * chunkSize, current.length);
                    const currentChunk = current.slice(start, end);
                    const previousChunks = previousArray.map(prev => prev ? prev.slice(start, Math.min(end, prev.length)) : []);

                    const chunkData = processDataChunk(currentChunk, previousChunks, i === 0);
                    mergeChunkData(processedData, chunkData);

                    resolve();
                }, 0);
            });
        }

        return finalizeProcessedData(processedData);
    }

    // Initialize processed data structure
    function initializeProcessedData(previousCount) {
        return {
            executiveSummary: {
                current: initializeSummary(),
                previous: Array(previousCount).fill().map(() => initializeSummary())
            },
            missionAnalysis: {
                current: new Map(),
                previous: Array(previousCount).fill().map(() => new Map())
            },
            severityAnalysis: {
                current: new Map([['Critical', 0], ['High', 0], ['Medium', 0], ['Low', 0]]),
                previous: Array(previousCount).fill().map(() => new Map([['Critical', 0], ['High', 0], ['Medium', 0], ['Low', 0]]))
            },
            pluginAnalysis: {
                current: new Map(),
                previous: Array(previousCount).fill().map(() => new Map())
            },
            ipAnalysis: {
                current: new Map(),
                previous: Array(previousCount).fill().map(() => new Map())
            },
            assetTypeAnalysis: {
                current: new Map(),
                previous: Array(previousCount).fill().map(() => new Map())
            },
            assetRiskHeatmap: {
                current: {},
                previous: Array(previousCount).fill().map(() => ({}))
            },
            vulnerabilityAging: {
                new: [],
                persisting: [],
                remediated: []
            },
            remediatedVulnerabilities: [],
            newVulnerabilities: [],
            comparison: Array(previousCount).fill().map(() => ({})),
            diffAnalysis: {
                new: [],
                persisting: [],
                remediated: []
            },
            riskTrend: {
                overall: [],
                bySeverity: {
                    Critical: [],
                    High: [],
                    Medium: [],
                    Low: []
                }
            },
            aiInsights: []
        };
    }

    // Initialize summary object
    function initializeSummary() {
        return {
            totalVulnerabilities: 0,
            criticalVulnerabilities: 0,
            highVulnerabilities: 0,
            mediumVulnerabilities: 0,
            lowVulnerabilities: 0,
            uniquePlugins: new Set(),
            uniqueIPs: new Set(),
            uniqueMissions: new Set(),
            uniqueAssetTypes: new Set(),
            scanDate: new Date().toISOString()
        };
    }

    // Process a chunk of data
    function processDataChunk(currentChunk, previousChunks, isFirstChunk) {
        let chunkData = initializeProcessedData(previousChunks.length);

        // Process current vulnerability data
        currentChunk.forEach(vulnerability => {
            if (chunkData.executiveSummary && chunkData.executiveSummary.current) {
                updateSummary(chunkData.executiveSummary.current, vulnerability);
            }
            if (chunkData.missionAnalysis && chunkData.missionAnalysis.current) {
                updateMissionAnalysis(chunkData.missionAnalysis.current, vulnerability);
            }
            if (chunkData.severityAnalysis && chunkData.severityAnalysis.current) {
                updateSeverityAnalysis(chunkData.severityAnalysis.current, vulnerability);
            }
            if (chunkData.pluginAnalysis && chunkData.pluginAnalysis.current) {
                updatePluginAnalysis(chunkData.pluginAnalysis.current, vulnerability);
            }
            if (chunkData.ipAnalysis && chunkData.ipAnalysis.current) {
                updateIPAnalysis(chunkData.ipAnalysis.current, vulnerability);
            }
            if (chunkData.assetTypeAnalysis && chunkData.assetTypeAnalysis.current) {
                updateAssetTypeAnalysis(chunkData.assetTypeAnalysis.current, vulnerability);
            }
            if (chunkData.assetRiskHeatmap && chunkData.assetRiskHeatmap.current) {
                updateAssetRiskHeatmap(chunkData.assetRiskHeatmap.current, vulnerability);
            }
        });

        // Process previous vulnerability data
        previousChunks.forEach((previousChunk, index) => {
            if (previousChunk) {
                previousChunk.forEach(vulnerability => {
                    if (chunkData.executiveSummary && chunkData.executiveSummary.previous[index]) {
                        updateSummary(chunkData.executiveSummary.previous[index], vulnerability);
                    }
                    if (chunkData.missionAnalysis && chunkData.missionAnalysis.previous[index]) {
                        updateMissionAnalysis(chunkData.missionAnalysis.previous[index], vulnerability);
                    }
                    if (chunkData.severityAnalysis && chunkData.severityAnalysis.previous[index]) {
                        updateSeverityAnalysis(chunkData.severityAnalysis.previous[index], vulnerability);
                    }
                    if (chunkData.pluginAnalysis && chunkData.pluginAnalysis.previous[index]) {
                        updatePluginAnalysis(chunkData.pluginAnalysis.previous[index], vulnerability);
                    }
                    if (chunkData.ipAnalysis && chunkData.ipAnalysis.previous[index]) {
                        updateIPAnalysis(chunkData.ipAnalysis.previous[index], vulnerability);
                    }
                    if (chunkData.assetTypeAnalysis && chunkData.assetTypeAnalysis.previous[index]) {
                        updateAssetTypeAnalysis(chunkData.assetTypeAnalysis.previous[index], vulnerability);
                    }
                    if (chunkData.assetRiskHeatmap && chunkData.assetRiskHeatmap.previous[index]) {
                        updateAssetRiskHeatmap(chunkData.assetRiskHeatmap.previous[index], vulnerability);
                    }
                });
            }
        });

        // Calculate comparison data
        if (isFirstChunk && chunkData.executiveSummary) {
            chunkData.comparison = previousChunks.map((_, index) =>
                chunkData.executiveSummary.previous[index] ? 
                    compareData(chunkData.executiveSummary.current, chunkData.executiveSummary.previous[index]) : 
                    {}
            );
        }

        // Analyze differences between current and previous vulnerability data
        const chunkDiffAnalysis = analyzeDiff(currentChunk, previousChunks);
        chunkData.diffAnalysis = {
            new: (chunkData.diffAnalysis ? chunkData.diffAnalysis.new : []).concat(chunkDiffAnalysis.new),
            persisting: (chunkData.diffAnalysis ? chunkData.diffAnalysis.persisting : []).concat(chunkDiffAnalysis.persisting),
            remediated: (chunkData.diffAnalysis ? chunkData.diffAnalysis.remediated : []).concat(chunkDiffAnalysis.remediated)
        };

        // Set remediated and new vulnerabilities
        chunkData.remediatedVulnerabilities = chunkData.diffAnalysis.remediated;
        chunkData.newVulnerabilities = chunkData.diffAnalysis.new;

        return chunkData;
    }

    // Compare data to calculate changes
    function compareData(current, previous) {
        return {
            totalVulnerabilities: calculateChange(current.totalVulnerabilities, previous.totalVulnerabilities),
            criticalVulnerabilities: calculateChange(current.criticalVulnerabilities, previous.criticalVulnerabilities),
            highVulnerabilities: calculateChange(current.highVulnerabilities, previous.highVulnerabilities),
            mediumVulnerabilities: calculateChange(current.mediumVulnerabilities, previous.mediumVulnerabilities),
            lowVulnerabilities: calculateChange(current.lowVulnerabilities, previous.lowVulnerabilities),
            uniquePlugins: calculateChange(current.uniquePlugins.size, previous.uniquePlugins.size),
            uniqueIPs: calculateChange(current.uniqueIPs.size, previous.uniqueIPs.size),
            uniqueMissions: calculateChange(current.uniqueMissions.size, previous.uniqueMissions.size),
            uniqueAssetTypes: calculateChange(current.uniqueAssetTypes.size, previous.uniqueAssetTypes.size)
        };
    }

    // Calculate absolute and percentage change
    function calculateChange(currentValue, previousValue) {
        const absoluteChange = currentValue - previousValue;
        const percentageChange = previousValue !== 0 ? (absoluteChange / previousValue) * 100 : 
            (currentValue > 0 ? 100 : 0); // Avoid division by zero
        return {
            absolute: absoluteChange,
            percentage: percentageChange.toFixed(2),
            improved: absoluteChange < 0
        };
    }

    // Update summary with vulnerability data
    function updateSummary(summary, vulnerability) {
        summary.totalVulnerabilities++;
        const severity = (vulnerability.SEVERITY || '').toLowerCase();
        if (severity.includes('critical')) summary.criticalVulnerabilities++;
        else if (severity.includes('high')) summary.highVulnerabilities++;
        else if (severity.includes('medium')) summary.mediumVulnerabilities++;
        else if (severity.includes('low')) summary.lowVulnerabilities++;
        if (vulnerability['PLUGIN NAME']) summary.uniquePlugins.add(vulnerability['PLUGIN NAME']);
        if (vulnerability['IP ADDRESS']) summary.uniqueIPs.add(vulnerability['IP ADDRESS']);
        if (vulnerability.MISSION) summary.uniqueMissions.add(vulnerability.MISSION);
        if (vulnerability.ASSET_TYPE) summary.uniqueAssetTypes.add(vulnerability.ASSET_TYPE);
    }

    // Update mission analysis with vulnerability data
    function updateMissionAnalysis(analysis, vulnerability) {
        const mission = vulnerability.MISSION || 'Unknown';
        if (!analysis.has(mission)) {
            analysis.set(mission, { 
                totalVulnerabilities: 0, 
                criticalVulnerabilities: 0, 
                highVulnerabilities: 0,
                mediumVulnerabilities: 0,
                lowVulnerabilities: 0,
                uniqueIPs: new Set(),
                uniquePlugins: new Set()
            });
        }
        
        const missionData = analysis.get(mission);
        missionData.totalVulnerabilities++;
        
        const severity = (vulnerability.SEVERITY || '').toLowerCase();
        if (severity.includes('critical')) missionData.criticalVulnerabilities++;
        else if (severity.includes('high')) missionData.highVulnerabilities++;
        else if (severity.includes('medium')) missionData.mediumVulnerabilities++;
        else if (severity.includes('low')) missionData.lowVulnerabilities++;
        
        if (vulnerability['IP ADDRESS']) missionData.uniqueIPs.add(vulnerability['IP ADDRESS']);
        if (vulnerability['PLUGIN NAME']) missionData.uniquePlugins.add(vulnerability['PLUGIN NAME']);
    }

    // Update severity analysis with vulnerability data
    function updateSeverityAnalysis(analysis, vulnerability) {
        const severity = vulnerability.SEVERITY || 'Unknown';
        if (!analysis.has(severity)) {
            analysis.set(severity, 0);
        }
        analysis.set(severity, analysis.get(severity) + 1);
    }

    // Update plugin analysis with vulnerability data
    function updatePluginAnalysis(analysis, vulnerability) {
        const pluginName = vulnerability['PLUGIN NAME'] || 'Unknown';
        if (!analysis.has(pluginName)) {
            analysis.set(pluginName, { 
                count: 0, 
                severity: vulnerability.SEVERITY || 'Unknown',
                missions: new Set(),
                assetTypes: new Set(),
                ips: new Set()
            });
        }
        
        const pluginData = analysis.get(pluginName);
        pluginData.count++;
        
        if (vulnerability.MISSION) pluginData.missions.add(vulnerability.MISSION);
        if (vulnerability.ASSET_TYPE) pluginData.assetTypes.add(vulnerability.ASSET_TYPE);
        if (vulnerability['IP ADDRESS']) pluginData.ips.add(vulnerability['IP ADDRESS']);
    }

    // Update IP address analysis with vulnerability data
    function updateIPAnalysis(analysis, vulnerability) {
        const ipAddress = vulnerability['IP ADDRESS'] || 'Unknown';
        if (!analysis.has(ipAddress)) {
            analysis.set(ipAddress, { 
                count: 0, 
                criticalCount: 0, 
                highCount: 0,
                mediumCount: 0,
                lowCount: 0,
                plugins: new Set(),
                missions: new Set(),
                assetTypes: new Set()
            });
        }
        
        const ipData = analysis.get(ipAddress);
        ipData.count++;
        
        const severity = (vulnerability.SEVERITY || '').toLowerCase();
        if (severity.includes('critical')) ipData.criticalCount++;
        else if (severity.includes('high')) ipData.highCount++;
        else if (severity.includes('medium')) ipData.mediumCount++;
        else if (severity.includes('low')) ipData.lowCount++;
        
        if (vulnerability['PLUGIN NAME']) ipData.plugins.add(vulnerability['PLUGIN NAME']);
        if (vulnerability.MISSION) ipData.missions.add(vulnerability.MISSION);
        if (vulnerability.ASSET_TYPE) ipData.assetTypes.add(vulnerability.ASSET_TYPE);
    }

    // Update asset type analysis with vulnerability data
    function updateAssetTypeAnalysis(analysis, vulnerability) {
        const assetType = vulnerability.ASSET_TYPE || 'Unknown';
        if (!analysis.has(assetType)) {
            analysis.set(assetType, { 
                count: 0, 
                criticalCount: 0, 
                highCount: 0,
                mediumCount: 0,
                lowCount: 0,
                ips: new Set(),
                plugins: new Set()
            });
        }
        
        const assetTypeData = analysis.get(assetType);
        assetTypeData.count++;
        
        const severity = (vulnerability.SEVERITY || '').toLowerCase();
        if (severity.includes('critical')) assetTypeData.criticalCount++;
        else if (severity.includes('high')) assetTypeData.highCount++;
        else if (severity.includes('medium')) assetTypeData.mediumCount++;
        else if (severity.includes('low')) assetTypeData.lowCount++;
        
        if (vulnerability['IP ADDRESS']) assetTypeData.ips.add(vulnerability['IP ADDRESS']);
        if (vulnerability['PLUGIN NAME']) assetTypeData.plugins.add(vulnerability['PLUGIN NAME']);
    }

    // Update asset risk heatmap with vulnerability data
    function updateAssetRiskHeatmap(analysis, vulnerability) {
        const asset = vulnerability.ASSET || vulnerability['IP ADDRESS'] || 'Unknown';
        const mission = vulnerability.MISSION || 'Unknown';
        
        if (!analysis[mission]) {
            analysis[mission] = {};
        }
        
        if (!analysis[mission][asset]) {
            analysis[mission][asset] = {
                count: 0,
                criticalCount: 0,
                highCount: 0,
                mediumCount: 0,
                lowCount: 0,
                riskScore: 0
            };
        }
        
        analysis[mission][asset].count++;
        
        const severity = (vulnerability.SEVERITY || '').toLowerCase();
        if (severity.includes('critical')) analysis[mission][asset].criticalCount++;
        else if (severity.includes('high')) analysis[mission][asset].highCount++;
        else if (severity.includes('medium')) analysis[mission][asset].mediumCount++;
        else if (severity.includes('low')) analysis[mission][asset].lowCount++;
        
        analysis[mission][asset].riskScore += calculateVulnerabilityRiskScore(vulnerability);
    }

    // Calculate risk score for a vulnerability
    function calculateVulnerabilityRiskScore(vulnerability) {
        const severityWeights = {
            'Critical': 10,
            'High': 8,
            'Medium': 5,
            'Low': 2
        };
        
        const severity = vulnerability.SEVERITY || 'Low';
        let weight = 1;
        
        // Match severity regardless of case
        for (const [key, value] of Object.entries(severityWeights)) {
            if (severity.toLowerCase().includes(key.toLowerCase())) {
                weight = value;
                break;
            }
        }
        
        // Adjust weight based on additional factors if available
        if (vulnerability.EXPLOITABILITY) {
            const exploitability = parseFloat(vulnerability.EXPLOITABILITY);
            if (!isNaN(exploitability)) {
                weight *= (1 + (exploitability / 10));
            }
        }
        
        if (vulnerability.IMPACT) {
            const impact = parseFloat(vulnerability.IMPACT);
            if (!isNaN(impact)) {
                weight *= (1 + (impact / 10));
            }
        }
        
        return weight;
    }

    // Analyze differences between current and previous vulnerability data
    function analyzeDiff(currentChunk, previousChunks) {
        let diff = {
            new: [],
            persisting: [],
            remediated: []
        };

        // Function to create a unique key for a vulnerability
        const createVulnKey = (vuln) => `${vuln['PLUGIN NAME'] || ''}|${vuln['IP ADDRESS'] || ''}`;
        
        // Create a set of keys from the first previous chunk for faster lookup
        const prevVulnKeys = new Set();
        if (Array.isArray(previousChunks[0])) {
            previousChunks[0].forEach(prevVuln => {
                prevVulnKeys.add(createVulnKey(prevVuln));
            });
        }
        
        // Find new and persisting vulnerabilities
        currentChunk.forEach(currVuln => {
            const vulnKey = createVulnKey(currVuln);
            if (!prevVulnKeys.has(vulnKey)) {
                diff.new.push(currVuln);
            } else {
                diff.persisting.push(currVuln);
            }
        });
        
        // Find remediated vulnerabilities
        if (Array.isArray(previousChunks[0])) {
            // Create a set of keys from the current chunk for faster lookup
            const currVulnKeys = new Set();
            currentChunk.forEach(currVuln => {
                currVulnKeys.add(createVulnKey(currVuln));
            });
            
            previousChunks[0].forEach(prevVuln => {
                const vulnKey = createVulnKey(prevVuln);
                if (!currVulnKeys.has(vulnKey)) {
                    diff.remediated.push(prevVuln);
                }
            });
        }

        return diff;
    }

    // Merge chunk data into existing data
    function mergeChunkData(existingData, newData) {
        // Merge nested objects and arrays
        ['executiveSummary', 'missionAnalysis', 'severityAnalysis', 'pluginAnalysis', 'ipAnalysis', 'assetTypeAnalysis', 'assetRiskHeatmap', 'riskTrend'].forEach(key => {
            if (existingData[key] && newData[key]) {
                mergeNestedObject(existingData[key], newData[key]);
            }
        });

        // Merge arrays
        ['remediatedVulnerabilities', 'newVulnerabilities', 'aiInsights'].forEach(key => {
            if (existingData[key] && newData[key]) {
                existingData[key] = (existingData[key] || []).concat(newData[key] || []);
            }
        });

        // Merge diff analysis
        if (existingData.diffAnalysis && newData.diffAnalysis) {
            existingData.diffAnalysis.new = (existingData.diffAnalysis.new || []).concat(newData.diffAnalysis.new || []);
            existingData.diffAnalysis.persisting = (existingData.diffAnalysis.persisting || []).concat(newData.diffAnalysis.persisting || []);
            existingData.diffAnalysis.remediated = (existingData.diffAnalysis.remediated || []).concat(newData.diffAnalysis.remediated || []);
        }

        // Merge vulnerability aging
        if (existingData.vulnerabilityAging && newData.vulnerabilityAging) {
            existingData.vulnerabilityAging.new = (existingData.vulnerabilityAging.new || []).concat(newData.vulnerabilityAging.new || []);
            existingData.vulnerabilityAging.persisting = (existingData.vulnerabilityAging.persisting || []).concat(newData.vulnerabilityAging.persisting || []);
            existingData.vulnerabilityAging.remediated = (existingData.vulnerabilityAging.remediated || []).concat(newData.vulnerabilityAging.remediated || []);
        }

        return existingData;
    }

    // Merge nested objects recursively
    function mergeNestedObject(target, source) {
        if (!source || typeof source !== 'object') return target;
        
        // Handle special case for Map objects
        if (source instanceof Map) {
            if (!(target instanceof Map)) {
                target = new Map();
            }
            
            for (const [key, value] of source.entries()) {
                if (!target.has(key)) {
                    target.set(key, value);
                } else if (typeof value === 'object' && value !== null) {
                    // If the value is an object, merge it recursively
                    const existingValue = target.get(key);
                    if (typeof existingValue === 'object' && existingValue !== null) {
                        mergeNestedObject(existingValue, value);
                    } else {
                        target.set(key, value);
                    }
                } else if (typeof value === 'number') {
                    // If the value is a number, add it to the existing value
                    const existingValue = target.get(key);
                    if (typeof existingValue === 'number') {
                        target.set(key, existingValue + value);
                    } else {
                        target.set(key, value);
                    }
                } else {
                    target.set(key, value);
                }
            }
            
            return target;
        }
        
        // Handle regular objects
        Object.keys(source).forEach(key => {
            if (source[key] !== null && typeof source[key] === 'object') {
                if (!target[key]) {
                    if (Array.isArray(source[key])) {
                        target[key] = [...source[key]];
                    } else if (source[key] instanceof Set) {
                        target[key] = new Set([...source[key]]);
                    } else {
                        target[key] = {};
                    }
                }
                mergeNestedObject(target[key], source[key]);
            } else if (source[key] instanceof Set) {
                if (!target[key]) target[key] = new Set();
                for (const item of source[key]) {
                    target[key].add(item);
                }
            } else if (typeof source[key] === 'number') {
                if (!target[key]) target[key] = 0;
                target[key] += source[key];
            } else {
                target[key] = source[key];
            }
        });
        
        return target;
    }

    // Finalize processed data
    function finalizeProcessedData(data) {
        // Calculate comparisons between current and previous data
        data.comparison = data.executiveSummary.previous.map(previous =>
            compareData(data.executiveSummary.current, previous)
        );
        
        // Calculate enhanced risk scores
        calculateEnhancedRiskScores(data);
        
        // Calculate vulnerability aging metrics
        calculateVulnerabilityAging(data);
        
        // Calculate risk trend data
        calculateRiskTrend(data);
        
        return data;
    }

    // Calculate enhanced risk scores
    function calculateEnhancedRiskScores(data) {
        const current = data.executiveSummary.current;
        const previous = data.executiveSummary.previous[0];
        
        // Calculate current risk score
        current.riskScore = calculateEnhancedRiskScore(current);
        
        // Calculate previous risk score if available
        if (previous) {
            previous.riskScore = calculateEnhancedRiskScore(previous);
            current.riskScoreChange = {
                absolute: current.riskScore - previous.riskScore,
                percentage: ((current.riskScore - previous.riskScore) / previous.riskScore * 100).toFixed(2),
                improved: current.riskScore < previous.riskScore
            };
        } else {
            current.riskScoreChange = {
                absolute: 0,
                percentage: 0,
                improved: false
            };
        }
        
        // Calculate risk scores for missions
        for (const [mission, missionData] of data.missionAnalysis.current.entries()) {
            missionData.riskScore = calculateMissionRiskScore(missionData);
            
            if (data.missionAnalysis.previous[0] && data.missionAnalysis.previous[0].has(mission)) {
                const previousMissionData = data.missionAnalysis.previous[0].get(mission);
                const previousRiskScore = calculateMissionRiskScore(previousMissionData);
                missionData.riskScoreChange = {
                    absolute: missionData.riskScore - previousRiskScore,
                    percentage: ((missionData.riskScore - previousRiskScore) / previousRiskScore * 100).toFixed(2),
                    improved: missionData.riskScore < previousRiskScore
                };
            } else {
                missionData.riskScoreChange = {
                    absolute: missionData.riskScore,
                    percentage: 100,
                    improved: false
                };
            }
        }
    }

    // Calculate risk score for executive summary
    function calculateEnhancedRiskScore(summary) {
        // Calculate weighted severity score
        const severityWeights = {
            critical: 10,
            high: 8,
            medium: 5,
            low: 2
        };

        let weightedSum = 0;
        let totalVulnerabilities = summary.totalVulnerabilities || 1; // Avoid division by zero
        
        Object.keys(severityWeights).forEach(severity => {
            const count = summary[severity + 'Vulnerabilities'] || 0;
            weightedSum += count * severityWeights[severity];
        });
        
        // Calculate normalized factors
        const avgSeverityScore = weightedSum / totalVulnerabilities;
        const uniqueIPFactor = Math.log(summary.uniqueIPs.size + 1) / Math.log(100); // Normalize to 0-1 range
        const uniquePluginFactor = Math.log(summary.uniquePlugins.size + 1) / Math.log(1000); // Normalize to 0-1 range
        const criticalRatio = summary.criticalVulnerabilities / totalVulnerabilities;
        const highRatio = summary.highVulnerabilities / totalVulnerabilities;
        
        // Calculate risk score using a weighted formula
        const riskScore = (
            (avgSeverityScore * 0.4) + 
            (uniqueIPFactor * 0.2) + 
            (uniquePluginFactor * 0.1) + 
            (criticalRatio * 0.2) + 
            (highRatio * 0.1)
        ) * 10; // Scale to 0-100 range
        
        return parseFloat(riskScore.toFixed(2));
    }

    // Calculate risk score for a mission
    function calculateMissionRiskScore(missionData) {
        // Calculate weighted severity score
        const severityWeights = {
            criticalVulnerabilities: 10,
            highVulnerabilities: 8,
            mediumVulnerabilities: 5,
            lowVulnerabilities: 2
        };

        let weightedSum = 0;
        let totalVulnerabilities = missionData.totalVulnerabilities || 1; // Avoid division by zero
        
        Object.keys(severityWeights).forEach(severityKey => {
            const count = missionData[severityKey] || 0;
            weightedSum += count * severityWeights[severityKey];
        });
        
        // Calculate normalized factors
        const avgSeverityScore = weightedSum / totalVulnerabilities;
        const uniqueIPFactor = Math.log(missionData.uniqueIPs.size + 1) / Math.log(100); // Normalize to 0-1 range
        const uniquePluginFactor = Math.log(missionData.uniquePlugins.size + 1) / Math.log(1000); // Normalize to 0-1 range
        const criticalRatio = missionData.criticalVulnerabilities / totalVulnerabilities;
        const highRatio = missionData.highVulnerabilities / totalVulnerabilities;
        
        // Calculate risk score using a weighted formula
        const riskScore = (
            (avgSeverityScore * 0.4) + 
            (uniqueIPFactor * 0.2) + 
            (uniquePluginFactor * 0.1) + 
            (criticalRatio * 0.2) + 
            (highRatio * 0.1)
        ) * 10; // Scale to 0-100 range
        
        return parseFloat(riskScore.toFixed(2));
    }

    // Calculate vulnerability aging metrics
    function calculateVulnerabilityAging(data) {
        // Add more sophisticated aging analysis based on persistence
        if (data.diffAnalysis && data.diffAnalysis.persisting && data.diffAnalysis.persisting.length > 0) {
            // Calculate age distribution
            const ageCounts = {
                '0-30 days': 0,
                '31-60 days': 0,
                '61-90 days': 0,
                '91+ days': 0
            };
            
            // For real implementation, we'd use actual dates
            // Here we'll just simulate aging based on persistence
            data.diffAnalysis.persisting.forEach((vuln, index) => {
                // Simulate age based on index (for demonstration)
                const simulatedAge = Math.floor(Math.random() * 120);
                
                // Categorize by age
                if (simulatedAge <= 30) {
                    ageCounts['0-30 days']++;
                } else if (simulatedAge <= 60) {
                    ageCounts['31-60 days']++;
                } else if (simulatedAge <= 90) {
                    ageCounts['61-90 days']++;
                } else {
                    ageCounts['91+ days']++;
                }
                
                // Add age to vulnerability for later use
                vuln.simulatedAge = simulatedAge;
            });
            
            data.vulnerabilityAging.ageCounts = ageCounts;
            data.vulnerabilityAging.averageAge = data.diffAnalysis.persisting.reduce((sum, vuln) => sum + vuln.simulatedAge, 0) / 
                data.diffAnalysis.persisting.length;
        }
    }

    // Calculate risk trend data
    function calculateRiskTrend(data) {
        // Initialize risk trend data
        data.riskTrend = {
            overall: [],
            bySeverity: {
                Critical: [],
                High: [],
                Medium: [],
                Low: []
            }
        };
        
        // Add current data point
        data.riskTrend.overall.push({
            label: 'Current',
            value: data.executiveSummary.current.riskScore
        });
        
        // Add previous data points if available
        data.executiveSummary.previous.forEach((previous, index) => {
            data.riskTrend.overall.push({
                label: previousVulnerabilityData[index]?.label || `Previous ${index + 1}`,
                value: previous.riskScore
            });
        });
        
        // Add severity-specific data points
        ['Critical', 'High', 'Medium', 'Low'].forEach(severity => {
            // Current data point
            data.riskTrend.bySeverity[severity].push({
                label: 'Current',
                value: data.executiveSummary.current[severity.toLowerCase() + 'Vulnerabilities']
            });
            
            // Previous data points
            data.executiveSummary.previous.forEach((previous, index) => {
                data.riskTrend.bySeverity[severity].push({
                    label: previousVulnerabilityData[index]?.label || `Previous ${index + 1}`,
                    value: previous[severity.toLowerCase() + 'Vulnerabilities']
                });
            });
        });
    }

    // Enhance data with advanced analytics
    function enhanceDataWithAdvancedAnalytics(data) {
        // Apply statistical methods to identify outliers and patterns
        data = identifyOutliers(data);
        data = performCorrelationAnalysis(data);
        data = calculateRiskPredictions(data);
        data = generateRecommendations(data);
        
        return data;
    }

    // Identify outliers in the data
    function identifyOutliers(data) {
        data.outliers = {
            highRiskIPs: [],
            unusualPatterns: [],
            criticalAssets: []
        };
        
        // Identify high-risk IPs
        if (data.ipAnalysis && data.ipAnalysis.current) {
            const ipRiskScores = [];
            
            for (const [ip, ipData] of data.ipAnalysis.current.entries()) {
                const riskScore = (ipData.criticalCount * 10 + ipData.highCount * 8 + ipData.mediumCount * 5 + ipData.lowCount * 2) / ipData.count;
                ipRiskScores.push({ ip, riskScore });
            }
            
            // Sort by risk score descending
            ipRiskScores.sort((a, b) => b.riskScore - a.riskScore);
            
            // Top 10% of high-risk IPs
            const topN = Math.max(1, Math.ceil(ipRiskScores.length * 0.1));
            data.outliers.highRiskIPs = ipRiskScores.slice(0, topN);
        }
        
        // Identify critical assets
        if (data.assetRiskHeatmap && data.assetRiskHeatmap.current) {
            const assetRiskScores = [];
            
            for (const mission in data.assetRiskHeatmap.current) {
                for (const asset in data.assetRiskHeatmap.current[mission]) {
                    const assetData = data.assetRiskHeatmap.current[mission][asset];
                    assetRiskScores.push({
                        mission,
                        asset,
                        riskScore: assetData.riskScore,
                        vulnerabilityCount: assetData.count
                    });
                }
            }
            
            // Sort by risk score descending
            assetRiskScores.sort((a, b) => b.riskScore - a.riskScore);
            
            // Top 10% of high-risk assets
            const topN = Math.max(1, Math.ceil(assetRiskScores.length * 0.1));
            data.outliers.criticalAssets = assetRiskScores.slice(0, topN);
        }
        
        return data;
    }

    // Perform correlation analysis
    function performCorrelationAnalysis(data) {
        data.correlations = {
            missionRiskFactors: [],
            vulnerabilityPatterns: []
        };
        
        // Analyze mission risk factors
        if (data.missionAnalysis && data.missionAnalysis.current) {
            for (const [mission, missionData] of data.missionAnalysis.current.entries()) {
                // Calculate risk density (vulnerabilities per IP)
                const riskDensity = missionData.totalVulnerabilities / (missionData.uniqueIPs.size || 1);
                
                // Calculate percentage of critical and high vulnerabilities
                const criticalHighPercentage = (missionData.criticalVulnerabilities + missionData.highVulnerabilities) / 
                    (missionData.totalVulnerabilities || 1) * 100;
                
                data.correlations.missionRiskFactors.push({
                    mission,
                    riskDensity: parseFloat(riskDensity.toFixed(2)),
                    criticalHighPercentage: parseFloat(criticalHighPercentage.toFixed(2)),
                    uniqueIPs: missionData.uniqueIPs.size,
                    uniquePlugins: missionData.uniquePlugins.size
                });
            }
            
            // Sort by risk density descending
            data.correlations.missionRiskFactors.sort((a, b) => b.riskDensity - a.riskDensity);
        }
        
        // Analyze vulnerability patterns
        if (data.pluginAnalysis && data.pluginAnalysis.current) {
            const pluginClusters = {};
            
            for (const [plugin, pluginData] of data.pluginAnalysis.current.entries()) {
                // Extract category/type from plugin name if possible
                const category = extractPluginCategory(plugin);
                
                if (!pluginClusters[category]) {
                    pluginClusters[category] = {
                        count: 0,
                        criticalCount: 0,
                        highCount: 0,
                        plugins: []
                    };
                }
                
                pluginClusters[category].count += pluginData.count;
                
                if (pluginData.severity.toLowerCase().includes('critical')) {
                    pluginClusters[category].criticalCount += pluginData.count;
                } else if (pluginData.severity.toLowerCase().includes('high')) {
                    pluginClusters[category].highCount += pluginData.count;
                }
                
                pluginClusters[category].plugins.push({
                    name: plugin,
                    count: pluginData.count,
                    severity: pluginData.severity
                });
            }
            
            // Convert to array for easier manipulation
            const clusterArray = Object.entries(pluginClusters).map(([category, data]) => ({
                category,
                ...data
            }));
            
            // Sort by count descending
            clusterArray.sort((a, b) => b.count - a.count);
            
            data.correlations.vulnerabilityPatterns = clusterArray;
        }
        
        return data;
    }

    // Extract plugin category from name
    function extractPluginCategory(pluginName) {
        if (!pluginName) return 'Unknown';
        
        // Common categories to look for in plugin names
        const categories = [
            'SSL', 'TLS', 'Encryption', 'Certificate',
            'Password', 'Authentication', 'Authorization', 'Credentials',
            'XSS', 'SQLi', 'Injection', 'CSRF',
            'Buffer Overflow', 'Memory',
            'Default', 'Hardcoded',
            'Outdated', 'Version', 'EOL', 'End of Life',
            'Configuration', 'Setting',
            'Unpatched', 'Patch', 'Update',
            'DoS', 'Denial of Service',
            'Firewall', 'Network',
            'Service', 'Port',
            'Web', 'HTTP', 'HTTPS',
            'Software', 'Application',
            'Windows', 'Linux', 'Unix',
            'Ransomware', 'Malware', 'Virus'
        ];
        
        for (const category of categories) {
            if (pluginName.toLowerCase().includes(category.toLowerCase())) {
                return category;
            }
        }
        
        // If no category is found, return the first part of the plugin name
        return pluginName.split(' ')[0] || 'Other';
    }

    // Calculate risk predictions
    function calculateRiskPredictions(data) {
        data.predictions = {
            nextScan: {
                total: 0,
                critical: 0,
                high: 0,
                medium: 0,
                low: 0,
                riskScore: 0,
                confidence: 0
            },
            timeToRemediate: {
                critical: 0,
                high: 0,
                medium: 0,
                low: 0
            },
            riskTrend: 'stable',
            vulnerabilityGrowth: 0
        };
        
        // Simple linear regression for prediction
        if (data.executiveSummary.previous.length > 0) {
            const current = data.executiveSummary.current;
            const previous = data.executiveSummary.previous[0];
            
            // Calculate change rates
            const totalChangeRate = (current.totalVulnerabilities - previous.totalVulnerabilities) / (previous.totalVulnerabilities || 1);
            const criticalChangeRate = (current.criticalVulnerabilities - previous.criticalVulnerabilities) / (previous.criticalVulnerabilities || 1);
            const highChangeRate = (current.highVulnerabilities - previous.highVulnerabilities) / (previous.highVulnerabilities || 1);
            const mediumChangeRate = (current.mediumVulnerabilities - previous.mediumVulnerabilities) / (previous.mediumVulnerabilities || 1);
            const lowChangeRate = (current.lowVulnerabilities - previous.lowVulnerabilities) / (previous.lowVulnerabilities || 1);
            
            // Predict next scan values
            data.predictions.nextScan.total = Math.max(0, Math.round(current.totalVulnerabilities * (1 + totalChangeRate)));
            data.predictions.nextScan.critical = Math.max(0, Math.round(current.criticalVulnerabilities * (1 + criticalChangeRate)));
            data.predictions.nextScan.high = Math.max(0, Math.round(current.highVulnerabilities * (1 + highChangeRate)));
            data.predictions.nextScan.medium = Math.max(0, Math.round(current.mediumVulnerabilities * (1 + mediumChangeRate)));
            data.predictions.nextScan.low = Math.max(0, Math.round(current.lowVulnerabilities * (1 + lowChangeRate)));
            
            // Calculate predicted risk score
            const predictedSummary = {
                totalVulnerabilities: data.predictions.nextScan.total,
                criticalVulnerabilities: data.predictions.nextScan.critical,
                highVulnerabilities: data.predictions.nextScan.high,
                mediumVulnerabilities: data.predictions.nextScan.medium,
                lowVulnerabilities: data.predictions.nextScan.low,
                uniquePlugins: new Set([...current.uniquePlugins]),
                uniqueIPs: new Set([...current.uniqueIPs])
            };
            
            data.predictions.nextScan.riskScore = calculateEnhancedRiskScore(predictedSummary);
            
            // Determine confidence based on data quality
            data.predictions.nextScan.confidence = calculatePredictionConfidence(data);
            
            // Determine overall risk trend
            const riskScoreChange = data.predictions.nextScan.riskScore - current.riskScore;
            if (riskScoreChange > 1) {
                data.predictions.riskTrend = 'increasing';
            } else if (riskScoreChange < -1) {
                data.predictions.riskTrend = 'decreasing';
            } else {
                data.predictions.riskTrend = 'stable';
            }
            
            // Calculate vulnerability growth rate
            data.predictions.vulnerabilityGrowth = parseFloat(totalChangeRate.toFixed(4));
        } else {
            // Without previous data, use current data as prediction
            const current = data.executiveSummary.current;
            
            data.predictions.nextScan.total = current.totalVulnerabilities;
            data.predictions.nextScan.critical = current.criticalVulnerabilities;
            data.predictions.nextScan.high = current.highVulnerabilities;
            data.predictions.nextScan.medium = current.mediumVulnerabilities;
            data.predictions.nextScan.low = current.lowVulnerabilities;
            data.predictions.nextScan.riskScore = current.riskScore;
            data.predictions.nextScan.confidence = 0.5; // Medium confidence without history
            data.predictions.riskTrend = 'stable';
        }
        
        // Estimate time to remediate
        const remediationRates = {
            critical: 10, // days per vulnerability
            high: 20,
            medium: 45,
            low: 90
        };
        
        data.predictions.timeToRemediate.critical = Math.ceil(data.executiveSummary.current.criticalVulnerabilities * remediationRates.critical / 5); // Assuming 5 vulnerabilities per day
        data.predictions.timeToRemediate.high = Math.ceil(data.executiveSummary.current.highVulnerabilities * remediationRates.high / 8);
        data.predictions.timeToRemediate.medium = Math.ceil(data.executiveSummary.current.mediumVulnerabilities * remediationRates.medium / 15);
        data.predictions.timeToRemediate.low = Math.ceil(data.executiveSummary.current.lowVulnerabilities * remediationRates.low / 20);
        
        return data;
    }

    // Calculate prediction confidence
    function calculatePredictionConfidence(data) {
        // Factors that influence confidence:
        // 1. Number of previous scans
        // 2. Consistency of vulnerability growth/reduction
        // 3. Data quality
        
        // Start with a base confidence
        let confidence = 0.5;
        
        // Adjust based on number of previous scans
        if (data.executiveSummary.previous.length > 2) {
            confidence += 0.2;
        } else if (data.executiveSummary.previous.length > 0) {
            confidence += 0.1;
        } else {
            confidence -= 0.1;
        }
        
        // Adjust based on consistency
        if (data.executiveSummary.previous.length > 0) {
            const current = data.executiveSummary.current;
            const previous = data.executiveSummary.previous[0];
            
            // Check if the growth/reduction is consistent across severity levels
            const totalChange = current.totalVulnerabilities - previous.totalVulnerabilities;
const criticalChange = current.criticalVulnerabilities - previous.criticalVulnerabilities;
            const highChange = current.highVulnerabilities - previous.highVulnerabilities;
            const mediumChange = current.mediumVulnerabilities - previous.mediumVulnerabilities;
            const lowChange = current.lowVulnerabilities - previous.lowVulnerabilities;
            
            // Check if changes are consistent in direction
            const changes = [criticalChange, highChange, mediumChange, lowChange];
            const positiveChanges = changes.filter(c => c > 0).length;
            const negativeChanges = changes.filter(c => c < 0).length;
            
            if (positiveChanges >= 3 || negativeChanges >= 3) {
                // Most severity levels are changing in the same direction
                confidence += 0.1;
            } else {
                // Changes are inconsistent
                confidence -= 0.05;
            }
        }
        
        // Adjust based on data quality
        const missingDataPercentage = calculateMissingDataPercentage(data);
        if (missingDataPercentage < 5) {
            confidence += 0.1;
        } else if (missingDataPercentage > 20) {
            confidence -= 0.2;
        }
        
        // Ensure confidence is between 0 and 1
        return Math.max(0, Math.min(1, confidence));
    }

    // Calculate percentage of missing data
    function calculateMissingDataPercentage(data) {
        let missingFields = 0;
        let totalFields = 0;
        
        // Check required fields in current vulnerabilities
        currentVulnerabilityData.forEach(vuln => {
            totalFields += 5; // IP ADDRESS, PLUGIN NAME, SEVERITY, MISSION, ASSET_TYPE
            if (!vuln['IP ADDRESS']) missingFields++;
            if (!vuln['PLUGIN NAME']) missingFields++;
            if (!vuln['SEVERITY']) missingFields++;
            if (!vuln['MISSION']) missingFields++;
            if (!vuln['ASSET_TYPE']) missingFields++;
        });
        
        return (missingFields / totalFields) * 100;
    }

    // Generate recommendations
    function generateRecommendations(data) {
        data.recommendations = {
            critical: [],
            high: [],
            medium: [],
            general: []
        };
        
        // Critical recommendations for high-risk issues
        if (data.executiveSummary.current.criticalVulnerabilities > 0) {
            data.recommendations.critical.push({
                title: "Address Critical Vulnerabilities",
                description: `Prioritize remediation of ${data.executiveSummary.current.criticalVulnerabilities} critical vulnerabilities.`,
                impact: "High",
                effort: "High",
                roi: "High"
            });
            
            // Add specific recommendations for top critical plugins
            const topCriticalPlugins = Array.from(data.pluginAnalysis.current.entries())
                .filter(([_, pluginData]) => pluginData.severity.toLowerCase().includes('critical'))
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 3);
            
            topCriticalPlugins.forEach(([plugin, pluginData]) => {
                data.recommendations.critical.push({
                    title: `Remediate "${plugin}" Vulnerability`,
                    description: `Address ${pluginData.count} instances of this critical vulnerability affecting ${pluginData.ips.size} systems.`,
                    impact: "High",
                    effort: "Medium",
                    roi: "High"
                });
            });
        }
        
        // High recommendations for improving security posture
        if (data.executiveSummary.current.highVulnerabilities > 0) {
            data.recommendations.high.push({
                title: "High Severity Vulnerability Reduction",
                description: `Plan remediation for ${data.executiveSummary.current.highVulnerabilities} high severity vulnerabilities.`,
                impact: "Medium",
                effort: "Medium",
                roi: "High"
            });
        }
        
        // Add recommendations based on vulnerability patterns
        if (data.correlations && data.correlations.vulnerabilityPatterns) {
            const topCategories = data.correlations.vulnerabilityPatterns.slice(0, 3);
            
            topCategories.forEach(category => {
                const criticalHighCount = category.criticalCount + category.highCount;
                
                if (criticalHighCount > 0) {
                    data.recommendations.high.push({
                        title: `${category.category} Vulnerability Mitigation`,
                        description: `Implement systematic fixes for ${criticalHighCount} critical/high ${category.category}-related vulnerabilities.`,
                        impact: "Medium",
                        effort: "Medium",
                        roi: "High"
                    });
                }
            });
        }
        
        // Medium recommendations for improving overall security
        if (data.executiveSummary.current.mediumVulnerabilities > 0) {
            data.recommendations.medium.push({
                title: "Medium Vulnerability Reduction",
                description: `Create a plan to address ${data.executiveSummary.current.mediumVulnerabilities} medium severity vulnerabilities.`,
                impact: "Medium",
                effort: "Medium",
                roi: "Medium"
            });
        }
        
        // General recommendations
        data.recommendations.general.push({
            title: "Regular Vulnerability Scanning",
            description: "Implement bi-weekly vulnerability scanning to detect new issues early.",
            impact: "Medium",
            effort: "Low",
            roi: "High"
        });
        
        data.recommendations.general.push({
            title: "Security Awareness Training",
            description: "Conduct security awareness training for staff to reduce human-factor vulnerabilities.",
            impact: "Medium",
            effort: "Medium",
            roi: "Medium"
        });
        
        data.recommendations.general.push({
            title: "Vulnerability Management Process",
            description: "Establish a formal vulnerability management process with defined SLAs for different severity levels.",
            impact: "High",
            effort: "Medium",
            roi: "High"
        });
        
        return data;
    }

    // Generate AI insights
    function generateAIInsights(data) {
        const insights = [];
        
        // Overall risk insight
        insights.push({
            type: "risk",
            title: "Overall Risk Assessment",
            description: generateOverallRiskInsight(data),
            confidence: 0.9
        });
        
        // Critical vulnerability insight
        if (data.executiveSummary.current.criticalVulnerabilities > 0) {
            insights.push({
                type: "critical",
                title: "Critical Vulnerability Analysis",
                description: generateCriticalVulnerabilityInsight(data),
                confidence: 0.85
            });
        }
        
        // Trend insight
        if (data.executiveSummary.previous.length > 0) {
            insights.push({
                type: "trend",
                title: "Security Posture Trend",
                description: generateTrendInsight(data),
                confidence: 0.8
            });
        }
        
        // Remediation effectiveness insight
        if (data.diffAnalysis.remediated.length > 0) {
            insights.push({
                type: "remediation",
                title: "Remediation Effectiveness",
                description: generateRemediationInsight(data),
                confidence: 0.75
            });
        }
        
        // New vulnerabilities insight
        if (data.diffAnalysis.new.length > 0) {
            insights.push({
                type: "new",
                title: "New Vulnerability Assessment",
                description: generateNewVulnerabilityInsight(data),
                confidence: 0.8
            });
        }
        
        // Mission-specific insight
        if (data.missionAnalysis.current.size > 0) {
            insights.push({
                type: "mission",
                title: "Mission Impact Analysis",
                description: generateMissionInsight(data),
                confidence: 0.7
            });
        }
        
        // Predictive insight
        insights.push({
            type: "predictive",
            title: "Future Risk Projection",
            description: generatePredictiveInsight(data),
            confidence: data.predictions.nextScan.confidence
        });
        
        return insights;
    }

    // Generate overall risk insight
    function generateOverallRiskInsight(data) {
        const current = data.executiveSummary.current;
        const riskScore = current.riskScore;
        let riskCategory, riskDescription;
        
        if (riskScore >= 75) {
            riskCategory = "critical";
            riskDescription = "critical requiring immediate executive attention";
        } else if (riskScore >= 50) {
            riskCategory = "high";
            riskDescription = "high requiring prompt action";
        } else if (riskScore >= 25) {
            riskCategory = "moderate";
            riskDescription = "moderate requiring planned remediation";
        } else {
            riskCategory = "low";
            riskDescription = "relatively low compared to industry standards";
        }
        
        const criticalHighPercentage = ((current.criticalVulnerabilities + current.highVulnerabilities) / 
            (current.totalVulnerabilities || 1) * 100).toFixed(1);
        
        return `The organization's cybersecurity risk score is ${riskScore.toFixed(1)}, indicating ${riskDescription}. ` +
            `There are ${current.totalVulnerabilities} total vulnerabilities across ${current.uniqueIPs.size} unique systems. ` +
            `${criticalHighPercentage}% of vulnerabilities are critical or high severity, which significantly contributes to the overall risk. ` +
            `The most affected systems should be prioritized for immediate remediation to reduce organizational risk exposure.`;
    }

    // Generate critical vulnerability insight
    function generateCriticalVulnerabilityInsight(data) {
        const criticalCount = data.executiveSummary.current.criticalVulnerabilities;
        
        // Get top critical plugins
        const topCriticalPlugins = Array.from(data.pluginAnalysis.current.entries())
            .filter(([_, pluginData]) => pluginData.severity.toLowerCase().includes('critical'))
            .sort((a, b) => b[1].count - a[1].count)
            .slice(0, 3);
        
        let pluginInsight = "";
        if (topCriticalPlugins.length > 0) {
            pluginInsight = "The most prevalent critical issues are: ";
            topCriticalPlugins.forEach(([plugin, pluginData], index) => {
                pluginInsight += `"${plugin}" (${pluginData.count} instances)${index < topCriticalPlugins.length - 1 ? ", " : "."}`;
            });
        }
        
        // Get top missions affected by critical vulnerabilities
        const missionsWithCritical = [];
        for (const [mission, missionData] of data.missionAnalysis.current.entries()) {
            if (missionData.criticalVulnerabilities > 0) {
                missionsWithCritical.push({
                    mission,
                    count: missionData.criticalVulnerabilities
                });
            }
        }
        
        missionsWithCritical.sort((a, b) => b.count - a.count);
        
        let missionInsight = "";
        if (missionsWithCritical.length > 0) {
            missionInsight = `The most impacted business unit is ${missionsWithCritical[0].mission} with ${missionsWithCritical[0].count} critical vulnerabilities.`;
        }
        
        return `There are ${criticalCount} critical vulnerabilities that pose an immediate risk to the organization. ` +
            pluginInsight + " " + missionInsight + 
            ` Critical vulnerabilities often indicate potential for unauthorized access, data breaches, or service disruption. ` +
            `Immediate remediation of these issues should be prioritized to protect sensitive data and maintain operational continuity.`;
    }

    // Generate trend insight
    function generateTrendInsight(data) {
        const current = data.executiveSummary.current;
        const previous = data.executiveSummary.previous[0];
        const comparison = data.comparison[0];
        
        const totalChange = comparison.totalVulnerabilities;
        const criticalChange = comparison.criticalVulnerabilities;
        const riskScoreChange = current.riskScoreChange;
        
        let trendDescription, recommendation;
        
        if (totalChange.absolute < 0 && criticalChange.absolute < 0) {
            trendDescription = `overall positive, with a reduction of ${Math.abs(totalChange.absolute)} total vulnerabilities (${Math.abs(totalChange.percentage)}%) and ${Math.abs(criticalChange.absolute)} critical vulnerabilities (${Math.abs(criticalChange.percentage)}%)`;
            recommendation = "Continue current remediation strategies while focusing on remaining high-risk issues.";
        } else if (totalChange.absolute > 0 && criticalChange.absolute > 0) {
            trendDescription = `concerning, with an increase of ${totalChange.absolute} total vulnerabilities (${totalChange.percentage}%) and ${criticalChange.absolute} critical vulnerabilities (${criticalChange.percentage}%)`;
            recommendation = "Urgent action is needed to address the growing security risk. Prioritize critical and high severity vulnerabilities.";
        } else if (totalChange.absolute > 0 && criticalChange.absolute <= 0) {
            trendDescription = `mixed, with an increase of ${totalChange.absolute} total vulnerabilities (${totalChange.percentage}%) but a reduction of ${Math.abs(criticalChange.absolute)} critical vulnerabilities (${Math.abs(criticalChange.percentage)}%)`;
            recommendation = "Continue focusing on critical vulnerabilities while expanding remediation efforts to address the growing number of lower-severity issues.";
        } else {
            trendDescription = `mixed, with a reduction of ${Math.abs(totalChange.absolute)} total vulnerabilities (${Math.abs(totalChange.percentage)}%) but an increase of ${criticalChange.absolute} critical vulnerabilities (${criticalChange.percentage}%)`;
            recommendation = "Shift focus to the new critical vulnerabilities while maintaining the effective remediation of lower-severity issues.";
        }
        
        let riskScoreInsight = "";
        if (riskScoreChange) {
            riskScoreInsight = ` The overall risk score has ${riskScoreChange.improved ? 'decreased' : 'increased'} by ${Math.abs(riskScoreChange.absolute).toFixed(1)} points (${Math.abs(riskScoreChange.percentage)}%).`;
        }
        
        return `The security posture trend is ${trendDescription}.${riskScoreInsight} ${recommendation}`;
    }

    // Generate remediation insight
    function generateRemediationInsight(data) {
        const remediatedCount = data.diffAnalysis.remediated.length;
        const totalPrevious = data.executiveSummary.previous[0].totalVulnerabilities;
        const remediationRate = ((remediatedCount / totalPrevious) * 100).toFixed(1);
        
        // Count remediated vulnerabilities by severity
        const remediatedBySeverity = {
            Critical: 0,
            High: 0,
            Medium: 0,
            Low: 0
        };
        
        data.diffAnalysis.remediated.forEach(vuln => {
            const severity = vuln.SEVERITY || 'Unknown';
            if (remediatedBySeverity[severity] !== undefined) {
                remediatedBySeverity[severity]++;
            }
        });
        
        // Calculate weighted remediation score
        const weights = { Critical: 10, High: 7, Medium: 4, Low: 1 };
        let weightedScore = 0;
        let totalWeight = 0;
        
        for (const [severity, count] of Object.entries(remediatedBySeverity)) {
            if (weights[severity]) {
                weightedScore += count * weights[severity];
                totalWeight += count;
            }
        }
        
        const effectivenessScore = totalWeight > 0 ? (weightedScore / totalWeight).toFixed(1) : 0;
        
        let effectivenessRating;
        if (effectivenessScore >= 8) {
            effectivenessRating = "excellent";
        } else if (effectivenessScore >= 6) {
            effectivenessRating = "good";
        } else if (effectivenessScore >= 4) {
            effectivenessRating = "moderate";
        } else {
            effectivenessRating = "needs improvement";
        }
        
        return `Remediation effectiveness is ${effectivenessRating} with ${remediatedCount} vulnerabilities (${remediationRate}% of previous vulnerabilities) resolved. ` +
            `This includes ${remediatedBySeverity.Critical} critical, ${remediatedBySeverity.High} high, ${remediatedBySeverity.Medium} medium, and ${remediatedBySeverity.Low} low severity issues. ` +
            `${remediatedBySeverity.Critical > 0 ? `The remediation of ${remediatedBySeverity.Critical} critical vulnerabilities significantly reduces organizational risk. ` : ''}` +
            `${effectivenessScore >= 6 ? 'Continue the current remediation strategy with similar prioritization.' : 'Consider adjusting remediation priorities to focus more on critical and high-severity vulnerabilities.'}`;
    }

    // Generate new vulnerability insight
    function generateNewVulnerabilityInsight(data) {
        const newCount = data.diffAnalysis.new.length;
        
        // Count new vulnerabilities by severity
        const newBySeverity = {
            Critical: 0,
            High: 0,
            Medium: 0,
            Low: 0
        };
        
        data.diffAnalysis.new.forEach(vuln => {
            const severity = vuln.SEVERITY || 'Unknown';
            if (newBySeverity[severity] !== undefined) {
                newBySeverity[severity]++;
            }
        });
        
        // Analyze patterns in new vulnerabilities
        const newPlugins = new Set();
        const newIPs = new Set();
        data.diffAnalysis.new.forEach(vuln => {
            if (vuln['PLUGIN NAME']) newPlugins.add(vuln['PLUGIN NAME']);
            if (vuln['IP ADDRESS']) newIPs.add(vuln['IP ADDRESS']);
        });
        
        // Get top new plugins
        const pluginCounts = {};
        data.diffAnalysis.new.forEach(vuln => {
            const plugin = vuln['PLUGIN NAME'] || 'Unknown';
            pluginCounts[plugin] = (pluginCounts[plugin] || 0) + 1;
        });
        
        const topNewPlugins = Object.entries(pluginCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3);
        
        let pluginInsight = "";
        if (topNewPlugins.length > 0) {
            pluginInsight = "The most common new vulnerabilities are: ";
            topNewPlugins.forEach(([plugin, count], index) => {
                pluginInsight += `"${plugin}" (${count} instances)${index < topNewPlugins.length - 1 ? ", " : "."}`;
            });
        }
        
        let severity = "low";
        if (newBySeverity.Critical > 0) {
            severity = "critical";
        } else if (newBySeverity.High > 0) {
            severity = "high";
        } else if (newBySeverity.Medium > 0) {
            severity = "moderate";
        }
        
        return `${newCount} new vulnerabilities have been identified since the last scan, representing a ${severity} risk to the organization. ` +
            `This includes ${newBySeverity.Critical} critical, ${newBySeverity.High} high, ${newBySeverity.Medium} medium, and ${newBySeverity.Low} low severity issues. ` +
            `${newIPs.size} systems are affected by new vulnerabilities. ` +
            pluginInsight + 
            `${newBySeverity.Critical > 0 ? ' Immediate attention is required for the new critical vulnerabilities to prevent potential exploitation.' : ''}`;
    }

    // Generate mission insight
    function generateMissionInsight(data) {
        // Find most vulnerable mission
        let mostVulnerableMission = { name: 'Unknown', data: null, riskScore: 0 };
        
        for (const [mission, missionData] of data.missionAnalysis.current.entries()) {
            if (missionData.riskScore > mostVulnerableMission.riskScore) {
                mostVulnerableMission = {
                    name: mission,
                    data: missionData,
                    riskScore: missionData.riskScore
                };
            }
        }
        
        // Find mission with most critical vulnerabilities
        let missionWithMostCritical = { name: 'Unknown', count: 0 };
        
        for (const [mission, missionData] of data.missionAnalysis.current.entries()) {
            if (missionData.criticalVulnerabilities > missionWithMostCritical.count) {
                missionWithMostCritical = {
                    name: mission,
                    count: missionData.criticalVulnerabilities
                };
            }
        }
        
        // Find mission with largest improvement/degradation
        let mostImprovedMission = { name: 'Unknown', change: 0 };
        let mostDegradedMission = { name: 'Unknown', change: 0 };
        
        if (data.missionAnalysis.previous[0]) {
            for (const [mission, missionData] of data.missionAnalysis.current.entries()) {
                if (data.missionAnalysis.previous[0].has(mission)) {
                    const prevMissionData = data.missionAnalysis.previous[0].get(mission);
                    const change = prevMissionData.totalVulnerabilities - missionData.totalVulnerabilities;
                    
                    if (change > mostImprovedMission.change) {
                        mostImprovedMission = {
                            name: mission,
                            change: change
                        };
                    }
                    
                    if (change < mostDegradedMission.change) {
                        mostDegradedMission = {
                            name: mission,
                            change: Math.abs(change)
                        };
                    }
                }
            }
        }
        
        let insightText = `The most vulnerable business unit is ${mostVulnerableMission.name} with a risk score of ${mostVulnerableMission.riskScore.toFixed(1)} ` +
            `(${mostVulnerableMission.data.totalVulnerabilities} total vulnerabilities, including ${mostVulnerableMission.data.criticalVulnerabilities} critical and ${mostVulnerableMission.data.highVulnerabilities} high severity). `;
        
        if (missionWithMostCritical.name !== mostVulnerableMission.name) {
            insightText += `${missionWithMostCritical.name} has the highest number of critical vulnerabilities (${missionWithMostCritical.count}). `;
        }
        
        if (mostImprovedMission.change > 0) {
            insightText += `${mostImprovedMission.name} has shown the most improvement with ${mostImprovedMission.change} vulnerabilities remediated. `;
        }
        
        if (mostDegradedMission.change > 0) {
            insightText += `${mostDegradedMission.name} has experienced the largest security degradation with ${mostDegradedMission.change} new vulnerabilities. `;
        }
        
        insightText += `Prioritizing critical vulnerabilities in high-risk business units will provide the greatest risk reduction for the organization.`;
        
        return insightText;
    }

    // Generate predictive insight
    function generatePredictiveInsight(data) {
        const predictions = data.predictions;
        const current = data.executiveSummary.current;
        
        const nextTotal = predictions.nextScan.total;
        const nextCritical = predictions.nextScan.critical;
        const nextRiskScore = predictions.nextScan.riskScore;
        
        const totalChange = nextTotal - current.totalVulnerabilities;
        const criticalChange = nextCritical - current.criticalVulnerabilities;
        const riskScoreChange = nextRiskScore - current.riskScore;
        
        const confidence = (predictions.nextScan.confidence * 100).toFixed(0);
        
        let trendDescription;
        if (totalChange > 0 && criticalChange > 0) {
            trendDescription = "is projected to worsen";
        } else if (totalChange < 0 && criticalChange < 0) {
            trendDescription = "is projected to improve";
        } else {
            trendDescription = "is projected to remain relatively stable";
        }
        
        let criticalInsight = "";
        if (criticalChange !== 0) {
            criticalInsight = ` Critical vulnerabilities are expected to ${criticalChange > 0 ? 'increase' : 'decrease'} by ${Math.abs(criticalChange)}.`;
        }
        
        let riskScoreInsight = "";
        if (riskScoreChange !== 0) {
            riskScoreInsight = ` The risk score is projected to ${riskScoreChange > 0 ? 'increase' : 'decrease'} by ${Math.abs(riskScoreChange).toFixed(1)} points.`;
        }
        
        let recommendationInsight;
        if (predictions.riskTrend === 'increasing') {
            recommendationInsight = "Implementing more aggressive vulnerability management practices is recommended to address the projected increase in risk.";
        } else if (predictions.riskTrend === 'decreasing') {
            recommendationInsight = "Continue current remediation efforts to maintain the positive security trend.";
        } else {
            recommendationInsight = "Focus on critical and high vulnerabilities to improve the security posture.";
        }
        
        return `Based on trend analysis with ${confidence}% confidence, the security posture ${trendDescription} over the next 30 days. ` +
            `The total vulnerability count is expected to be ${nextTotal} (${totalChange > 0 ? '+' : ''}${totalChange}).${criticalInsight}${riskScoreInsight} ` +
            `${recommendationInsight}`;
    }

    // Populate filter dropdowns
    function populateFilterDropdowns() {
        const missionFilter = document.getElementById('missionFilter');
        const assetTypeFilter = document.getElementById('assetTypeFilter');

        // Clear existing options
        missionFilter.innerHTML = '<option value="">All Missions</option>';
        assetTypeFilter.innerHTML = '<option value="">All Asset Types</option>';

        // Get unique missions
        const missions = new Set();
        currentVulnerabilityData.forEach(vuln => {
            if (vuln.MISSION) missions.add(vuln.MISSION);
        });

        // Get unique asset types
        const assetTypes = new Set();
        currentVulnerabilityData.forEach(vuln => {
            if (vuln.ASSET_TYPE) assetTypes.add(vuln.ASSET_TYPE);
        });

        // Populate mission filter
        missions.forEach(mission => {
            const option = document.createElement('option');
            option.value = mission;
            option.textContent = mission;
            missionFilter.appendChild(option);
        });

        // Populate asset type filter
        assetTypes.forEach(assetType => {
            const option = document.createElement('option');
            option.value = assetType;
            option.textContent = assetType;
            assetTypeFilter.appendChild(option);
        });
    }

    // Apply filters
    function applyFilters() {
        const severityFilter = document.getElementById('severityFilter').value;
        const missionFilter = document.getElementById('missionFilter').value;
        const ipRangeFilter = document.getElementById('ipRangeFilter').value;
        const assetTypeFilter = document.getElementById('assetTypeFilter').value;

        filteredData = applyEnhancedFilters(currentVulnerabilityData, {
            severity: severityFilter,
            mission: missionFilter,
            ipRange: ipRangeFilter,
            assetType: assetTypeFilter
        });

        showLoader("Processing filtered data...");
        
        setTimeout(() => {
            processedData = processData(filteredData, previousVulnerabilityData.map(pv => pv.data));
            renderDashboard(processedData);
            hideLoader();
        }, 100);
    }

    // Apply enhanced filters
    function applyEnhancedFilters(data, filters) {
        return data.filter(item => {
            // Basic filtering
            const severityMatch = !filters.severity || (item.SEVERITY && item.SEVERITY.toLowerCase() === filters.severity.toLowerCase());
            const missionMatch = !filters.mission || (item.MISSION && item.MISSION === filters.mission);
            const assetTypeMatch = !filters.assetType || (item.ASSET_TYPE && item.ASSET_TYPE === filters.assetType);
            
            // IP range filtering with CIDR support
            const ipMatch = !filters.ipRange || isIpInRange(item['IP ADDRESS'], filters.ipRange);
            
            return severityMatch && missionMatch && ipMatch && assetTypeMatch;
        });
    }

    // Check if IP is in range (with CIDR support)
    function isIpInRange(ip, range) {
        if (!ip || !range) return false;
        
        // Simple case: exact match or prefix match
        if (ip === range || ip.startsWith(range)) return true;
        
        // CIDR notation check
        if (range.includes('/')) {
            try {
                const [rangeIp, cidrStr] = range.split('/');
                const cidr = parseInt(cidrStr, 10);
                
                if (isNaN(cidr) || cidr < 0 || cidr > 32) return false;
                
                const ipParts = ip.split('.').map(part => parseInt(part, 10));
                const rangeIpParts = rangeIp.split('.').map(part => parseInt(part, 10));
                
                if (ipParts.length !== 4 || rangeIpParts.length !== 4) return false;
                
                // Convert IP addresses to 32-bit integers
                const ipInt = (ipParts[0] << 24) | (ipParts[1] << 16) | (ipParts[2] << 8) | ipParts[3];
                const rangeIpInt = (rangeIpParts[0] << 24) | (rangeIpParts[1] << 16) | (rangeIpParts[2] << 8) | rangeIpParts[3];
                
                // Create mask from CIDR
                const mask = ~((1 << (32 - cidr)) - 1);
                
                // Check if IP is in range
                return (ipInt & mask) === (rangeIpInt & mask);
            } catch (e) {
                console.error('Error parsing CIDR:', e);
                return false;
            }
        }
        
        return false;
    }

    // Show loader with custom message
    function showLoader(message) {
        const loader = document.getElementById('loader');
        const processingStatus = document.getElementById('processingStatus');
        if (loader && processingStatus) {
            processingStatus.textContent = message;
            loader.style.display = 'flex';
        } else {
            console.error('Loader elements not found in the DOM');
        }
    }

    // Hide loader
    function hideLoader() {
        const loader = document.getElementById('loader');
        if (loader) {
            loader.style.display = 'none';
        } else {
            console.error('Loader element not found in the DOM');
        }
    }

    // Render dashboard
    function renderDashboard(data) {
        requestAnimationFrame(() => {
            // Clear any existing charts
            Object.keys(modalCharts).forEach(chartId => {
                if (modalCharts[chartId]) {
                    modalCharts[chartId].destroy();
                    delete modalCharts[chartId];
                }
            });
            
            // Render based on view type
            if (currentViewType === 'executive') {
                renderExecutiveView(data);
            } else if (currentViewType === 'technical') {
                renderTechnicalView(data);
            } else {
                renderStandardView(data);
            }
            
            // Show all dashboard sections
            document.querySelectorAll('.hidden').forEach(el => {
                if (!el.id.includes('modalOverlay') && !el.id.includes('loader') && !el.id.includes('uploadSections')) {
                    el.classList.remove('hidden');
                }
            });
        });
    }

    // Render executive view - focused on high-level metrics and insights
    function renderExecutiveView(data) {
        renderRiskScoreOverview(data);
        renderExecutiveSummary(data);
        renderAIInsights(data.aiInsights);
        renderOverallSummary(data.executiveSummary, data.comparison);
        renderComparisons(data);
        renderMissionAnalysis(data.missionAnalysis);
        renderPredictiveAnalysis(data);
        renderRecommendedActions(data.recommendations);
        
        // Hide technical sections
        document.getElementById('severityAnalysis').classList.add('hidden');
        document.getElementById('pluginAnalysis').classList.add('hidden');
        document.getElementById('ipAnalysis').classList.add('hidden');
        document.getElementById('remediatedVulnerabilities').classList.add('hidden');
        document.getElementById('newVulnerabilities').classList.add('hidden');
        document.getElementById('assetRiskHeatmap').classList.add('hidden');
        document.getElementById('vulnerabilityAging').classList.add('hidden');
    }

    // Render technical view - focused on detailed technical information
    function renderTechnicalView(data) {
        renderExecutiveSummary(data);
        renderSeverityAnalysis(data.severityAnalysis);
        renderPluginAnalysis(data.pluginAnalysis);
        renderIPAnalysis(data.ipAnalysis);
        renderRemediatedVulnerabilities(data.diffAnalysis.remediated);
        renderNewVulnerabilities(data.diffAnalysis.new);
        renderAssetRiskHeatmap(data.assetRiskHeatmap);
        renderVulnerabilityAging(data.vulnerabilityAging);
        
        // Hide executive sections
        document.getElementById('riskScoreOverview').classList.add('hidden');
        document.getElementById('aiInsights').classList.add('hidden');
        document.getElementById('overallSummary').classList.add('hidden');
        document.getElementById('comparisons').classList.add('hidden');
        document.getElementById('missionAnalysis').classList.add('hidden');
        document.getElementById('predictiveAnalysis').classList.add('hidden');
        document.getElementById('recommendedActions').classList.add('hidden');
    }

    // Render standard view - balanced between executive and technical
    function renderStandardView(data) {
        renderRiskScoreOverview(data);
        renderExecutiveSummary(data);
        renderAIInsights(data.aiInsights);
        renderOverallSummary(data.executiveSummary, data.comparison);
        renderComparisons(data);
        renderMissionAnalysis(data.missionAnalysis);
        renderSeverityAnalysis(data.severityAnalysis);
        renderPluginAnalysis(data.pluginAnalysis);
        renderIPAnalysis(data.ipAnalysis);
        renderRemediatedVulnerabilities(data.diffAnalysis.remediated);
        renderNewVulnerabilities(data.diffAnalysis.new);
        renderAssetRiskHeatmap(data.assetRiskHeatmap);
        renderPredictiveAnalysis(data);
        renderRecommendedActions(data.recommendations);
    }

    // Render risk score overview
    function renderRiskScoreOverview(data) {
        const riskScoreOverview = document.getElementById('riskScoreOverview');
        const current = data.executiveSummary.current;
        const riskScore = current.riskScore;
        const riskScoreChange = current.riskScoreChange;
        
        let riskLevel, riskClass;
        if (riskScore >= 75) {
            riskLevel = "Critical";
            riskClass = "text-critical";
        } else if (riskScore >= 50) {
            riskLevel = "High";
            riskClass = "text-high";
        } else if (riskScore >= 25) {
            riskLevel = "Medium";
            riskClass = "text-medium";
        } else {
            riskLevel = "Low";
            riskClass = "text-low";
        }
        
        let changeHtml = '';
        if (riskScoreChange) {
            const changeIcon = riskScoreChange.improved ? '<i class="fas fa-arrow-down text-low"></i>' : '<i class="fas fa-arrow-up text-critical"></i>';
            changeHtml = `
                <div class="text-xl mt-2">
                    ${changeIcon} ${Math.abs(riskScoreChange.absolute).toFixed(1)} (${Math.abs(riskScoreChange.percentage)}%)
                </div>
            `;
        }
        
        riskScoreOverview.innerHTML = `
            <div class="p-6">
                <h2 class="text-2xl font-bold mb-4">Cybersecurity Risk Score</h2>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div class="bg-white p-6 rounded-lg shadow-md text-center">
                        <h3 class="text-lg font-semibold mb-2">Overall Risk Score</h3>
                        <div class="text-5xl font-bold ${riskClass}">${riskScore.toFixed(1)}</div>
                        <div class="text-lg font-medium mt-2 ${riskClass}">${riskLevel} Risk</div>
                        ${changeHtml}
                    </div>
                    <div class="col-span-2">
                        <div class="bg-white p-6 rounded-lg shadow-md h-full">
                            <h3 class="text-lg font-semibold mb-4">Risk Score Components</h3>
                            ${renderRiskScoreComponents(data)}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    // Render risk score components
    function renderRiskScoreComponents(data) {
        const current = data.executiveSummary.current;
        
        // Calculate component scores
        const severityScore = (current.criticalVulnerabilities * 10 + current.highVulnerabilities * 8 + 
                             current.mediumVulnerabilities * 5 + current.lowVulnerabilities * 2) / 
                             (current.totalVulnerabilities || 1);
        
        const exposureScore = Math.min(10, Math.log(current.uniqueIPs.size + 1) / Math.log(10) * 10);
        
        const criticalRatio = current.criticalVulnerabilities / (current.totalVulnerabilities || 1);
        const criticality = criticalRatio * 10;
        
        const components = [
            { name: "Severity Distribution", score: severityScore.toFixed(1), percentage: ((severityScore / 10) * 100).toFixed(0) },
            { name: "System Exposure", score: exposureScore.toFixed(1), percentage: ((exposureScore / 10) * 100).toFixed(0) },
            { name: "Critical Vulnerability Ratio", score: criticality.toFixed(1), percentage: ((criticality / 10) * 100).toFixed(0) }
        ];
        
        return `
            <div class="space-y-4">
                ${components.map(component => `
                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <span class="text-sm font-medium">${component.name}</span>
                            <span class="text-sm font-medium">${component.score}/10</span>
                        </div>
                        <div class="w-full bg-gray-200 rounded-full h-2.5">
                            <div class="bg-indigo-600 h-2.5 rounded-full" style="width: ${component.percentage}%"></div>
                        </div>
                    </div>
                `).join('')}
            </div>
            <div class="mt-4">
                <p class="text-sm text-gray-600">Risk score is calculated based on severity of vulnerabilities, exposure (unique systems affected), and percentage of critical issues.</p>
            </div>
        `;
    }

    // Render executive summary
    function renderExecutiveSummary(data) {
        const executiveSummary = document.getElementById('executiveSummary');
        const current = data.executiveSummary.current;
        const previous = data.executiveSummary.previous[0];
        const comparison = data.comparison[0];

        let html = `
            <div class="p-6">
                <h2 class="text-2xl font-bold mb-4">Executive Summary</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Vulnerability Summary</h3>
                        ${renderKeyMetrics(current, comparison)}
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Trend Analysis</h3>
                        <div class="chart-container">
                            <canvas id="vulnerabilityTrendChart"></canvas>
                        </div>
                    </div>
                </div>
                <div class="mt-6">
                    <h3 class="text-xl font-semibold mb-3">Key Findings</h3>
                    ${renderExecutiveInsights(data)}
                </div>
            </div>
        `;
        executiveSummary.innerHTML = html;

        renderVulnerabilityTrendChart(data);
    }

    // Render AI insights
    function renderAIInsights(insights) {
        const aiInsights = document.getElementById('aiInsights');
        
        if (!insights || insights.length === 0) {
            aiInsights.classList.add('hidden');
            return;
        }
        
        let html = `
            <div class="p-6">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-2xl font-bold">AI-Powered Insights</h2>
                    <span class="bg-purple-100 text-purple-800 text-xs font-medium px-2.5 py-0.5 rounded">Confidence Score: High</span>
                </div>
                <div class="space-y-4">
        `;
        
        insights.forEach(insight => {
            let iconClass;
            switch (insight.type) {
                case 'risk': iconClass = 'fa-shield-alt'; break;
                case 'critical': iconClass = 'fa-exclamation-triangle'; break;
                case 'trend': iconClass = 'fa-chart-line'; break;
                case 'remediation': iconClass = 'fa-check-circle'; break;
                case 'new': iconClass = 'fa-plus-circle'; break;
                case 'mission': iconClass = 'fa-building'; break;
                case 'predictive': iconClass = 'fa-crystal-ball'; break;
                default: iconClass = 'fa-lightbulb';
            }
            
            const confidenceLabel = insight.confidence >= 0.8 ? 'High' : 
                                  insight.confidence >= 0.6 ? 'Medium' : 'Low';
            
            html += `
                <div class="ai-insight-card">
                    <div class="ai-insight-header">
                        <i class="fas ${iconClass} ai-insight-icon"></i>
                        ${insight.title}
                        <span class="ml-auto text-xs text-purple-700">${Math.round(insight.confidence * 100)}% confidence</span>
                    </div>
                    <p class="text-gray-700">${insight.description}</p>
                </div>
            `;
        });
        
        html += `
                </div>
            </div>
        `;
        
        aiInsights.innerHTML = html;
    }

    // Render key metrics
    function renderKeyMetrics(current, comparison) {
        return `
            <div class="grid grid-cols-2 gap-4">
                ${renderMetricCard('Total Vulnerabilities', current.totalVulnerabilities, comparison.totalVulnerabilities, 'bg-blue-100')}
                ${renderMetricCard('Critical Vulnerabilities', current.criticalVulnerabilities, comparison.criticalVulnerabilities, 'bg-critical')}
                ${renderMetricCard('High Vulnerabilities', current.highVulnerabilities, comparison.highVulnerabilities, 'bg-high')}
                ${renderMetricCard('Medium Vulnerabilities', current.mediumVulnerabilities, comparison.mediumVulnerabilities, 'bg-medium')}
            </div>
        `;
    }

    // Render metric card
    function renderMetricCard(title, value, change, bgColor) {
        const trendClass = change.improved ? 'trend-down' : change.absolute === 0 ? 'text-gray-500' : 'trend-up';
        const trendIcon = change.improved ? '▼' : change.absolute === 0 ? '■' : '▲';
        return `
            <div class="p-4 rounded-lg shadow-sm ${bgColor}">
                <h4 class="text-sm font-semibold mb-2">${title}</h4>
                <p class="text-2xl font-bold">${value.toLocaleString()}</p>
                <p class="text-sm ${trendClass} flex items-center mt-1">
                    <span class="trend-indicator">${trendIcon}</span>
                    ${Math.abs(change.absolute).toLocaleString()} (${change.improved ? '-' : '+'}${Math.abs(change.percentage)}%)
                    <span class="tooltip ml-1">
                        <i class="fas fa-info-circle"></i>
                        <span class="tooltiptext">
                            Absolute change: ${change.absolute}<br>
                            Percentage change: ${change.percentage}%
                        </span>
                    </span>
                </p>
            </div>
        `;
    }

    // Render vulnerability trend chart
    function renderVulnerabilityTrendChart(data) {
        const ctx = document.getElementById('vulnerabilityTrendChart').getContext('2d');
        
        // Get all time points (current and previous scans)
        const timePoints = ['Current'].concat(
            previousVulnerabilityData.map(pv => pv.label || 'Previous')
        );
        
        // Get data for each severity level
        const datasets = [
            {
                label: 'Critical',
                data: [data.executiveSummary.current.criticalVulnerabilities].concat(
                    data.executiveSummary.previous.map(prev => prev.criticalVulnerabilities)
                ),
                backgroundColor: 'rgba(239, 68, 68, 0.7)',
                borderColor: 'rgb(239, 68, 68)',
                borderWidth: 2
            },
            {
                label: 'High',
                data: [data.executiveSummary.current.highVulnerabilities].concat(
                    data.executiveSummary.previous.map(prev => prev.highVulnerabilities)
                ),
                backgroundColor: 'rgba(249, 115, 22, 0.7)',
                borderColor: 'rgb(249, 115, 22)',
                borderWidth: 2
            },
            {
                label: 'Medium',
                data: [data.executiveSummary.current.mediumVulnerabilities].concat(
                    data.executiveSummary.previous.map(prev => prev.mediumVulnerabilities)
                ),
                backgroundColor: 'rgba(234, 179, 8, 0.7)',
                borderColor: 'rgb(234, 179, 8)',
                borderWidth: 2
            },
            {
                label: 'Low',
                data: [data.executiveSummary.current.lowVulnerabilities].concat(
                    data.executiveSummary.previous.map(prev => prev.lowVulnerabilities)
                ),
                backgroundColor: 'rgba(34, 197, 94, 0.7)',
                borderColor: 'rgb(34, 197, 94)',
                borderWidth: 2
            }
        ];

        // Create chart
        modalCharts.vulnerabilityTrend = new Chart(ctx, {
            type: 'line',
            data: { 
                labels: timePoints,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    label += context.parsed.y.toLocaleString();
                                }
                                return label;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true
                    }
                }
            }
        });
    }

    // Render executive insights
    function renderExecutiveInsights(data) {
        const current = data.executiveSummary.current;
        const previous = data.executiveSummary.previous[0];
        const comparison = data.comparison[0];

        const totalChange = comparison.totalVulnerabilities;
        const criticalChange = comparison.criticalVulnerabilities;
        const remediatedCount = data.diffAnalysis.remediated.length;
        const newCount = data.diffAnalysis.new.length;

        return `
            <div class="bg-gray-50 p-4 rounded-lg">
                <ul class="space-y-2">
                    <li class="flex items-start">
                        <i class="fas fa-chart-line text-indigo-600 mt-1 mr-2"></i>
                        <span>Overall vulnerability count has ${totalChange.absolute > 0 ? 'increased' : 'decreased'} by ${Math.abs(totalChange.absolute)} (${Math.abs(totalChange.percentage)}%).</span>
                    </li>
                    <li class="flex items-start">
                        <i class="fas fa-exclamation-triangle text-red-600 mt-1 mr-2"></i>
                        <span>Critical vulnerabilities have ${criticalChange.absolute > 0 ? 'increased' : 'decreased'} by ${Math.abs(criticalChange.absolute)} (${Math.abs(criticalChange.percentage)}%).</span>
                    </li>
                    <li class="flex items-start">
                        <i class="fas fa-check-circle text-green-600 mt-1 mr-2"></i>
                        <span>${remediatedCount} vulnerabilities have been remediated since the last scan.</span>
                    </li>
                    <li class="flex items-start">
                        <i class="fas fa-plus-circle text-orange-600 mt-1 mr-2"></i>
                        <span>${newCount} new vulnerabilities have been identified since the last scan.</span>
                    </li>
                    <li class="flex items-start">
                        <i class="fas fa-building text-blue-600 mt-1 mr-2"></i>
                        <span>Top affected mission: ${getTopAffectedMission(data.missionAnalysis.current)}</span>
                    </li>
                    <li class="flex items-start">
                        <i class="fas fa-bug text-purple-600 mt-1 mr-2"></i>
                        <span>Most common vulnerability: ${getMostCommonPlugin(data.pluginAnalysis.current)}</span>
                    </li>
                </ul>
            </div>
        `;
    }

    // Get top affected mission
    function getTopAffectedMission(missionData) {
        let topMission = { name: 'Unknown', count: 0 };
        
        for (const [mission, data] of missionData.entries()) {
            if (data.totalVulnerabilities > topMission.count) {
                topMission = {
                    name: mission,
                    count: data.totalVulnerabilities
                };
            }
        }
        
        return `${topMission.name} (${topMission.count} vulnerabilities)`;
    }

    // Get most common plugin
    function getMostCommonPlugin(pluginData) {
        let topPlugin = { name: 'Unknown', count: 0 };
        
        for (const [plugin, data] of pluginData.entries()) {
            if (data.count > topPlugin.count) {
                topPlugin = {
                    name: plugin,
                    count: data.count
                };
            }
        }
        
        return `${topPlugin.name} (${topPlugin.count} instances)`;
    }

    // Render overall summary
    function renderOverallSummary(summary, comparison) {
        const overallSummary = document.getElementById('overallSummary');
        overallSummary.innerHTML = `
            <div class="p-6">
                <h2 class="text-2xl font-bold mb-4">Overall Vulnerability Summary</h2>
                <div class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-4 mb-6">
                    ${renderMetricCard('Total Vulnerabilities', summary.current.totalVulnerabilities, comparison[0].totalVulnerabilities, 'bg-white')}
                    ${renderMetricCard('Critical Vulnerabilities', summary.current.criticalVulnerabilities, comparison[0].criticalVulnerabilities, 'bg-white')}
                    ${renderMetricCard('High Vulnerabilities', summary.current.highVulnerabilities, comparison[0].highVulnerabilities, 'bg-white')}
                    ${renderMetricCard('Medium Vulnerabilities', summary.current.mediumVulnerabilities, comparison[0].mediumVulnerabilities, 'bg-white')}
                    ${renderMetricCard('Low Vulnerabilities', summary.current.lowVulnerabilities, comparison[0].lowVulnerabilities, 'bg-white')}
                    ${renderMetricCard('Unique Systems', summary.current.uniqueIPs.size, comparison[0].uniqueIPs, 'bg-white')}
                    ${renderMetricCard('Unique Vulnerabilities', summary.current.uniquePlugins.size, comparison[0].uniquePlugins, 'bg-white')}
                    ${renderMetricCard('Business Units', summary.current.uniqueMissions.size, comparison[0].uniqueMissions, 'bg-white')}
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Vulnerability Distribution</h3>
                        <div class="chart-container">
                            <canvas id="vulnerabilityDistributionChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Remediation Progress</h3>
                        <div class="chart-container">
                            <canvas id="remediationProgressChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        `;

        renderVulnerabilityDistributionChart(summary.current);
        renderRemediationProgressChart(summary.current, comparison[0]);
    }

    // Render vulnerability distribution chart
    function renderVulnerabilityDistributionChart(current) {
        const ctx = document.getElementById('vulnerabilityDistributionChart').getContext('2d');
        
        // Create chart
        modalCharts.vulnerabilityDistribution = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: ['Critical', 'High', 'Medium', 'Low'],
                datasets: [{
                    data: [
                        current.criticalVulnerabilities,
                        current.highVulnerabilities,
                        current.mediumVulnerabilities,
                        current.lowVulnerabilities
                    ],
                    backgroundColor: [
                        'rgba(239, 68, 68, 0.7)',
                        'rgba(249, 115, 22, 0.7)',
                        'rgba(234, 179, 8, 0.7)',
                        'rgba(34, 197, 94, 0.7)'
                    ],
                    borderColor: [
                        'rgb(239, 68, 68)',
                        'rgb(249, 115, 22)',
                        'rgb(234, 179, 8)',
                        'rgb(34, 197, 94)'
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(1);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Render remediation progress chart
    function renderRemediationProgressChart(current, comparison) {
        const ctx = document.getElementById('remediationProgressChart').getContext('2d');
        
        // Calculate remediation statistics
        const remediatedCount = Math.abs(comparison.totalVulnerabilities.absolute < 0 ? comparison.totalVulnerabilities.absolute : 0);
        const persistingCount = current.totalVulnerabilities;
        const newCount = comparison.totalVulnerabilities.absolute > 0 ? comparison.totalVulnerabilities.absolute : 0;
        
        // Create chart
        modalCharts.remediationProgress = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: ['Remediated', 'Persisting', 'New'],
                datasets: [{
                    data: [remediatedCount, persistingCount - newCount, newCount],
                    backgroundColor: [
                        'rgba(34, 197, 94, 0.7)',
                        'rgba(99, 102, 241, 0.7)',
                        'rgba(239, 68, 68, 0.7)'
                    ],
                    borderColor: [
                        'rgb(34, 197, 94)',
                        'rgb(99, 102, 241)',
                        'rgb(239, 68, 68)'
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(1);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Render comparisons
    function renderComparisons(data) {
        const comparisons = document.getElementById('comparisons');
        
        let html = `
            <div class="p-6">
                <h2 class="text-2xl font-bold mb-4">Comparative Analysis</h2>
                <div class="grid grid-cols-1 md:grid-cols-${Math.min(3, data.comparison.length)} gap-6">
                    ${renderComparisonCards(data)}
                </div>
                <div class="mt-6">
                    <div class="chart-container">
                        <canvas id="comparativeAnalysisChart"></canvas>
                    </div>
                </div>
            </div>
        `;
        
        comparisons.innerHTML = html;
        
        renderComparativeAnalysisChart(data);
    }

    // Render comparison cards
    function renderComparisonCards(data) {
        return data.comparison.map((comparison, index) => {
            const previousData = data.executiveSummary.previous[index];
            const currentData = data.executiveSummary.current;
            const label = previousVulnerabilityData[index].label;

            return `
                <div class="bg-white rounded-lg p-6 shadow-md">
                    <h4 class="text-lg font-bold mb-4 text-indigo-700">${label} vs Current</h4>
                    <div class="space-y-3">
                        ${renderComparisonItem('Total', currentData.totalVulnerabilities, comparison.totalVulnerabilities)}
                        ${renderComparisonItem('Critical', currentData.criticalVulnerabilities, comparison.criticalVulnerabilities)}
                        ${renderComparisonItem('High', currentData.highVulnerabilities, comparison.highVulnerabilities)}
                        ${renderComparisonItem('Medium', currentData.mediumVulnerabilities, comparison.mediumVulnerabilities)}
                        ${renderComparisonItem('Low', currentData.lowVulnerabilities, comparison.lowVulnerabilities)}
                        <hr class="my-2 border-gray-200">
                        ${renderComparisonItem('Unique Vulnerabilities', currentData.uniquePlugins.size, comparison.uniquePlugins)}
                        ${renderComparisonItem('Unique Systems', currentData.uniqueIPs.size, comparison.uniqueIPs)}
                    </div>
                </div>
            `;
        }).join('');
    }

    // Render comparison item
    function renderComparisonItem(title, currentValue, change) {
        const trendClass = change.improved ? 'text-low' : change.absolute === 0 ? 'text-gray-500' : 'text-critical';
        const trendIcon = change.improved ? '<i class="fas fa-arrow-down"></i>' : change.absolute === 0 ? '<i class="fas fa-minus"></i>' : '<i class="fas fa-arrow-up"></i>';
        
        return `
            <div class="flex justify-between items-center">
                <span class="text-sm font-medium">${title}</span>
                <span class="text-sm font-bold ${trendClass}">
                    ${trendIcon} ${Math.abs(change.absolute).toLocaleString()} (${Math.abs(change.percentage)}%)
                    <span class="tooltip">
                        <i class="fas fa-info-circle text-gray-400"></i>
                        <span class="tooltiptext">
                            Current: ${currentValue}<br>
                            Change: ${change.absolute > 0 ? '+' : ''}${change.absolute} (${change.percentage}%)
                        </span>
                    </span>
                </span>
            </div>
        `;
    }

    // Render comparative analysis chart
    function renderComparativeAnalysisChart(data) {
        const ctx = document.getElementById('comparativeAnalysisChart').getContext('2d');
        
        // Get data for each time point
        const timePoints = ['Current'].concat(
            previousVulnerabilityData.map(pv => pv.label || 'Previous')
        );
        
        // Get data for each category
        const severities = ['Critical', 'High', 'Medium', 'Low'];
        const datasets = severities.map(severity => {
            const currentValue = data.executiveSummary.current[severity.toLowerCase() + 'Vulnerabilities'];
            const previousValues = data.executiveSummary.previous.map(prev => prev[severity.toLowerCase() + 'Vulnerabilities']);
            
            let color;
            switch(severity) {
                case 'Critical': color = 'rgb(239, 68, 68)'; break;
                case 'High': color = 'rgb(249, 115, 22)'; break;
                case 'Medium': color = 'rgb(234, 179, 8)'; break;
                case 'Low': color = 'rgb(34, 197, 94)'; break;
                default: color = 'rgb(99, 102, 241)';
            }
            
            return {
                label: severity,
                data: [currentValue, ...previousValues],
                backgroundColor: color,
                borderColor: color,
                borderWidth: 1
            };
        });
        
        // Create chart
        modalCharts.comparativeAnalysis = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: timePoints,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        stacked: true
                    },
                    y: {
                        stacked: true,
                        beginAtZero: true
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    label += context.parsed.y.toLocaleString();
                                }
                                return label;
                            }
                        }
                    }
                }
            }
        });
    }

    // Render mission analysis
    function renderMissionAnalysis(missionData) {
        const missionAnalysis = document.getElementById('missionAnalysis');
        
        let html = `
            <div class="p-6">
                <h2 class="text-2xl font-bold mb-4">Business Unit Analysis</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <div class="chart-container">
                            <canvas id="missionVulnerabilityChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Business Unit Risk Scores</h3>
                        <div class="chart-container">
                            <canvas id="missionRiskScoreChart"></canvas>
                        </div>
                    </div>
                </div>
                <div class="mt-6">
                    <h3 class="text-xl font-semibold mb-3">Business Unit Details</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full bg-white">
                            <thead>
                                <tr>
                                    <th class="py-2 px-4 border-b border-gray-200">Business Unit</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Risk Score</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Total</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Critical</th>
                                    <th class="py-2 px-4 border-b border-gray-200">High</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Systems</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Trend</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${renderMissionTableRows(missionData.current, missionData.previous[0])}
                            </tbody>
                        </table>
                    </div>
                </div>
                <div class="mt-6">
                    <h3 class="text-xl font-semibold mb-3">Key Insights</h3>
                    ${renderMissionKeyInsights(missionData.current, missionData.previous[0])}
                </div>
            </div>
        `;
        
        missionAnalysis.innerHTML = html;
        
        renderMissionVulnerabilityChart(missionData.current);
        renderMissionRiskScoreChart(missionData.current);
    }

    // Render mission table rows
    function renderMissionTableRows(currentMissionData, previousMissionData) {
        // Convert Map to array and sort by risk score (descending)
        const missions = Array.from(currentMissionData.entries()).map(([mission, data]) => ({
            mission,
            data,
            previousData: previousMissionData ? previousMissionData.get(mission) : null
        }));
        
        missions.sort((a, b) => (b.data.riskScore || 0) - (a.data.riskScore || 0));
        
        return missions.map(({ mission, data, previousData }) => {
            let trendIcon, trendClass;
            
            if (previousData) {
                const change = data.totalVulnerabilities - previousData.totalVulnerabilities;
                trendIcon = change > 0 ? '<i class="fas fa-arrow-up"></i>' :
                          change < 0 ? '<i class="fas fa-arrow-down"></i>' :
                          '<i class="fas fa-minus"></i>';
                trendClass = change > 0 ? 'text-critical' :
                           change < 0 ? 'text-low' :
                           'text-gray-500';
            } else {
                trendIcon = '<i class="fas fa-minus"></i>';
                trendClass = 'text-gray-500';
            }
            
            let riskScoreClass;
            if (data.riskScore >= 7.5) {
                riskScoreClass = 'text-critical font-bold';
            } else if (data.riskScore >= 5) {
                riskScoreClass = 'text-high font-bold';
            } else if (data.riskScore >= 2.5) {
                riskScoreClass = 'text-medium font-bold';
            } else {
                riskScoreClass = 'text-low font-bold';
            }
            
            return `
                <tr class="hover:bg-gray-50">
                    <td class="py-2 px-4 border-b border-gray-200 font-medium">${mission}</td>
                    <td class="py-2 px-4 border-b border-gray-200 ${riskScoreClass}">${data.riskScore?.toFixed(1) || 'N/A'}</td>
                    <td class="py-2 px-4 border-b border-gray-200">${data.totalVulnerabilities}</td>
                    <td class="py-2 px-4 border-b border-gray-200 text-critical">${data.criticalVulnerabilities}</td>
                    <td class="py-2 px-4 border-b border-gray-200 text-high">${data.highVulnerabilities}</td>
                    <td class="py-2 px-4 border-b border-gray-200">${data.uniqueIPs.size}</td>
                    <td class="py-2 px-4 border-b border-gray-200 ${trendClass}">${trendIcon}</td>
                </tr>
            `;
        }).join('');
    }

    // Render mission vulnerability chart
    function renderMissionVulnerabilityChart(missionData) {
        const ctx = document.getElementById('missionVulnerabilityChart').getContext('2d');
        
        // Convert Map to array and sort by total vulnerabilities (descending)
        const missions = Array.from(missionData.entries())
            .map(([mission, data]) => ({
                mission,
                totalVulnerabilities: data.totalVulnerabilities,
                criticalVulnerabilities: data.criticalVulnerabilities,
                highVulnerabilities: data.highVulnerabilities
            }))
            .sort((a, b) => b.totalVulnerabilities - a.totalVulnerabilities)
            .slice(0, 10); // Top 10 missions
        
        // Create chart
        modalCharts.missionVulnerability = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: missions.map(m => m.mission),
                datasets: [
                    {
                        label: 'Critical',
                        data: missions.map(m => m.criticalVulnerabilities),
                        backgroundColor: 'rgba(239, 68, 68, 0.7)',
                        borderColor: 'rgb(239, 68, 68)',
                        borderWidth: 1
                    },
                    {
                        label: 'High',
                        data: missions.map(m => m.highVulnerabilities),
                        backgroundColor: 'rgba(249, 115, 22, 0.7)',
                        borderColor: 'rgb(249, 115, 22)',
                        borderWidth: 1
                    },
                    {
                        label: 'Other',
                        data: missions.map(m => m.totalVulnerabilities - m.criticalVulnerabilities - m.highVulnerabilities),
                        backgroundColor: 'rgba(99, 102, 241, 0.7)',
                        borderColor: 'rgb(99, 102, 241)',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        stacked: true,
                        title: {
                            display: true,
                            text: 'Business Unit'
                        }
                    },
                    y: {
                        stacked: true,
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Vulnerability Count'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    title: {
                        display: true,
                        text: 'Top 10 Business Units by Vulnerability Count'
                    }
                }
            }
        });
    }

    // Render mission risk score chart
  // Render mission risk score chart
function renderMissionRiskScoreChart(missionData) {
    const ctx = document.getElementById('missionRiskScoreChart').getContext('2d');
    
    // Convert Map to array and sort by risk score (descending)
    const missions = Array.from(missionData.entries())
        .map(([mission, data]) => ({
            mission,
            riskScore: data.riskScore || 0
        }))
        .sort((a, b) => b.riskScore - a.riskScore)
        .slice(0, 10); // Top 10 missions
    
    // Create chart
    modalCharts.missionRiskScore = new Chart(ctx, {
        type: 'bar', // Changed from 'horizontalBar' to 'bar'
        data: {
            labels: missions.map(m => m.mission),
            datasets: [
                {
                    label: 'Risk Score',
                    data: missions.map(m => m.riskScore),
                    backgroundColor: missions.map(m => {
                        if (m.riskScore >= 7.5) return 'rgba(239, 68, 68, 0.7)';
                        if (m.riskScore >= 5) return 'rgba(249, 115, 22, 0.7)';
                        if (m.riskScore >= 2.5) return 'rgba(234, 179, 8, 0.7)';
                        return 'rgba(34, 197, 94, 0.7)';
                    }),
                    borderColor: missions.map(m => {
                        if (m.riskScore >= 7.5) return 'rgb(239, 68, 68)';
                        if (m.riskScore >= 5) return 'rgb(249, 115, 22)';
                        if (m.riskScore >= 2.5) return 'rgb(234, 179, 8)';
                        return 'rgb(34, 197, 94)';
                    }),
                    borderWidth: 1
                }
            ]
        },
        options: {
            indexAxis: 'y', // This replaces horizontalBar chart type
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    beginAtZero: true,
                    max: 10,
                    title: {
                        display: true,
                        text: 'Risk Score'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Business Unit'
                    }
                }
            },
            plugins: {
                legend: {
                    display: false
                },
                title: {
                    display: true,
                    text: 'Top 10 Business Units by Risk Score'
                }
            }
        }
    });
}



// Process data for filtering - this was missing
function processData(current, previousArray) {
    let processedData = initializeProcessedData(previousArray.length);

    current.forEach(vulnerability => {
        updateSummary(processedData.executiveSummary.current, vulnerability);
        updateMissionAnalysis(processedData.missionAnalysis.current, vulnerability);
        updateSeverityAnalysis(processedData.severityAnalysis.current, vulnerability);
        updatePluginAnalysis(processedData.pluginAnalysis.current, vulnerability);
        updateIPAnalysis(processedData.ipAnalysis.current, vulnerability);
        updateAssetTypeAnalysis(processedData.assetTypeAnalysis.current, vulnerability);
        if (processedData.assetRiskHeatmap && processedData.assetRiskHeatmap.current) {
            updateAssetRiskHeatmap(processedData.assetRiskHeatmap.current, vulnerability);
        }
    });

    previousArray.forEach((previous, index) => {
        if (previous) {
            previous.forEach(vulnerability => {
                updateSummary(processedData.executiveSummary.previous[index], vulnerability);
                updateMissionAnalysis(processedData.missionAnalysis.previous[index], vulnerability);
                updateSeverityAnalysis(processedData.severityAnalysis.previous[index], vulnerability);
                updatePluginAnalysis(processedData.pluginAnalysis.previous[index], vulnerability);
                updateIPAnalysis(processedData.ipAnalysis.previous[index], vulnerability);
                updateAssetTypeAnalysis(processedData.assetTypeAnalysis.previous[index], vulnerability);
                if (processedData.assetRiskHeatmap && processedData.assetRiskHeatmap.previous[index]) {
                    updateAssetRiskHeatmap(processedData.assetRiskHeatmap.previous[index], vulnerability);
                }
            });
        }
    });

    processedData.diffAnalysis = analyzeDiff(current, previousArray);
    processedData.remediatedVulnerabilities = processedData.diffAnalysis.remediated;
    processedData.newVulnerabilities = processedData.diffAnalysis.new;
    
    return finalizeProcessedData(processedData);
}





    // Render mission key insights
    function renderMissionKeyInsights(currentMissionData, previousMissionData) {
        // Find most vulnerable mission (highest risk score)
        let mostVulnerableMission = { name: 'Unknown', riskScore: 0, count: 0 };
        let missionWithMostCritical = { name: 'Unknown', count: 0 };
        
        for (const [mission, data] of currentMissionData.entries()) {
            if (data.riskScore > (mostVulnerableMission.riskScore || 0)) {
                mostVulnerableMission = {
                    name: mission,
                    riskScore: data.riskScore,
                    count: data.totalVulnerabilities
                };
            }
            
            if (data.criticalVulnerabilities > missionWithMostCritical.count) {
                missionWithMostCritical = {
                    name: mission,
                    count: data.criticalVulnerabilities
                };
            }
        }
        
        // Calculate improvement/degradation if previous data exists
        let mostImprovedMission = { name: 'Unknown', change: 0 };
        let mostDegradedMission = { name: 'Unknown', change: 0 };
        
        if (previousMissionData) {
            for (const [mission, data] of currentMissionData.entries()) {
                if (previousMissionData.has(mission)) {
                    const prevData = previousMissionData.get(mission);
                    const change = prevData.totalVulnerabilities - data.totalVulnerabilities;
                    
                    if (change > mostImprovedMission.change) {
                        mostImprovedMission = {
                            name: mission,
                            change: change
                        };
                    }
                    
                    if (change < mostDegradedMission.change) {
                        mostDegradedMission = {
                            name: mission,
                            change: Math.abs(change)
                        };
                    }
                }
            }
        }
        
        return `
            <div class="bg-gray-50 p-4 rounded-lg">
                <ul class="space-y-2">
                    <li class="flex items-start">
                        <i class="fas fa-exclamation-circle text-critical mt-1 mr-2"></i>
                        <span>Most vulnerable business unit: <strong>${mostVulnerableMission.name}</strong> with a risk score of <strong>${mostVulnerableMission.riskScore?.toFixed(1) || 'N/A'}</strong> and ${mostVulnerableMission.count} vulnerabilities.</span>
                    </li>
                    ${missionWithMostCritical.name !== mostVulnerableMission.name ? `
                    <li class="flex items-start">
                        <i class="fas fa-exclamation-triangle text-high mt-1 mr-2"></i>
                        <span>Business unit with most critical vulnerabilities: <strong>${missionWithMostCritical.name}</strong> with ${missionWithMostCritical.count} critical vulnerabilities.</span>
                    </li>
                    ` : ''}
                    ${mostImprovedMission.change > 0 ? `
                    <li class="flex items-start">
                        <i class="fas fa-arrow-down text-low mt-1 mr-2"></i>
                        <span>Most improved business unit: <strong>${mostImprovedMission.name}</strong> with ${mostImprovedMission.change} fewer vulnerabilities.</span>
                    </li>
                    ` : ''}
                    ${mostDegradedMission.change > 0 ? `
                    <li class="flex items-start">
                        <i class="fas fa-arrow-up text-critical mt-1 mr-2"></i>
                        <span>Most degraded business unit: <strong>${mostDegradedMission.name}</strong> with ${mostDegradedMission.change} new vulnerabilities.</span>
                    </li>
                    ` : ''}
                    <li class="flex items-start">
                        <i class="fas fa-info-circle text-blue-600 mt-1 mr-2"></i>
                        <span>Total business units with vulnerabilities: <strong>${currentMissionData.size}</strong></span>
                    </li>
                    <li class="flex items-start">
                        <i class="fas fa-lightbulb text-yellow-500 mt-1 mr-2"></i>
                        <span>Recommendation: Prioritize remediation efforts for <strong>${mostVulnerableMission.name}</strong> and <strong>${missionWithMostCritical.name}</strong> to reduce organizational risk most effectively.</span>
                    </li>
                </ul>
            </div>
        `;
    }

    // Render severity analysis
    function renderSeverityAnalysis(severityData) {
        const severityAnalysis = document.getElementById('severityAnalysis');
        
        let html = `
            <div class="p-6">
                <h2 class="text-2xl font-bold mb-4">Severity Analysis</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Severity Distribution</h3>
                        <div class="chart-container">
                            <canvas id="severityDistributionChart2"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Severity Breakdown</h3>
                        <div class="space-y-4">
                            ${renderSeverityBreakdown(severityData.current)}
                        </div>
                    </div>
                </div>
                <div class="mt-6">
                    <h3 class="text-xl font-semibold mb-3">Severity Trend</h3>
                    <div class="chart-container">
                        <canvas id="severityTrendChart"></canvas>
                    </div>
                </div>
            </div>
        `;
        
        severityAnalysis.innerHTML = html;
        
        renderSeverityDistributionChart2(severityData.current);
        renderSeverityTrendChart(severityData);
    }

    // Render severity breakdown
    function renderSeverityBreakdown(currentSeverityData) {
        // Calculate total vulnerabilities
        let totalVulnerabilities = 0;
        for (const [_, count] of currentSeverityData.entries()) {
            totalVulnerabilities += count;
        }
        
        // Generate HTML for each severity level
        let html = '';
        
        for (const [severity, count] of currentSeverityData.entries()) {
            const percentage = ((count / totalVulnerabilities) * 100).toFixed(1);
            let colorClass, bgColorClass;
            
            switch(severity.toLowerCase()) {
                case 'critical': 
                    colorClass = 'text-critical';
                    bgColorClass = 'bg-red-600';
                    break;
                case 'high': 
                    colorClass = 'text-high';
                    bgColorClass = 'bg-orange-500';
                    break;
                case 'medium': 
                    colorClass = 'text-medium';
                    bgColorClass = 'bg-yellow-500';
                    break;
                case 'low': 
                    colorClass = 'text-low';
                    bgColorClass = 'bg-green-500';
                    break;
                default: 
                    colorClass = 'text-gray-700';
                    bgColorClass = 'bg-gray-500';
            }
            
            html += `
                <div>
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-sm font-medium ${colorClass}">${severity}</span>
                        <span class="text-sm font-medium">${count} (${percentage}%)</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded-full h-2.5">
                        <div class="${bgColorClass} h-2.5 rounded-full" style="width: ${percentage}%"></div>
                    </div>
                </div>
            `;
        }
        
        return html;
    }

    // Render severity distribution chart
    function renderSeverityDistributionChart2(currentSeverityData) {
        const ctx = document.getElementById('severityDistributionChart2').getContext('2d');
        
        // Extract data
        const labels = [];
        const data = [];
        const colors = [];
        
        for (const [severity, count] of currentSeverityData.entries()) {
            labels.push(severity);
            data.push(count);
            
            let color;
            switch(severity.toLowerCase()) {
                case 'critical': color = 'rgba(239, 68, 68, 0.7)'; break;
                case 'high': color = 'rgba(249, 115, 22, 0.7)'; break;
                case 'medium': color = 'rgba(234, 179, 8, 0.7)'; break;
                case 'low': color = 'rgba(34, 197, 94, 0.7)'; break;
                default: color = 'rgba(99, 102, 241, 0.7)';
            }
            
            colors.push(color);
        }
        
        // Create chart
        modalCharts.severityDistribution2 = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: labels,
                datasets: [{
                    data: data,
                    backgroundColor: colors,
                    borderColor: colors.map(color => color.replace('0.7', '1')),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(1);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Render severity trend chart
    function renderSeverityTrendChart(severityData) {
        const ctx = document.getElementById('severityTrendChart').getContext('2d');
        
        // Get all time points (current and previous scans)
        const timePoints = ['Current'].concat(
            previousVulnerabilityData.map(pv => pv.label || 'Previous')
        );
        
        // Get data for each severity level
        const datasets = [];
        
        for (const [severity, _] of severityData.current.entries()) {
            let color;
            switch(severity.toLowerCase()) {
                case 'critical': color = 'rgb(239, 68, 68)'; break;
                case 'high': color = 'rgb(249, 115, 22)'; break;
                case 'medium': color = 'rgb(234, 179, 8)'; break;
                case 'low': color = 'rgb(34, 197, 94)'; break;
                default: color = 'rgb(99, 102, 241)';
            }
            
            // Get current value
            const currentValue = severityData.current.get(severity) || 0;
            
            // Get previous values
            const previousValues = severityData.previous.map(prev => prev.get(severity) || 0);
            
            datasets.push({
                label: severity,
                data: [currentValue, ...previousValues],
                borderColor: color,
                backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.1)'),
                borderWidth: 2,
                fill: true,
                tension: 0.4
            });
        }
        
        // Create chart
        modalCharts.severityTrend = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timePoints,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Vulnerability Count'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Scan Period'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    }
                }
            }
        });
    }

    // Render plugin analysis
    function renderPluginAnalysis(pluginData) {
        const pluginAnalysis = document.getElementById('pluginAnalysis');
        
        // Convert Map to array and sort by count (descending)
        const plugins = Array.from(pluginData.current.entries())
            .map(([plugin, data]) => ({
                plugin,
                ...data
            }))
            .sort((a, b) => b.count - a.count);
        
        // Get top plugins
        const topPlugins = plugins.slice(0, 10);
        
        let html = `
            <div class="p-6">
                <h2 class="text-2xl font-bold mb-4">Vulnerability Type Analysis</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Top 10 Vulnerability Types</h3>
                        <div class="chart-container">
                            <canvas id="topPluginsChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Vulnerability Category Distribution</h3>
                        <div class="chart-container">
                            <canvas id="pluginCategoryChart"></canvas>
                        </div>
                    </div>
                </div>
                <div class="mt-6">
                    <h3 class="text-xl font-semibold mb-3">Top Vulnerability Types</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full bg-white">
                            <thead>
                                <tr>
                                    <th class="py-2 px-4 border-b border-gray-200">Vulnerability</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Count</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Severity</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Affected Systems</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Affected Business Units</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Category</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${topPlugins.map(plugin => `
                                    <tr class="hover:bg-gray-50">
                                        <td class="py-2 px-4 border-b border-gray-200 font-medium">${plugin.plugin}</td>
                                        <td class="py-2 px-4 border-b border-gray-200">${plugin.count}</td>
                                        <td class="py-2 px-4 border-b border-gray-200 ${getSeverityTextClass(plugin.severity)}">${plugin.severity}</td>
                                        <td class="py-2 px-4 border-b border-gray-200">${plugin.ips?.size || 0}</td>
                                        <td class="py-2 px-4 border-b border-gray-200">${plugin.missions?.size || 0}</td>
                                        <td class="py-2 px-4 border-b border-gray-200">${extractPluginCategory(plugin.plugin)}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        `;
        
        pluginAnalysis.innerHTML = html;
        
        renderTopPluginsChart(topPlugins);
        renderPluginCategoryChart(plugins);
    }

    // Get severity text class
    function getSeverityTextClass(severity) {
        switch(severity.toLowerCase()) {
            case 'critical': return 'text-critical';
            case 'high': return 'text-high';
            case 'medium': return 'text-medium';
            case 'low': return 'text-low';
            default: return 'text-gray-700';
        }
    }

    // Render top plugins chart
    function renderTopPluginsChart(topPlugins) {
        const ctx = document.getElementById('topPluginsChart').getContext('2d');
        
        // Create chart
        modalCharts.topPlugins = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: topPlugins.map(p => truncateString(p.plugin, 30)),
                datasets: [{
                    label: 'Count',
                    data: topPlugins.map(p => p.count),
                    backgroundColor: topPlugins.map(p => {
                        switch(p.severity.toLowerCase()) {
                            case 'critical': return 'rgba(239, 68, 68, 0.7)';
                            case 'high': return 'rgba(249, 115, 22, 0.7)';
                            case 'medium': return 'rgba(234, 179, 8, 0.7)';
                            case 'low': return 'rgba(34, 197, 94, 0.7)';
                            default: return 'rgba(99, 102, 241, 0.7)';
                        }
                    }),
                    borderColor: topPlugins.map(p => {
                        switch(p.severity.toLowerCase()) {
                            case 'critical': return 'rgb(239, 68, 68)';
                            case 'high': return 'rgb(249, 115, 22)';
                            case 'medium': return 'rgb(234, 179, 8)';
                            case 'low': return 'rgb(34, 197, 94)';
                            default: return 'rgb(99, 102, 241)';
                        }
                    }),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Count'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Vulnerability Type'
                        },
                        ticks: {
                            maxRotation: 45,
                            minRotation: 45
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            title: function(tooltipItems) {
                                return topPlugins[tooltipItems[0].dataIndex].plugin;
                            }
                        }
                    }
                }
            }
        });
    }

    // Render plugin category chart
    function renderPluginCategoryChart(plugins) {
        const ctx = document.getElementById('pluginCategoryChart').getContext('2d');
        
        // Group plugins by category
        const categories = {};
        plugins.forEach(plugin => {
            const category = extractPluginCategory(plugin.plugin);
            
            if (!categories[category]) {
                categories[category] = {
                    count: 0,
                    critical: 0,
                    high: 0,
                    medium: 0,
                    low: 0
                };
            }
            
            categories[category].count += plugin.count;
            
            switch(plugin.severity.toLowerCase()) {
                case 'critical': categories[category].critical += plugin.count; break;
                case 'high': categories[category].high += plugin.count; break;
                case 'medium': categories[category].medium += plugin.count; break;
                case 'low': categories[category].low += plugin.count; break;
            }
        });
        
        // Sort categories by count and take top 10
        const topCategories = Object.entries(categories)
            .map(([category, data]) => ({ category, ...data }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 10);
        
        // Create chart
        modalCharts.pluginCategory = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: topCategories.map(c => c.category),
                datasets: [{
                    data: topCategories.map(c => c.count),
                    backgroundColor: [
                        'rgba(99, 102, 241, 0.7)',
                        'rgba(239, 68, 68, 0.7)',
                        'rgba(249, 115, 22, 0.7)',
                        'rgba(234, 179, 8, 0.7)',
                        'rgba(34, 197, 94, 0.7)',
                        'rgba(16, 185, 129, 0.7)',
                        'rgba(59, 130, 246, 0.7)',
                        'rgba(139, 92, 246, 0.7)',
                        'rgba(236, 72, 153, 0.7)',
                        'rgba(248, 113, 113, 0.7)'
                    ],
                    borderColor: [
                        'rgb(99, 102, 241)',
                        'rgb(239, 68, 68)',
                        'rgb(249, 115, 22)',
                        'rgb(234, 179, 8)',
                        'rgb(34, 197, 94)',
                        'rgb(16, 185, 129)',
                        'rgb(59, 130, 246)',
                        'rgb(139, 92, 246)',
                        'rgb(236, 72, 153)',
                        'rgb(248, 113, 113)'
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const category = topCategories[context.dataIndex];
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(1);
                                return `${label}: ${value} (${percentage}%)`;
                            },
                            afterLabel: function(context) {
                                const category = topCategories[context.dataIndex];
                                return [
                                    `Critical: ${category.critical}`,
                                    `High: ${category.high}`,
                                    `Medium: ${category.medium}`,
                                    `Low: ${category.low}`
                                ];
                            }
                        }
                    }
                }
            }
        });
    }

    // Truncate string
    function truncateString(str, length) {
        if (!str) return '';
        return str.length > length ? str.substring(0, length) + '...' : str;
    }

    // Render IP analysis
    function renderIPAnalysis(ipData) {
        const ipAnalysis = document.getElementById('ipAnalysis');
        
        // Convert Map to array and sort by count (descending)
        const ips = Array.from(ipData.current.entries())
            .map(([ip, data]) => ({
                ip,
                ...data
            }))
            .sort((a, b) => b.count - a.count);
        
        // Get top IPs
        const topIPs = ips.slice(0, 10);
        
        let html = `
            <div class="p-6">
                <h2 class="text-2xl font-bold mb-4">System Analysis</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Top 10 Vulnerable Systems</h3>
                        <div class="chart-container">
                            <canvas id="topIPsChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-3">System Vulnerability Distribution</h3>
                        <div class="chart-container">
                            <canvas id="ipSeverityDistributionChart"></canvas>
                        </div>
                    </div>
                </div>
                <div class="mt-6">
                    <h3 class="text-xl font-semibold mb-3">System Details</h3>
                    <div class="overflow-x-auto">
                        <div class="mb-4 flex justify-between items-center">
                            <input type="text" id="ipSearchInput" placeholder="Search by IP address..." class="px-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                            <div class="text-sm text-gray-600">Showing <span id="ipDisplayCount">10</span> of ${ips.length} systems</div>
                        </div>
                        <table class="min-w-full bg-white">
                            <thead>
                                <tr>
                                    <th class="py-2 px-4 border-b border-gray-200">IP Address</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Total</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Critical</th>
                                    <th class="py-2 px-4 border-b border-gray-200">High</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Medium</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Low</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Business Units</th>
                                </tr>
                            </thead>
                            <tbody id="ipTableBody">
                                ${topIPs.map(ip => `
                                    <tr class="hover:bg-gray-50">
                                        <td class="py-2 px-4 border-b border-gray-200 font-medium">${ip.ip}</td>
                                        <td class="py-2 px-4 border-b border-gray-200">${ip.count}</td>
                                        <td class="py-2 px-4 border-b border-gray-200 text-critical">${ip.criticalCount}</td>
                                        <td class="py-2 px-4 border-b border-gray-200 text-high">${ip.highCount}</td>
                                        <td class="py-2 px-4 border-b border-gray-200 text-medium">${ip.mediumCount}</td>
                                        <td class="py-2 px-4 border-b border-gray-200 text-low">${ip.lowCount}</td>
                                        <td class="py-2 px-4 border-b border-gray-200">${ip.missions?.size || 0}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                        <div class="mt-4 flex justify-between">
                            <button id="prevIPsBtn" class="btn btn-secondary">Previous</button>
                            <span id="ipPagination" class="text-sm text-gray-600 flex items-center">Page <span id="currentIPPage">1</span> of <span id="totalIPPages">${Math.ceil(ips.length / 10)}</span></span>
                            <button id="nextIPsBtn" class="btn btn-secondary">Next</button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        ipAnalysis.innerHTML = html;
        
        renderTopIPsChart(topIPs);
        renderIPSeverityDistributionChart(ips);
        setupIPPagination(ips);
    }

    // Render top IPs chart
    function renderTopIPsChart(topIPs) {
        const ctx = document.getElementById('topIPsChart').getContext('2d');
        
        // Create chart
        modalCharts.topIPs = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: topIPs.map(ip => ip.ip),
                datasets: [
                    {
                        label: 'Critical',
                        data: topIPs.map(ip => ip.criticalCount),
                        backgroundColor: 'rgba(239, 68, 68, 0.7)',
                        borderColor: 'rgb(239, 68, 68)',
                        borderWidth: 1
                    },
                    {
                        label: 'High',
                        data: topIPs.map(ip => ip.highCount),
                        backgroundColor: 'rgba(249, 115, 22, 0.7)',
                        borderColor: 'rgb(249, 115, 22)',
                        borderWidth: 1
                    },
                    {
                        label: 'Medium',
                        data: topIPs.map(ip => ip.mediumCount),
                        backgroundColor: 'rgba(234, 179, 8, 0.7)',
                        borderColor: 'rgb(234, 179, 8)',
                        borderWidth: 1
                    },
                    {
                        label: 'Low',
                        data: topIPs.map(ip => ip.lowCount),
                        backgroundColor: 'rgba(34, 197, 94, 0.7)',
                        borderColor: 'rgb(34, 197, 94)',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        stacked: true,
                        title: {
                            display: true,
                            text: 'IP Address'
                        }
                    },
                    y: {
                        stacked: true,
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Vulnerability Count'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    title: {
                        display: true,
                        text: 'Top 10 Vulnerable Systems'
                    }
                }
            }
        });
    }

    // Render IP severity distribution chart
    function renderIPSeverityDistributionChart(ips) {
        const ctx = document.getElementById('ipSeverityDistributionChart').getContext('2d');
        
        // Calculate statistics
        const totalIPs = ips.length;
        const ipsWithCritical = ips.filter(ip => ip.criticalCount > 0).length;
        const ipsWithHigh = ips.filter(ip => ip.highCount > 0).length;
        const ipsWithMedium = ips.filter(ip => ip.mediumCount > 0).length;
        const ipsWithLow = ips.filter(ip => ip.lowCount > 0).length;
        
        // Create chart
        modalCharts.ipSeverityDistribution = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: [
                    'Systems with Critical',
                    'Systems with High (no Critical)',
                    'Systems with Medium (no Critical/High)',
                    'Systems with Low only'
                ],
                datasets: [{
                    data: [
                        ipsWithCritical,
                        ipsWithHigh - ips.filter(ip => ip.criticalCount > 0 && ip.highCount > 0).length,
                        ipsWithMedium - ips.filter(ip => (ip.criticalCount > 0 || ip.highCount > 0) && ip.mediumCount > 0).length,
                        ipsWithLow - ips.filter(ip => (ip.criticalCount > 0 || ip.highCount > 0 || ip.mediumCount > 0) && ip.lowCount > 0).length
                    ],
                    backgroundColor: [
                        'rgba(239, 68, 68, 0.7)',
                        'rgba(249, 115, 22, 0.7)',
                        'rgba(234, 179, 8, 0.7)',
                        'rgba(34, 197, 94, 0.7)'
                    ],
                    borderColor: [
                        'rgb(239, 68, 68)',
                        'rgb(249, 115, 22)',
                        'rgb(234, 179, 8)',
                        'rgb(34, 197, 94)'
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const total = totalIPs;
                                const percentage = ((value / total) * 100).toFixed(1);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Setup IP pagination
    function setupIPPagination(ips) {
        let currentPage = 1;
        const itemsPerPage = 10;
        const totalPages = Math.ceil(ips.length / itemsPerPage);
        let filteredIPs = [...ips];
        
        const ipSearchInput = document.getElementById('ipSearchInput');
        const ipTableBody = document.getElementById('ipTableBody');
        const prevIPsBtn = document.getElementById('prevIPsBtn');
        const nextIPsBtn = document.getElementById('nextIPsBtn');
        const currentIPPage = document.getElementById('currentIPPage');
        const totalIPPages = document.getElementById('totalIPPages');
        const ipDisplayCount = document.getElementById('ipDisplayCount');
        
        function renderIPsPage() {
            const start = (currentPage - 1) * itemsPerPage;
            const end = start + itemsPerPage;
            const pageData = filteredIPs.slice(start, end);
            
            ipTableBody.innerHTML = pageData.map(ip => `
                <tr class="hover:bg-gray-50">
                    <td class="py-2 px-4 border-b border-gray-200 font-medium">${ip.ip}</td>
                    <td class="py-2 px-4 border-b border-gray-200">${ip.count}</td>
                    <td class="py-2 px-4 border-b border-gray-200 text-critical">${ip.criticalCount}</td>
                    <td class="py-2 px-4 border-b border-gray-200 text-high">${ip.highCount}</td>
                    <td class="py-2 px-4 border-b border-gray-200 text-medium">${ip.mediumCount}</td>
                    <td class="py-2 px-4 border-b border-gray-200 text-low">${ip.lowCount}</td>
                    <td class="py-2 px-4 border-b border-gray-200">${ip.missions?.size || 0}</td>
                </tr>
            `).join('');
            
            currentIPPage.textContent = currentPage;
            totalIPPages.textContent = Math.ceil(filteredIPs.length / itemsPerPage);
            ipDisplayCount.textContent = Math.min(filteredIPs.length, end) - start;
            
            prevIPsBtn.disabled = currentPage === 1;
            nextIPsBtn.disabled = currentPage === Math.ceil(filteredIPs.length / itemsPerPage);
        }
        
        // Search functionality
        ipSearchInput.addEventListener('input', function() {
            const searchTerm = this.value.toLowerCase();
            filteredIPs = searchTerm ? 
                ips.filter(ip => ip.ip.toLowerCase().includes(searchTerm)) : 
                [...ips];
            
            currentPage = 1;
            renderIPsPage();
        });
        
        // Pagination buttons
        prevIPsBtn.addEventListener('click', function() {
            if (currentPage > 1) {
                currentPage--;
                renderIPsPage();
            }
        });
        
        nextIPsBtn.addEventListener('click', function() {
            if (currentPage < Math.ceil(filteredIPs.length / itemsPerPage)) {
                currentPage++;
                renderIPsPage();
            }
        });
        
        // Initial render
        renderIPsPage();
    }

    // Render remediated vulnerabilities
    function renderRemediatedVulnerabilities(remediatedData) {
        const remediatedVulnerabilities = document.getElementById('remediatedVulnerabilities');
        
        if (!remediatedData || remediatedData.length === 0) {
            remediatedVulnerabilities.innerHTML = `
                <div class="p-6">
                    <h2 class="text-2xl font-bold mb-4">Remediated Vulnerabilities</h2>
                    <div class="bg-gray-50 p-6 rounded-lg text-center">
                        <i class="fas fa-info-circle text-4xl text-gray-400 mb-4"></i>
                        <p class="text-gray-700">No remediated vulnerabilities detected.</p>
                    </div>
                </div>
            `;
            return;
        }
        
        // Count remediated vulnerabilities by severity
        const remediatedBySeverity = {
            Critical: 0,
            High: 0,
            Medium: 0,
            Low: 0,
            Unknown: 0
        };
        
        remediatedData.forEach(vuln => {
            const severity = vuln.SEVERITY || 'Unknown';
            remediatedBySeverity[severity] = (remediatedBySeverity[severity] || 0) + 1;
        });
        
        let html = `
            <div class="p-6">
                <h2 class="text-2xl font-bold mb-4">Remediated Vulnerabilities</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Remediation Summary</h3>
                        <div class="chart-container">
                            <canvas id="remediationSummaryChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Key Metrics</h3>
                        <div class="grid grid-cols-2 gap-4">
                            ${renderRemediationMetricCards(remediatedData, remediatedBySeverity)}
                        </div>
                    </div>
                </div>
                <div class="mt-6">
                    <h3 class="text-xl font-semibold mb-3">Remediated Vulnerabilities Detail</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full bg-white">
                            <thead>
                                <tr>
                                    <th class="py-2 px-4 border-b border-gray-200">Vulnerability</th>
                                    <th class="py-2 px-4 border-b border-gray-200">IP Address</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Severity</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Business Unit</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Status</th>
                                </tr>
                            </thead>
                            <tbody id="remediatedVulnerabilitiesTable">
                                ${remediatedData.slice(0, 10).map(vuln => `
                                    <tr class="hover:bg-gray-50">
                                        <td class="py-2 px-4 border-b border-gray-200 font-medium">${vuln['PLUGIN NAME'] || 'N/A'}</td>
                                        <td class="py-2 px-4 border-b border-gray-200">${vuln['IP ADDRESS'] || 'N/A'}</td>
                                        <td class="py-2 px-4 border-b border-gray-200 ${getSeverityTextClass(vuln.SEVERITY || 'Unknown')}">${vuln.SEVERITY || 'Unknown'}</td>
                                        <td class="py-2 px-4 border-b border-gray-200">${vuln.MISSION || 'Unknown'}</td>
                                        <td class="py-2 px-4 border-b border-gray-200">
                                            <span class="status-badge status-remediated">
                                                <i class="fas fa-check-circle mr-1"></i> Remediated
                                            </span>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                        <div class="mt-4 flex justify-between">
                            <button id="prevRemediatedBtn" class="btn btn-secondary">Previous</button>
                            <span id="remediatedPagination" class="text-sm text-gray-600 flex items-center">Page <span id="currentRemediatedPage">1</span> of <span id="totalRemediatedPages">${Math.ceil(remediatedData.length / 10)}</span></span>
                            <button id="nextRemediatedBtn" class="btn btn-secondary">Next</button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        remediatedVulnerabilities.innerHTML = html;
        
        renderRemediationSummaryChart(remediatedBySeverity);
        setupRemediationPagination(remediatedData);
    }

    // Render remediation summary chart
    function renderRemediationSummaryChart(remediatedBySeverity) {
        const ctx = document.getElementById('remediationSummaryChart').getContext('2d');
        
        // Create chart
        modalCharts.remediationSummary = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: Object.keys(remediatedBySeverity).filter(severity => remediatedBySeverity[severity] > 0),
                datasets: [{
                    data: Object.entries(remediatedBySeverity)
                        .filter(([_, count]) => count > 0)
                        .map(([_, count]) => count),
                    backgroundColor: [
                        'rgba(239, 68, 68, 0.7)',
                        'rgba(249, 115, 22, 0.7)',
                        'rgba(234, 179, 8, 0.7)',
                        'rgba(34, 197, 94, 0.7)',
                        'rgba(99, 102, 241, 0.7)'
                    ],
                    borderColor: [
                        'rgb(239, 68, 68)',
                        'rgb(249, 115, 22)',
                        'rgb(234, 179, 8)',
                        'rgb(34, 197, 94)',
                        'rgb(99, 102, 241)'
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const total = Object.values(remediatedBySeverity).reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(1);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Render remediation metric cards
    function renderRemediationMetricCards(remediatedData, remediatedBySeverity) {
        const totalRemediated = remediatedData.length;
        
        // Calculate total risk reduction
        const severityWeights = {
            Critical: 10,
            High: 8,
            Medium: 5,
            Low: 2,
            Unknown: 1
        };
        
        let riskReduction = 0;
        Object.entries(remediatedBySeverity).forEach(([severity, count]) => {
            riskReduction += count * (severityWeights[severity] || 1);
        });
        
        return `
            <div class="bg-white p-4 rounded-lg shadow-sm bg-green-50">
                <h4 class="text-sm font-semibold mb-2">Total Remediated</h4>
                <p class="text-2xl font-bold">${totalRemediated}</p>
                <p class="text-sm text-gray-600">Vulnerabilities fixed</p>
            </div>
            <div class="bg-white p-4 rounded-lg shadow-sm bg-red-50">
                <h4 class="text-sm font-semibold mb-2">Critical Remediated</h4>
                <p class="text-2xl font-bold">${remediatedBySeverity.Critical || 0}</p>
                <p class="text-sm text-gray-600">High-risk issues</p>
            </div>
            <div class="bg-white p-4 rounded-lg shadow-sm bg-blue-50">
                <h4 class="text-sm font-semibold mb-2">Risk Reduction</h4>
                <p class="text-2xl font-bold">${riskReduction.toFixed(0)}</p>
                <p class="text-sm text-gray-600">Risk score points</p>
            </div>
            <div class="bg-white p-4 rounded-lg shadow-sm bg-purple-50">
                <h4 class="text-sm font-semibold mb-2">Systems Improved</h4>
                <p class="text-2xl font-bold">${new Set(remediatedData.map(v => v['IP ADDRESS'])).size}</p>
                <p class="text-sm text-gray-600">Affected systems</p>
            </div>
        `;
    }

    // Setup remediation pagination
    function setupRemediationPagination(remediatedData) {
        let currentPage = 1;
        const itemsPerPage = 10;
        const totalPages = Math.ceil(remediatedData.length / itemsPerPage);
        
        const remediatedTable = document.getElementById('remediatedVulnerabilitiesTable');
        const prevBtn = document.getElementById('prevRemediatedBtn');
        const nextBtn = document.getElementById('nextRemediatedBtn');
        const currentPageEl = document.getElementById('currentRemediatedPage');
        const totalPagesEl = document.getElementById('totalRemediatedPages');
        
        function renderRemediatedPage() {
            const start = (currentPage - 1) * itemsPerPage;
            const end = start + itemsPerPage;
            const pageData = remediatedData.slice(start, end);
            
            remediatedTable.innerHTML = pageData.map(vuln => `
                <tr class="hover:bg-gray-50">
                    <td class="py-2 px-4 border-b border-gray-200 font-medium">${vuln['PLUGIN NAME'] || 'N/A'}</td>
                    <td class="py-2 px-4 border-b border-gray-200">${vuln['IP ADDRESS'] || 'N/A'}</td>
                    <td class="py-2 px-4 border-b border-gray-200 ${getSeverityTextClass(vuln.SEVERITY || 'Unknown')}">${vuln.SEVERITY || 'Unknown'}</td>
                    <td class="py-2 px-4 border-b border-gray-200">${vuln.MISSION || 'Unknown'}</td>
                    <td class="py-2 px-4 border-b border-gray-200">
                        <span class="status-badge status-remediated">
                            <i class="fas fa-check-circle mr-1"></i> Remediated
                        </span>
                    </td>
                </tr>
            `).join('');
            
            currentPageEl.textContent = currentPage;
            totalPagesEl.textContent = totalPages;
            
            prevBtn.disabled = currentPage === 1;
            nextBtn.disabled = currentPage === totalPages;
        }
        
        prevBtn.addEventListener('click', function() {
            if (currentPage > 1) {
                currentPage--;
                renderRemediatedPage();
            }
        });
        
        nextBtn.addEventListener('click', function() {
            if (currentPage < totalPages) {
                currentPage++;
                renderRemediatedPage();
            }
        });
        
        // Initial render
        renderRemediatedPage();
    }

    // Render new vulnerabilities
    function renderNewVulnerabilities(newData) {
        const newVulnerabilities = document.getElementById('newVulnerabilities');
        
        if (!newData || newData.length === 0) {
            newVulnerabilities.innerHTML = `
                <div class="p-6">
                    <h2 class="text-2xl font-bold mb-4">New Vulnerabilities</h2>
                    <div class="bg-gray-50 p-6 rounded-lg text-center">
                        <i class="fas fa-info-circle text-4xl text-gray-400 mb-4"></i>
                        <p class="text-gray-700">No new vulnerabilities detected.</p>
                    </div>
                </div>
            `;
            return;
        }
        
        // Count new vulnerabilities by severity
        const newBySeverity = {
            Critical: 0,
            High: 0,
            Medium: 0,
            Low: 0,
            Unknown: 0
        };
        
        newData.forEach(vuln => {
            const severity = vuln.SEVERITY || 'Unknown';
            newBySeverity[severity] = (newBySeverity[severity] || 0) + 1;
        });
        
        let html = `
            <div class="p-6">
                <h2 class="text-2xl font-bold mb-4">New Vulnerabilities</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-xl font-semibold mb-3">New Vulnerabilities Summary</h3>
                        <div class="chart-container">
                            <canvas id="newVulnerabilitiesChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Top New Vulnerability Types</h3>
                        <div class="chart-container">
                            <canvas id="topNewVulnerabilitiesChart"></canvas>
                        </div>
                    </div>
                </div>
                <div class="mt-6">
                    <h3 class="text-xl font-semibold mb-3">New Vulnerabilities Detail</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full bg-white">
                            <thead>
                                <tr>
                                    <th class="py-2 px-4 border-b border-gray-200">Vulnerability</th>
                                    <th class="py-2 px-4 border-b border-gray-200">IP Address</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Severity</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Business Unit</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Status</th>
                                </tr>
                            </thead>
                            <tbody id="newVulnerabilitiesTable">
                                ${newData.slice(0, 10).map(vuln => `
                                    <tr class="hover:bg-gray-50">
                                        <td class="py-2 px-4 border-b border-gray-200 font-medium">${vuln['PLUGIN NAME'] || 'N/A'}</td>
                                        <td class="py-2 px-4 border-b border-gray-200">${vuln['IP ADDRESS'] || 'N/A'}</td>
                                        <td class="py-2 px-4 border-b border-gray-200 ${getSeverityTextClass(vuln.SEVERITY || 'Unknown')}">${vuln.SEVERITY || 'Unknown'}</td>
                                        <td class="py-2 px-4 border-b border-gray-200">${vuln.MISSION || 'Unknown'}</td>
                                        <td class="py-2 px-4 border-b border-gray-200">
                                            <span class="status-badge status-new">
                                                <i class="fas fa-exclamation-circle mr-1"></i> New
                                            </span>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                        <div class="mt-4 flex justify-between">
                            <button id="prevNewBtn" class="btn btn-secondary">Previous</button>
                            <span id="newPagination" class="text-sm text-gray-600 flex items-center">Page <span id="currentNewPage">1</span> of <span id="totalNewPages">${Math.ceil(newData.length / 10)}</span></span>
                            <button id="nextNewBtn" class="btn btn-secondary">Next</button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        newVulnerabilities.innerHTML = html;
        
        renderNewVulnerabilitiesChart(newBySeverity);
        renderTopNewVulnerabilitiesChart(newData);
        setupNewVulnerabilitiesPagination(newData);
    }

    // Render new vulnerabilities chart
    function renderNewVulnerabilitiesChart(newBySeverity) {
        const ctx = document.getElementById('newVulnerabilitiesChart').getContext('2d');
        
        // Create chart
        modalCharts.newVulnerabilities = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: Object.keys(newBySeverity).filter(severity => newBySeverity[severity] > 0),
                datasets: [{
                    data: Object.entries(newBySeverity)
                        .filter(([_, count]) => count > 0)
                        .map(([_, count]) => count),
                    backgroundColor: [
                        'rgba(239, 68, 68, 0.7)',
                        'rgba(249, 115, 22, 0.7)',
                        'rgba(234, 179, 8, 0.7)',
                        'rgba(34, 197, 94, 0.7)',
                        'rgba(99, 102, 241, 0.7)'
                    ],
                    borderColor: [
                        'rgb(239, 68, 68)',
                        'rgb(249, 115, 22)',
                        'rgb(234, 179, 8)',
                        'rgb(34, 197, 94)',
                        'rgb(99, 102, 241)'
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const total = Object.values(newBySeverity).reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(1);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Render top new vulnerabilities chart
    function renderTopNewVulnerabilitiesChart(newData) {
        const ctx = document.getElementById('topNewVulnerabilitiesChart').getContext('2d');
        
        // Count vulnerabilities by plugin
        const pluginCounts = {};
        newData.forEach(vuln => {
            const plugin = vuln['PLUGIN NAME'] || 'Unknown';
            if (!pluginCounts[plugin]) {
                pluginCounts[plugin] = {
                    count: 0,
                    severity: vuln.SEVERITY || 'Unknown'
                };
            }
            pluginCounts[plugin].count++;
        });
        
        // Sort by count and get top 5
        const topPlugins = Object.entries(pluginCounts)
            .map(([plugin, data]) => ({ plugin, ...data }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 5);
        
        // Create chart
        modalCharts.topNewVulnerabilities = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: topPlugins.map(p => truncateString(p.plugin, 30)),
                datasets: [{
                    label: 'Count',
                    data: topPlugins.map(p => p.count),
                    backgroundColor: topPlugins.map(p => {
                        switch(p.severity.toLowerCase()) {
                            case 'critical': return 'rgba(239, 68, 68, 0.7)';
                            case 'high': return 'rgba(249, 115, 22, 0.7)';
                            case 'medium': return 'rgba(234, 179, 8, 0.7)';
                            case 'low': return 'rgba(34, 197, 94, 0.7)';
                            default: return 'rgba(99, 102, 241, 0.7)';
                        }
                    }),
                    borderColor: topPlugins.map(p => {
                        switch(p.severity.toLowerCase()) {
                            case 'critical': return 'rgb(239, 68, 68)';
                            case 'high': return 'rgb(249, 115, 22)';
                            case 'medium': return 'rgb(234, 179, 8)';
                            case 'low': return 'rgb(34, 197, 94)';
                            default: return 'rgb(99, 102, 241)';
                        }
                    }),
                    borderWidth: 1
                }]
            },
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Count'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Vulnerability Type'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            title: function(tooltipItems) {
                                return topPlugins[tooltipItems[0].dataIndex].plugin;
                            }
                        }
                    }
                }
            }
        });
    }

    // Setup new vulnerabilities pagination
    function setupNewVulnerabilitiesPagination(newData) {
        let currentPage = 1;
        const itemsPerPage = 10;
        const totalPages = Math.ceil(newData.length / itemsPerPage);
        
        const newTable = document.getElementById('newVulnerabilitiesTable');
        const prevBtn = document.getElementById('prevNewBtn');
        const nextBtn = document.getElementById('nextNewBtn');
        const currentPageEl = document.getElementById('currentNewPage');
        const totalPagesEl = document.getElementById('totalNewPages');
        
        function renderNewPage() {
            const start = (currentPage - 1) * itemsPerPage;
            const end = start + itemsPerPage;
            const pageData = newData.slice(start, end);
            
            newTable.innerHTML = pageData.map(vuln => `
                <tr class="hover:bg-gray-50">
                    <td class="py-2 px-4 border-b border-gray-200 font-medium">${vuln['PLUGIN NAME'] || 'N/A'}</td>
                    <td class="py-2 px-4 border-b border-gray-200">${vuln['IP ADDRESS'] || 'N/A'}</td>
                    <td class="py-2 px-4 border-b border-gray-200 ${getSeverityTextClass(vuln.SEVERITY || 'Unknown')}">${vuln.SEVERITY || 'Unknown'}</td>
                    <td class="py-2 px-4 border-b border-gray-200">${vuln.MISSION || 'Unknown'}</td>
                    <td class="py-2 px-4 border-b border-gray-200">
                        <span class="status-badge status-new">
                            <i class="fas fa-exclamation-circle mr-1"></i> New
                        </span>
                    </td>
                </tr>
            `).join('');
            
            currentPageEl.textContent = currentPage;
            totalPagesEl.textContent = totalPages;
            
            prevBtn.disabled = currentPage === 1;
            nextBtn.disabled = currentPage === totalPages;
        }
        
        prevBtn.addEventListener('click', function() {
            if (currentPage > 1) {
                currentPage--;
                renderNewPage();
            }
        });
        
        nextBtn.addEventListener('click', function() {
            if (currentPage < totalPages) {
                currentPage++;
                renderNewPage();
            }
        });
        
        // Initial render
        renderNewPage();
    }

    // Render asset risk heatmap
    function renderAssetRiskHeatmap(heatmapData) {
        const assetRiskHeatmap = document.getElementById('assetRiskHeatmap');
        
        if (!heatmapData || !heatmapData.current || Object.keys(heatmapData.current).length === 0) {
            assetRiskHeatmap.innerHTML = `
                <div class="p-6">
                    <h2 class="text-2xl font-bold mb-4">Asset Risk Heatmap</h2>
                    <div class="bg-gray-50 p-6 rounded-lg text-center">
                        <i class="fas fa-info-circle text-4xl text-gray-400 mb-4"></i>
                        <p class="text-gray-700">No asset risk data available.</p>
                    </div>
                </div>
            `;
            return;
        }
        
        // Prepare data for heatmap
        const heatmapValues = [];
        const missions = new Set();
        const assets = new Set();
        
        for (const mission in heatmapData.current) {
            missions.add(mission);
            
            for (const asset in heatmapData.current[mission]) {
                assets.add(asset);
                
                heatmapValues.push({
                    mission,
                    asset,
                    riskScore: heatmapData.current[mission][asset].riskScore,
                    count: heatmapData.current[mission][asset].count,
                    criticalCount: heatmapData.current[mission][asset].criticalCount,
                    highCount: heatmapData.current[mission][asset].highCount
                });
            }
        }
        
        // Sort missions and assets
        const sortedMissions = Array.from(missions).sort();
        const sortedAssets = Array.from(assets).sort((a, b) => {
            // Calculate total risk score for each asset
            const aScore = sortedMissions.reduce((sum, mission) => {
                if (heatmapData.current[mission] && heatmapData.current[mission][a]) {
                    return sum + heatmapData.current[mission][a].riskScore;
                }
                return sum;
            }, 0);
            
            const bScore = sortedMissions.reduce((sum, mission) => {
                if (heatmapData.current[mission] && heatmapData.current[mission][b]) {
                    return sum + heatmapData.current[mission][b].riskScore;
                }
                return sum;
            }, 0);
            
            return bScore - aScore;
        }).slice(0, 20); // Limit to top 20 assets
        
        let html = `
            <div class="p-6">
                <h2 class="text-2xl font-bold mb-4">Asset Risk Heatmap</h2>
                <div class="mb-6">
                    <div id="heatmapContainer" class="chart-container" style="height: 500px;"></div>
                </div>
                <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Highest Risk Assets</h3>
                        <div class="chart-container">
                            <canvas id="highestRiskAssetsChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Key Insights</h3>
                        ${renderAssetRiskKeyInsights(heatmapData)}
                    </div>
                </div>
            </div>
        `;
        
        assetRiskHeatmap.innerHTML = html;
        
        renderHeatmap(sortedMissions, sortedAssets, heatmapData.current);
        renderHighestRiskAssetsChart(heatmapData.current);
    }

    // Render heatmap
    function renderHeatmap(missions, assets, heatmapData) {
        // Set dimensions
        const margin = { top: 50, right: 100, bottom: 100, left: 150 };
        const width = 800 - margin.left - margin.right;
        const height = 500 - margin.top - margin.bottom;
        
        // Create color scale
        const colorScale = d3.scaleSequential(d3.interpolateReds)
            .domain([0, d3.max(missions, mission => 
                d3.max(assets, asset => 
                    (heatmapData[mission] && heatmapData[mission][asset]) ? 
                    heatmapData[mission][asset].riskScore : 0
                )
            )]);
        
        // Create scales
        const xScale = d3.scaleBand()
            .domain(missions)
            .range([0, width])
            .padding(0.05);
        
        const yScale = d3.scaleBand()
            .domain(assets)
            .range([0, height])
            .padding(0.05);
        
        // Create SVG
        const svg = d3.select('#heatmapContainer')
            .append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
            .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // Create heatmap cells
        missions.forEach(mission => {
            assets.forEach(asset => {
                const riskScore = (heatmapData[mission] && heatmapData[mission][asset]) ? 
                    heatmapData[mission][asset].riskScore : 0;
                
                if (riskScore > 0) {
                    svg.append('rect')
                        .attr('x', xScale(mission))
                        .attr('y', yScale(asset))
                        .attr('width', xScale.bandwidth())
                        .attr('height', yScale.bandwidth())
                        .attr('fill', colorScale(riskScore))
                        .attr('class', 'heatmap-cell')
                        .on('mouseover', function(event) {
                            const tooltip = d3.select('#heatmapContainer')
                                .append('div')
                                .attr('class', 'heatmap-tooltip')
                                .style('position', 'absolute')
                                .style('background-color', 'rgba(0, 0, 0, 0.8)')
                                .style('color', 'white')
                                .style('padding', '8px')
                                .style('border-radius', '4px')
                                .style('pointer-events', 'none')
                                .style('z-index', '10')
                                .style('left', `${event.pageX + 10}px`)
                                .style('top', `${event.pageY + 10}px`);
                            
                            const cellData = heatmapData[mission][asset];
                            tooltip.html(`
                                <div><strong>Business Unit:</strong> ${mission}</div>
                                <div><strong>Asset:</strong> ${asset}</div>
                                <div><strong>Risk Score:</strong> ${cellData.riskScore.toFixed(1)}</div>
                                <div><strong>Vulnerabilities:</strong> ${cellData.count}</div>
                                <div><strong>Critical:</strong> ${cellData.criticalCount}</div>
                                <div><strong>High:</strong> ${cellData.highCount}</div>
                            `);
                        })
                        .on('mouseout', function() {
                            d3.select('.heatmap-tooltip').remove();
                        });
                }
            });
        });
        
        // Add X axis
        svg.append('g')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(xScale))
            .selectAll('text')
            .style('text-anchor', 'end')
            .attr('dx', '-.8em')
            .attr('dy', '.15em')
            .attr('transform', 'rotate(-45)');
        
        // Add Y axis
        svg.append('g')
            .call(d3.axisLeft(yScale));
        
        // Add title
        svg.append('text')
            .attr('x', width / 2)
            .attr('y', -margin.top / 2)
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .text('Asset Risk by Business Unit');
        
        // Add color legend
        const legendWidth = 20;
        const legendHeight = height;
        
        const legend = svg.append('g')
            .attr('transform', `translate(${width + 20}, 0)`);
        
        // Create gradient
        const defs = svg.append('defs');
        const gradient = defs.append('linearGradient')
            .attr('id', 'heatmap-gradient')
            .attr('x1', '0%')
            .attr('y1', '100%')
            .attr('x2', '0%')
            .attr('y2', '0%');
        
        gradient.selectAll('stop')
            .data([
                {offset: '0%', color: colorScale(0)},
                {offset: '25%', color: colorScale(2.5)},
                {offset: '50%', color: colorScale(5)},
                {offset: '75%', color: colorScale(7.5)},
                {offset: '100%', color: colorScale(10)}
            ])
            .enter().append('stop')
            .attr('offset', d => d.offset)
            .attr('stop-color', d => d.color);
        
        legend.append('rect')
            .attr('width', legendWidth)
            .attr('height', legendHeight)
            .style('fill', 'url(#heatmap-gradient)');
        
        // Add legend ticks
        const legendScale = d3.scaleLinear()
            .domain([0, 10])
            .range([legendHeight, 0]);
        
        legend.append('g')
            .attr('transform', `translate(${legendWidth}, 0)`)
            .call(d3.axisRight(legendScale).ticks(5));
        
        legend.append('text')
            .attr('transform', `translate(${legendWidth + 30}, ${legendHeight/2}) rotate(90)`)
            .attr('text-anchor', 'middle')
            .text('Risk Score');
    }

    // Render highest risk assets chart
    function renderHighestRiskAssetsChart(heatmapData) {
        const ctx = document.getElementById('highestRiskAssetsChart').getContext('2d');
        
        // Calculate total risk score for each asset
        const assetRiskScores = {};
        
        for (const mission in heatmapData) {
            for (const asset in heatmapData[mission]) {
                if (!assetRiskScores[asset]) {
                    assetRiskScores[asset] = {
                        riskScore: 0,
                        count: 0,
                        criticalCount: 0,
                        highCount: 0
                    };
                }
                
                assetRiskScores[asset].riskScore += heatmapData[mission][asset].riskScore;
                assetRiskScores[asset].count += heatmapData[mission][asset].count;
                assetRiskScores[asset].criticalCount += heatmapData[mission][asset].criticalCount;
                assetRiskScores[asset].highCount += heatmapData[mission][asset].highCount;
            }
        }
        
        // Sort and get top 10 assets
        const topAssets = Object.entries(assetRiskScores)
            .map(([asset, data]) => ({ asset, ...data }))
            .sort((a, b) => b.riskScore - a.riskScore)
            .slice(0, 10);
        
        // Create chart
        modalCharts.highestRiskAssets = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: topAssets.map(a => truncateString(a.asset, 20)),
                datasets: [
                    {
                        label: 'Critical',
                        data: topAssets.map(a => a.criticalCount),
                        backgroundColor: 'rgba(239, 68, 68, 0.7)',
                        borderColor: 'rgb(239, 68, 68)',
                        borderWidth: 1
                    },
                    {
                        label: 'High',
                        data: topAssets.map(a => a.highCount),
                        backgroundColor: 'rgba(249, 115, 22, 0.7)',
                        borderColor: 'rgb(249, 115, 22)',
                        borderWidth: 1
                    },
                    {
                        label: 'Other',
                        data: topAssets.map(a => a.count - a.criticalCount - a.highCount),
                        backgroundColor: 'rgba(99, 102, 241, 0.7)',
                        borderColor: 'rgb(99, 102, 241)',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        stacked: true,
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Vulnerability Count'
                        }
                    },
                    y: {
                        stacked: true,
                        title: {
                            display: true,
                            text: 'Asset'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            title: function(tooltipItems) {
                                return topAssets[tooltipItems[0].dataIndex].asset;
                            },
                            footer: function(tooltipItems) {
                                const assetData = topAssets[tooltipItems[0].dataIndex];
                                return `Risk Score: ${assetData.riskScore.toFixed(1)}`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Render asset risk key insights
    function renderAssetRiskKeyInsights(heatmapData) {
        // Calculate total risk score for each asset
        const assetRiskScores = {};
        
        for (const mission in heatmapData.current) {
            for (const asset in heatmapData.current[mission]) {
                if (!assetRiskScores[asset]) {
                    assetRiskScores[asset] = {
                        riskScore: 0,
                        count: 0,
                        criticalCount: 0,
                        highCount: 0,
                        missions: new Set()
                    };
                }
                
                assetRiskScores[asset].riskScore += heatmapData.current[mission][asset].riskScore;
                assetRiskScores[asset].count += heatmapData.current[mission][asset].count;
                assetRiskScores[asset].criticalCount += heatmapData.current[mission][asset].criticalCount;
                assetRiskScores[asset].highCount += heatmapData.current[mission][asset].highCount;
                assetRiskScores[asset].missions.add(mission);
            }
        }
        
        // Sort and get highest risk asset
        const highestRiskAsset = Object.entries(assetRiskScores)
            .sort((a, b) => b[1].riskScore - a[1].riskScore)[0];
        
        // Calculate total risk score for each mission
        const missionRiskScores = {};
        
        for (const mission in heatmapData.current) {
            missionRiskScores[mission] = Object.values(heatmapData.current[mission])
                .reduce((sum, asset) => sum + asset.riskScore, 0);
        }
        
        // Get highest risk mission
        const highestRiskMission = Object.entries(missionRiskScores)
            .sort((a, b) => b[1] - a[1])[0];
        
        // Calculate multi-mission assets (assets in multiple business units)
        const multiMissionAssets = Object.entries(assetRiskScores)
            .filter(([_, data]) => data.missions.size > 1)
            .sort((a, b) => b[1].riskScore - a[1].riskScore);
        
        return `
            <div class="bg-gray-50 p-4 rounded-lg">
                <ul class="space-y-2">
                    <li class="flex items-start">
                        <i class="fas fa-exclamation-circle text-critical mt-1 mr-2"></i>
                        <span>Highest risk asset: <strong>${highestRiskAsset[0]}</strong> with a risk score of <strong>${highestRiskAsset[1].riskScore.toFixed(1)}</strong> and ${highestRiskAsset[1].count} vulnerabilities.</span>
                    </li>
                    <li class="flex items-start">
                        <i class="fas fa-building text-high mt-1 mr-2"></i>
                        <span>Highest risk business unit: <strong>${highestRiskMission[0]}</strong> with a risk score of <strong>${highestRiskMission[1].toFixed(1)}</strong>.</span>
                    </li>
                    ${multiMissionAssets.length > 0 ? `
                    <li class="flex items-start">
                        <i class="fas fa-network-wired text-medium mt-1 mr-2"></i>
                        <span>Found ${multiMissionAssets.length} assets shared across multiple business units. Top shared asset: <strong>${multiMissionAssets[0][0]}</strong> (${multiMissionAssets[0][1].missions.size} business units).</span>
                    </li>
                    ` : ''}
                    <li class="flex items-start">
                        <i class="fas fa-server text-blue-600 mt-1 mr-2"></i>
                        <span>Total assets with vulnerabilities: <strong>${Object.keys(assetRiskScores).length}</strong></span>
                    </li>
                    <li class="flex items-start">
                        <i class="fas fa-lightbulb text-yellow-500 mt-1 mr-2"></i>
                        <span>Recommendation: Prioritize remediation of high-risk assets, especially those with critical vulnerabilities or those shared across multiple business units.</span>
                    </li>
                </ul>
            </div>
        `;
    }

    // Render vulnerability aging
    function renderVulnerabilityAging(agingData) {
        const vulnerabilityAging = document.getElementById('vulnerabilityAging');
        
        if (!agingData || !agingData.ageCounts) {
            vulnerabilityAging.innerHTML = `
                <div class="p-6">
                    <h2 class="text-2xl font-bold mb-4">Vulnerability Aging</h2>
                    <div class="bg-gray-50 p-6 rounded-lg text-center">
                        <i class="fas fa-info-circle text-4xl text-gray-400 mb-4"></i>
                        <p class="text-gray-700">No vulnerability aging data available.</p>
                    </div>
                </div>
            `;
            return;
        }
        
        let html = `
            <div class="p-6">
                <h2 class="text-2xl font-bold mb-4">Vulnerability Aging</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Age Distribution</h3>
                        <div class="chart-container">
                            <canvas id="vulnerabilityAgingChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Aging Metrics</h3>
                        <div class="grid grid-cols-2 gap-4">
                            ${renderAgingMetricCards(agingData)}
                        </div>
                    </div>
                </div>
                <div class="mt-6">
                    <h3 class="text-xl font-semibold mb-3">Oldest Vulnerabilities</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full bg-white">
                            <thead>
                                <tr>
                                    <th class="py-2 px-4 border-b border-gray-200">Vulnerability</th>
                                    <th class="py-2 px-4 border-b border-gray-200">IP Address</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Severity</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Business Unit</th>
                                    <th class="py-2 px-4 border-b border-gray-200">Age (days)</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${renderOldestVulnerabilities(agingData.persisting)}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        `;
        
        vulnerabilityAging.innerHTML = html;
        
        renderVulnerabilityAgingChart(agingData.ageCounts);
    }

    // Render vulnerability aging chart
    function renderVulnerabilityAgingChart(ageCounts) {
        const ctx = document.getElementById('vulnerabilityAgingChart').getContext('2d');
        
        // Create chart
        modalCharts.vulnerabilityAging = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: Object.keys(ageCounts),
                datasets: [{
                    data: Object.values(ageCounts),
                    backgroundColor: [
                        'rgba(34, 197, 94, 0.7)',
                        'rgba(234, 179, 8, 0.7)',
                        'rgba(249, 115, 22, 0.7)',
                        'rgba(239, 68, 68, 0.7)'
                    ],
                    borderColor: [
                        'rgb(34, 197, 94)',
                        'rgb(234, 179, 8)',
                        'rgb(249, 115, 22)',
                        'rgb(239, 68, 68)'
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(1);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Render aging metric cards
    function renderAgingMetricCards(agingData) {
        const totalPersisting = agingData.persisting.length;
        const averageAge = agingData.averageAge || 0;
        
        // Count persist vulnerabilities by severity
        const severityCounts = {
            Critical: 0,
            High: 0,
            Medium: 0,
            Low: 0
        };
        
        agingData.persisting.forEach(vuln => {
            const severity = vuln.SEVERITY || 'Unknown';
            if (severityCounts[severity] !== undefined) {
                severityCounts[severity]++;
            }
        });
        
        // Calculate oldest vulnerability
        const oldestVuln = Math.max(...agingData.persisting.map(v => v.simulatedAge || 0));
        
        return `
            <div class="bg-white p-4 rounded-lg shadow-sm bg-blue-50">
                <h4 class="text-sm font-semibold mb-2">Persistent Vulnerabilities</h4>
                <p class="text-2xl font-bold">${totalPersisting}</p>
                <p class="text-sm text-gray-600">Across all systems</p>
            </div>
            <div class="bg-white p-4 rounded-lg shadow-sm bg-yellow-50">
                <h4 class="text-sm font-semibold mb-2">Average Age</h4>
                <p class="text-2xl font-bold">${averageAge.toFixed(1)} days</p>
                <p class="text-sm text-gray-600">Per vulnerability</p>
            </div>
            <div class="bg-white p-4 rounded-lg shadow-sm bg-red-50">
                <h4 class="text-sm font-semibold mb-2">Oldest Vulnerability</h4>
                <p class="text-2xl font-bold">${oldestVuln} days</p>
                <p class="text-sm text-gray-600">Maximum age</p>
            </div>
            <div class="bg-white p-4 rounded-lg shadow-sm bg-purple-50">
                <h4 class="text-sm font-semibold mb-2">Critical Persisting</h4>
                <p class="text-2xl font-bold">${severityCounts.Critical}</p>
                <p class="text-sm text-gray-600">High-risk issues</p>
            </div>
        `;
    }

    // Render oldest vulnerabilities
    function renderOldestVulnerabilities(persistingVulns) {
        if (!persistingVulns || persistingVulns.length === 0) {
            return `
                <tr>
                    <td colspan="5" class="py-4 text-center text-gray-500">No persisting vulnerabilities found</td>
                </tr>
            `;
        }
        
        // Sort by age (descending)
        const sortedVulns = [...persistingVulns]
            .sort((a, b) => (b.simulatedAge || 0) - (a.simulatedAge || 0))
            .slice(0, 10);
        
        return sortedVulns.map(vuln => `
            <tr class="hover:bg-gray-50">
                <td class="py-2 px-4 border-b border-gray-200 font-medium">${vuln['PLUGIN NAME'] || 'N/A'}</td>
                <td class="py-2 px-4 border-b border-gray-200">${vuln['IP ADDRESS'] || 'N/A'}</td>
                <td class="py-2 px-4 border-b border-gray-200 ${getSeverityTextClass(vuln.SEVERITY || 'Unknown')}">${vuln.SEVERITY || 'Unknown'}</td>
                <td class="py-2 px-4 border-b border-gray-200">${vuln.MISSION || 'Unknown'}</td>
                <td class="py-2 px-4 border-b border-gray-200">${vuln.simulatedAge || 'N/A'}</td>
            </tr>
        `).join('');
    }

    // Render predictive analysis
    function renderPredictiveAnalysis(data) {
        const predictiveAnalysis = document.getElementById('predictiveAnalysis');
        
        if (!data.predictions) {
            predictiveAnalysis.innerHTML = `
                <div class="p-6">
                    <h2 class="text-2xl font-bold mb-4">Predictive Analysis</h2>
                    <div class="bg-gray-50 p-6 rounded-lg text-center">
                        <i class="fas fa-info-circle text-4xl text-gray-400 mb-4"></i>
                        <p class="text-gray-700">Predictive analysis data not available.</p>
                    </div>
                </div>
            `;
            return;
        }
        
        const predictions = data.predictions;
        const current = data.executiveSummary.current;
        
        let html = `
            <div class="p-6">
                <h2 class="text-2xl font-bold mb-4">Predictive Analysis <span class="text-sm font-normal text-gray-600 ml-2">(Confidence: ${(predictions.nextScan.confidence * 100).toFixed(0)}%)</span></h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Vulnerability Forecast</h3>
                        <div class="chart-container">
                            <canvas id="vulnerabilityForecastChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Risk Score Prediction</h3>
                        <div class="chart-container">
                            <canvas id="riskScoreForecastChart"></canvas>
                        </div>
                    </div>
                </div>
                <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Remediation Timeline</h3>
                        <div class="bg-white p-4 rounded-lg shadow">
                            <table class="min-w-full">
                                <thead>
                                    <tr>
                                        <th class="py-2 text-left">Severity</th>
                                        <th class="py-2 text-left">Current Count</th>
                                        <th class="py-2 text-left">Estimated Days to Remediate</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td class="py-2 text-critical font-medium">Critical</td>
                                        <td class="py-2">${current.criticalVulnerabilities}</td>
                                        <td class="py-2">${predictions.timeToRemediate.critical}</td>
                                    </tr>
                                    <tr>
                                        <td class="py-2 text-high font-medium">High</td>
                                        <td class="py-2">${current.highVulnerabilities}</td>
                                        <td class="py-2">${predictions.timeToRemediate.high}</td>
                                    </tr>
                                    <tr>
                                        <td class="py-2 text-medium font-medium">Medium</td>
                                        <td class="py-2">${current.mediumVulnerabilities}</td>
                                        <td class="py-2">${predictions.timeToRemediate.medium}</td>
                                    </tr>
                                    <tr>
                                        <td class="py-2 text-low font-medium">Low</td>
                                        <td class="py-2">${current.lowVulnerabilities}</td>
                                        <td class="py-2">${predictions.timeToRemediate.low}</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Prediction Insights</h3>
                        ${renderPredictionInsights(data)}
                    </div>
                </div>
            </div>
        `;
        
        predictiveAnalysis.innerHTML = html;
        
        renderVulnerabilityForecastChart(data);
        renderRiskScoreForecastChart(data);
    }

    // Render vulnerability forecast chart
    function renderVulnerabilityForecastChart(data) {
        const ctx = document.getElementById('vulnerabilityForecastChart').getContext('2d');
        
        const labels = ['Current', 'Predicted'];
        const current = data.executiveSummary.current;
        const predicted = data.predictions.nextScan;
        
        // Create chart
        modalCharts.vulnerabilityForecast = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Critical',
                        data: [current.criticalVulnerabilities, predicted.critical],
                        backgroundColor: ['rgba(239, 68, 68, 0.7)', 'rgba(239, 68, 68, 0.4)'],
                        borderColor: ['rgb(239, 68, 68)', 'rgb(239, 68, 68)'],
                        borderWidth: 1
                    },
                    {
                        label: 'High',
                        data: [current.highVulnerabilities, predicted.high],
                        backgroundColor: ['rgba(249, 115, 22, 0.7)', 'rgba(249, 115, 22, 0.4)'],
                        borderColor: ['rgb(249, 115, 22)', 'rgb(249, 115, 22)'],
                        borderWidth: 1
                    },
                    {
                        label: 'Medium',
                        data: [current.mediumVulnerabilities, predicted.medium],
                        backgroundColor: ['rgba(234, 179, 8, 0.7)', 'rgba(234, 179, 8, 0.4)'],
                        borderColor: ['rgb(234, 179, 8)', 'rgb(234, 179, 8)'],
                        borderWidth: 1
                    },
                    {
                        label: 'Low',
                        data: [current.lowVulnerabilities, predicted.low],
                        backgroundColor: ['rgba(34, 197, 94, 0.7)', 'rgba(34, 197, 94, 0.4)'],
                        borderColor: ['rgb(34, 197, 94)', 'rgb(34, 197, 94)'],
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        stacked: true
                    },
                    y: {
                        stacked: true,
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Vulnerability Count'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    label += context.parsed.y.toLocaleString();
                                }
                                return label;
                            }
                        }
                    }
                }
            }
        });
    }

    // Render risk score forecast chart
    function renderRiskScoreForecastChart(data) {
        const ctx = document.getElementById('riskScoreForecastChart').getContext('2d');
        
        const current = data.executiveSummary.current;
        const predicted = data.predictions.nextScan;
        
        // Create chart
        modalCharts.riskScoreForecast = new Chart(ctx, {
            type: 'line',
            data: {
                labels: ['Current', 'Predicted'],
                datasets: [
                    {
                        label: 'Risk Score',
                        data: [current.riskScore, predicted.riskScore],
                        backgroundColor: 'rgba(99, 102, 241, 0.1)',
                        borderColor: 'rgb(99, 102, 241)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointBackgroundColor: ['rgb(99, 102, 241)', 'rgba(99, 102, 241, 0.5)'],
                        pointRadius: 6,
                        pointHoverRadius: 8
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Risk Score'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Risk Score: ${context.raw.toFixed(1)}`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Render prediction insights
    function renderPredictionInsights(data) {
        const predictions = data.predictions;
        const current = data.executiveSummary.current;
        
        const totalChange = predictions.nextScan.total - current.totalVulnerabilities;
        const criticalChange = predictions.nextScan.critical - current.criticalVulnerabilities;
        const riskScoreChange = predictions.nextScan.riskScore - current.riskScore;
        
        let trendIcon, trendClass, trendText;
        if (predictions.riskTrend === 'increasing') {
            trendIcon = 'fa-arrow-trend-up';
            trendClass = 'text-critical';
            trendText = 'increasing';
        } else if (predictions.riskTrend === 'decreasing') {
            trendIcon = 'fa-arrow-trend-down';
            trendClass = 'text-low';
            trendText = 'decreasing';
        } else {
            trendIcon = 'fa-equals';
            trendClass = 'text-medium';
            trendText = 'stable';
        }
        
        return `
            <div class="bg-gray-50 p-4 rounded-lg">
                <ul class="space-y-2">
                    <li class="flex items-start">
                        <i class="fas ${trendIcon} ${trendClass} mt-1 mr-2"></i>
                        <span>Overall risk trend is <strong>${trendText}</strong> with a projected ${riskScoreChange > 0 ? 'increase' : 'decrease'} of ${Math.abs(riskScoreChange).toFixed(1)} points.</span>
                    </li>
                    <li class="flex items-start">
                        <i class="fas fa-chart-line ${totalChange > 0 ? 'text-critical' : 'text-low'} mt-1 mr-2"></i>
                        <span>Total vulnerabilities are projected to ${totalChange > 0 ? 'increase' : 'decrease'} by ${Math.abs(totalChange)} (${Math.abs((totalChange / current.totalVulnerabilities) * 100).toFixed(1)}%).</span>
                    </li>
                    <li class="flex items-start">
                        <i class="fas fa-exclamation-triangle ${criticalChange > 0 ? 'text-critical' : 'text-low'} mt-1 mr-2"></i>
                        <span>Critical vulnerabilities are projected to ${criticalChange > 0 ? 'increase' : 'decrease'} by ${Math.abs(criticalChange)} (${Math.abs((criticalChange / (current.criticalVulnerabilities || 1)) * 100).toFixed(1)}%).</span>
                    </li>
                    <li class="flex items-start">
                        <i class="fas fa-calendar-day text-blue-600 mt-1 mr-2"></i>
                        <span>Estimated time to remediate all current vulnerabilities: <strong>${Math.max(predictions.timeToRemediate.critical, predictions.timeToRemediate.high, predictions.timeToRemediate.medium, predictions.timeToRemediate.low)} days</strong>.</span>
                    </li>
                    <li class="flex items-start">
                        <i class="fas fa-lightbulb text-yellow-500 mt-1 mr-2"></i>
                        <span>Recommendation: ${predictions.riskTrend === 'increasing' ? 
                        'Increase remediation capacity to address the growing security risk, focusing on critical vulnerabilities first.' : 
                        predictions.riskTrend === 'decreasing' ? 
                        'Continue current remediation efforts to maintain the positive security trend.' : 
                        'Maintain current remediation pace while focusing efforts on critical and high-severity issues.'}</span>
                    </li>
                </ul>
            </div>
        `;
    }

    // Render recommended actions
    function renderRecommendedActions(recommendations) {
        const recommendedActions = document.getElementById('recommendedActions');
        
        if (!recommendations) {
            recommendedActions.classList.add('hidden');
            return;
        }
        
        let html = `
            <div class="p-6">
                <h2 class="text-2xl font-bold mb-4">Recommended Actions</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Critical Actions</h3>
                        <div class="space-y-3">
                            ${renderRecommendationCards(recommendations.critical, 'critical')}
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Important Actions</h3>
                        <div class="space-y-3">
                            ${renderRecommendationCards(recommendations.high, 'high')}
                        </div>
                    </div>
                </div>
                <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Strategic Actions</h3>
                        <div class="space-y-3">
                            ${renderRecommendationCards(recommendations.medium, 'medium')}
                            ${renderRecommendationCards(recommendations.general, 'general')}
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-3">Action Prioritization Matrix</h3>
                        <div class="chart-container">
                            <canvas id="actionPrioritizationChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        recommendedActions.innerHTML = html;
        
        renderActionPrioritizationChart(recommendations);
    }

    // Render recommendation cards
    function renderRecommendationCards(recommendations, type) {
        if (!recommendations || recommendations.length === 0) {
            return `<div class="p-4 bg-gray-50 text-gray-500 text-center rounded-lg">No ${type} actions recommended</div>`;
        }
        
        let colorClass;
        switch(type) {
            case 'critical': colorClass = 'border-critical'; break;
            case 'high': colorClass = 'border-high'; break;
            case 'medium': colorClass = 'border-medium'; break;
            default: colorClass = 'border-indigo-500';
        }
        
        return recommendations.map(rec => `
            <div class="p-4 bg-white rounded-lg shadow-sm border-l-4 ${colorClass}">
                <h4 class="font-bold">${rec.title}</h4>
                <p class="text-sm text-gray-700 mt-1">${rec.description}</p>
                <div class="flex mt-2 text-xs">
                    <span class="mr-2"><strong>Impact:</strong> ${rec.impact}</span>
                    <span class="mr-2"><strong>Effort:</strong> ${rec.effort}</span>
                    <span><strong>ROI:</strong> ${rec.roi}</span>
                </div>
            </div>
        `).join('');
    }

    // Render action prioritization chart
    function renderActionPrioritizationChart(recommendations) {
        const ctx = document.getElementById('actionPrioritizationChart').getContext('2d');
        
        // Combine all recommendations
        const allRecs = [
            ...recommendations.critical.map(r => ({ ...r, type: 'Critical' })),
            ...recommendations.high.map(r => ({ ...r, type: 'High' })),
            ...recommendations.medium.map(r => ({ ...r, type: 'Medium' })),
            ...recommendations.general.map(r => ({ ...r, type: 'General' }))
        ];
        
        // Create data for the chart
        const data = allRecs.map(rec => {
            // Map impact/effort/roi to numeric values
            const impactValue = mapValueToNumber(rec.impact);
            const effortValue = mapValueToNumber(rec.effort);
            const roiValue = mapValueToNumber(rec.roi);
            
            // Calculate priority score
            const priorityScore = (impactValue + roiValue) / effortValue;
            
            return {
                x: effortValue,
                y: impactValue,
                r: priorityScore * 5, // Size based on priority score
                title: rec.title,
                type: rec.type
            };
        });
        
        // Create chart
        modalCharts.actionPrioritization = new Chart(ctx, {
            type: 'bubble',
            data: {
                datasets: [
                    {
                        label: 'Critical',
                        data: data.filter(d => d.type === 'Critical'),
                        backgroundColor: 'rgba(239, 68, 68, 0.5)',
                        borderColor: 'rgb(239, 68, 68)',
                        borderWidth: 1
                    },
                    {
                        label: 'High',
                        data: data.filter(d => d.type === 'High'),
                        backgroundColor: 'rgba(249, 115, 22, 0.5)',
                        borderColor: 'rgb(249, 115, 22)',
                        borderWidth: 1
                    },
                    {
                        label: 'Medium',
                        data: data.filter(d => d.type === 'Medium'),
                        backgroundColor: 'rgba(234, 179, 8, 0.5)',
                        borderColor: 'rgb(234, 179, 8)',
                        borderWidth: 1
                    },
                    {
                        label: 'General',
                        data: data.filter(d => d.type === 'General'),
                        backgroundColor: 'rgba(99, 102, 241, 0.5)',
                        borderColor: 'rgb(99, 102, 241)',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Effort'
                        },
                        min: 0,
                        max: 10,
                        ticks: {
                            callback: function(value) {
                                return mapNumberToValue(value, 'effort');
                            }
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Impact'
                        },
                        min: 0,
                        max: 10,
                        ticks: {
                            callback: function(value) {
                                return mapNumberToValue(value, 'impact');
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const item = context.raw;
                                return [
                                    item.title,
                                    `Impact: ${mapNumberToValue(item.y, 'impact')}`,
                                    `Effort: ${mapNumberToValue(item.x, 'effort')}`,
                                    `Priority: ${(item.r / 5).toFixed(1)}`
                                ];
                            }
                        }
                    }
                }
            }
        });
    }

    // Map text value to number for chart positioning
    function mapValueToNumber(value) {
        if (!value) return 5;
        
        switch(value.toLowerCase()) {
            case 'very low': return 1;
            case 'low': return 3;
            case 'medium': return 5;
            case 'high': return 8;
            case 'very high': return 10;
            default: return 5;
        }
    }

    // Map number back to text value
    function mapNumberToValue(number, type) {
        if (number <= 2) return 'Very Low';
        if (number <= 4) return 'Low';
        if (number <= 6) return 'Medium';
        if (number <= 8) return 'High';
        return 'Very High';
    }

    // Open modal
    function openModal(modalId) {
        const modalOverlay = document.getElementById('modalOverlay');
        const modalTitle = document.getElementById('modalTitle');
        const modalBody = document.getElementById('modalBody');
        
        modalOverlay.style.display = 'flex';
        modalBody.innerHTML = '<div class="text-center p-8"><i class="fas fa-spinner fa-spin fa-2x mb-4"></i><p>Loading...</p></div>';

        requestAnimationFrame(() => {
            let content = '';
            switch(modalId) {
                case 'trendAnalysisModal':
                    modalTitle.textContent = 'Advanced Trend Analysis';
                    content = renderTrendAnalysisModal();
                    break;
                case 'predictiveAnalyticsModal':
                    modalTitle.textContent = 'AI-Powered Predictive Analytics';
                    content = renderPredictiveAnalyticsModal();
                    break;
                case 'riskScoreModal':
                    modalTitle.textContent = 'Risk Score Breakdown';
                    content = renderRiskScoreModal();
                    break;
                case 'comparativeAnalysisModal':
                    modalTitle.textContent = 'Comparative Analysis';
                    content = renderComparativeAnalysisModal();
                    break;
                default:
                    modalTitle.textContent = 'Unknown Modal';
                    content = '<p>No content available for this modal.</p>';
            }
            
            modalBody.innerHTML = content;

            // Initialize charts and add event listeners
            switch(modalId) {
                case 'trendAnalysisModal':
                    initializeTrendAnalysisModal();
                    break;
                case 'predictiveAnalyticsModal':
                    initializePredictiveAnalyticsModal();
                    break;
                case 'riskScoreModal':
                    initializeRiskScoreModal();
                    break;
                case 'comparativeAnalysisModal':
                    initializeComparativeAnalysisModal();
                    break;
            }
        });
    }

    // Close modal
    function closeModal() {
        const modalOverlay = document.getElementById('modalOverlay');
        modalOverlay.style.display = 'none';
        
        // Destroy any charts in the modal to prevent memory leaks
        Object.keys(modalCharts).forEach(key => {
            if (key.startsWith('modal') && modalCharts[key]) {
                modalCharts[key].destroy();
                delete modalCharts[key];
            }
        });
    }

    // Render trend analysis modal
    function renderTrendAnalysisModal() {
        return `
            <div class="tabs">
                <div class="tab active" data-tab="overallTrend">Overall Trend</div>
                <div class="tab" data-tab="severityTrend">Severity Trend</div>
                <div class="tab" data-tab="missionTrend">Business Unit Trend</div>
                <div class="tab" data-tab="remediationTrend">Remediation Trend</div>
            </div>
            
            <div class="tab-content active" id="overallTrend">
                <div class="chart-container">
                    <canvas id="modalOverallTrendChart"></canvas>
                </div>
                <div class="mt-4 text-sm text-gray-600">
                    <p>This chart shows the overall vulnerability trend across all scans, broken down by severity level.</p>
                </div>
            </div>
            
            <div class="tab-content" id="severityTrend">
                <div class="chart-container">
                    <canvas id="modalSeverityTrendChart"></canvas>
                </div>
                <div class="mt-4 text-sm text-gray-600">
                    <p>This chart shows the trend of each severity level independently across all scans.</p>
                </div>
            </div>
            
            <div class="tab-content" id="missionTrend">
                <div class="chart-container">
                    <canvas id="modalMissionTrendChart"></canvas>
                </div>
                <div class="mt-4 text-sm text-gray-600">
                    <p>This chart shows the trend of vulnerabilities by business unit across all scans.</p>
                </div>
            </div>
            
            <div class="tab-content" id="remediationTrend">
                <div class="chart-container">
                    <canvas id="modalRemediationTrendChart"></canvas>
                </div>
                <div class="mt-4 text-sm text-gray-600">
                    <p>This chart shows the remediation trend, tracking new vs. remediated vulnerabilities over time.</p>
                </div>
            </div>
            
            <div class="flex justify-end space-x-2 mt-4">
                <button id="downloadTrendChart" class="btn btn-secondary flex items-center">
                    <i class="fas fa-download mr-2"></i>Download Chart
                </button>
                <button id="exportTrendData" class="btn btn-primary flex items-center">
                    <i class="fas fa-file-export mr-2"></i>Export Data
                </button>
            </div>
        `;
    }

    // Initialize trend analysis modal
    function initializeTrendAnalysisModal() {
        // Setup tab switching
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabs.forEach(tab => {
            tab.addEventListener('click', function() {
                // Remove active class from all tabs and tab contents
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(c => c.classList.remove('active'));
                
                // Add active class to the clicked tab and corresponding content
                this.classList.add('active');
                document.getElementById(this.dataset.tab).classList.add('active');
                
                // Redraw charts to fix any rendering issues
                if (this.dataset.tab === 'overallTrend') renderModalOverallTrendChart();
                if (this.dataset.tab === 'severityTrend') renderModalSeverityTrendChart();
                if (this.dataset.tab === 'missionTrend') renderModalMissionTrendChart();
                if (this.dataset.tab === 'remediationTrend') renderModalRemediationTrendChart();
            });
        });
        
        // Render initial charts
        renderModalOverallTrendChart();
        
        // Setup download button
        document.getElementById('downloadTrendChart').addEventListener('click', function() {
            const activeTab = document.querySelector('.tab.active').dataset.tab;
            let chartId;
            
            switch(activeTab) {
                case 'overallTrend': chartId = 'modalOverallTrendChart'; break;
                case 'severityTrend': chartId = 'modalSeverityTrendChart'; break;
                case 'missionTrend': chartId = 'modalMissionTrendChart'; break;
                case 'remediationTrend': chartId = 'modalRemediationTrendChart'; break;
            }
            
            if (chartId) downloadChart(chartId);
        });
        
        // Setup export button
        document.getElementById('exportTrendData').addEventListener('click', function() {
            const activeTab = document.querySelector('.tab.active').dataset.tab;
            exportTrendData(activeTab);
        });
    }

    // Render overall trend chart
    function renderModalOverallTrendChart() {
        const ctx = document.getElementById('modalOverallTrendChart').getContext('2d');
        
        // Get all time points (current and previous scans)
        const timePoints = ['Current'].concat(
            previousVulnerabilityData.map(pv => pv.label || 'Previous')
        );
        
        // Get data for each severity level
        const datasets = [
            {
                label: 'Critical',
                data: [processedData.executiveSummary.current.criticalVulnerabilities].concat(
                    processedData.executiveSummary.previous.map(prev => prev.criticalVulnerabilities)
                ),
                backgroundColor: 'rgba(239, 68, 68, 0.7)',
                borderColor: 'rgb(239, 68, 68)',
                borderWidth: 2
            },
            {
                label: 'High',
                data: [processedData.executiveSummary.current.highVulnerabilities].concat(
                    processedData.executiveSummary.previous.map(prev => prev.highVulnerabilities)
                ),
                backgroundColor: 'rgba(249, 115, 22, 0.7)',
                borderColor: 'rgb(249, 115, 22)',
                borderWidth: 2
            },
            {
                label: 'Medium',
                data: [processedData.executiveSummary.current.mediumVulnerabilities].concat(
                    processedData.executiveSummary.previous.map(prev => prev.mediumVulnerabilities)
                ),
                backgroundColor: 'rgba(234, 179, 8, 0.7)',
                borderColor: 'rgb(234, 179, 8)',
                borderWidth: 2
            },
            {
                label: 'Low',
                data: [processedData.executiveSummary.current.lowVulnerabilities].concat(
                    processedData.executiveSummary.previous.map(prev => prev.lowVulnerabilities)
                ),
                backgroundColor: 'rgba(34, 197, 94, 0.7)',
                borderColor: 'rgb(34, 197, 94)',
                borderWidth: 2
            }
        ];

        // Create chart
        if (modalCharts.modalOverallTrend) {
            modalCharts.modalOverallTrend.destroy();
        }
        
        modalCharts.modalOverallTrend = new Chart(ctx, {
            type: 'bar',
            data: { 
                labels: timePoints,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        stacked: true,
                        title: {
                            display: true,
                            text: 'Scan Period'
                        }
                    },
                    y: {
                        stacked: true,
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Vulnerability Count'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    label += context.parsed.y.toLocaleString();
                                }
                                return label;
                            }
                        }
                    }
                }
            }
        });
    }

    // Render severity trend chart
    function renderModalSeverityTrendChart() {
        const ctx = document.getElementById('modalSeverityTrendChart').getContext('2d');
        
        // Get all time points (current and previous scans)
        const timePoints = ['Current'].concat(
            previousVulnerabilityData.map(pv => pv.label || 'Previous')
        ).reverse(); // Reverse to show chronological order
        
        // Get data for each severity level
        const datasets = [
            {
                label: 'Critical',
                data: [processedData.executiveSummary.current.criticalVulnerabilities].concat(
                    processedData.executiveSummary.previous.map(prev => prev.criticalVulnerabilities)
                ).reverse(),
                borderColor: 'rgb(239, 68, 68)',
                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                borderWidth: 3,
                fill: true,
                tension: 0.3
            },
            {
                label: 'High',
                data: [processedData.executiveSummary.current.highVulnerabilities].concat(
                    processedData.executiveSummary.previous.map(prev => prev.highVulnerabilities)
                ).reverse(),
                borderColor: 'rgb(249, 115, 22)',
                backgroundColor: 'rgba(249, 115, 22, 0.1)',
                borderWidth: 3,
                fill: true,
                tension: 0.3
            },
            {
                label: 'Medium',
                data: [processedData.executiveSummary.current.mediumVulnerabilities].concat(
                    processedData.executiveSummary.previous.map(prev => prev.mediumVulnerabilities)
                ).reverse(),
                borderColor: 'rgb(234, 179, 8)',
                backgroundColor: 'rgba(234, 179, 8, 0.1)',
                borderWidth: 3,
                fill: true,
                tension: 0.3
            },
            {
                label: 'Low',
                data: [processedData.executiveSummary.current.lowVulnerabilities].concat(
                    processedData.executiveSummary.previous.map(prev => prev.lowVulnerabilities)
                ).reverse(),
                borderColor: 'rgb(34, 197, 94)',
                backgroundColor: 'rgba(34, 197, 94, 0.1)',
                borderWidth: 3,
                fill: true,
                tension: 0.3
            }
        ];

        // Create chart
        if (modalCharts.modalSeverityTrend) {
            modalCharts.modalSeverityTrend.destroy();
        }
        
        modalCharts.modalSeverityTrend = new Chart(ctx, {
            type: 'line',
            data: { 
                labels: timePoints,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Scan Period'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Vulnerability Count'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    }
                }
            }
        });
    }

    // Render mission trend chart
    function renderModalMissionTrendChart() {
        const ctx = document.getElementById('modalMissionTrendChart').getContext('2d');
        
        // Get top 5 missions by total vulnerability count
        const topMissions = Array.from(processedData.missionAnalysis.current.entries())
            .map(([mission, data]) => ({
                mission,
                count: data.totalVulnerabilities
            }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 5)
            .map(item => item.mission);
        
        // Get all time points (current and previous scans)
        const timePoints = ['Current'].concat(
            previousVulnerabilityData.map(pv => pv.label || 'Previous')
        ).reverse(); // Reverse to show chronological order
        
        // Generate datasets for each mission
        const datasets = topMissions.map(mission => {
            // Get current count
            const currentCount = processedData.missionAnalysis.current.has(mission) ? 
                processedData.missionAnalysis.current.get(mission).totalVulnerabilities : 0;
                
            // Get previous counts
            const previousCounts = processedData.missionAnalysis.previous.map(prev => 
                prev.has(mission) ? prev.get(mission).totalVulnerabilities : 0
            );
            
            // Generate random color
            const r = Math.floor(Math.random() * 200);
            const g = Math.floor(Math.random() * 200);
            const b = Math.floor(Math.random() * 200);
            
            return {
                label: mission,
                data: [currentCount].concat(previousCounts).reverse(),
                borderColor: `rgb(${r}, ${g}, ${b})`,
                backgroundColor: `rgba(${r}, ${g}, ${b}, 0.1)`,
                borderWidth: 3,
                fill: true,
                tension: 0.3
            };
        });

        // Create chart
        if (modalCharts.modalMissionTrend) {
            modalCharts.modalMissionTrend.destroy();
        }
        
        modalCharts.modalMissionTrend = new Chart(ctx, {
            type: 'line',
            data: { 
                labels: timePoints,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Scan Period'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Vulnerability Count'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    }
                }
            }
        });
    }

    // Render remediation trend chart
    function renderModalRemediationTrendChart() {
        const ctx = document.getElementById('modalRemediationTrendChart').getContext('2d');
        
        // Calculate new and remediated counts for each period
        const newCounts = [processedData.diffAnalysis.new.length];
        const remediatedCounts = [processedData.diffAnalysis.remediated.length];
        
        // Get all time points (current and previous scans)
        const timePoints = ['Current'].concat(
            previousVulnerabilityData.map(pv => pv.label || 'Previous')
        ).reverse(); // Reverse to show chronological order
        
        // Create chart
        if (modalCharts.modalRemediationTrend) {
            modalCharts.modalRemediationTrend.destroy();
        }
        
        modalCharts.modalRemediationTrend = new Chart(ctx, {
            type: 'bar',
            data: { 
                labels: timePoints,
                datasets: [
                    {
                        label: 'New Vulnerabilities',
                        data: newCounts,
                        backgroundColor: 'rgba(239, 68, 68, 0.7)',
                        borderColor: 'rgb(239, 68, 68)',
                        borderWidth: 1
                    },
                    {
                        label: 'Remediated Vulnerabilities',
                        data: remediatedCounts,
                        backgroundColor: 'rgba(34, 197, 94, 0.7)',
                        borderColor: 'rgb(34, 197, 94)',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Scan Period'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Vulnerability Count'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    }
                }
            }
        });
    }

    // Export trend data
    function exportTrendData(activeTab) {
        let data = [];
        let filename = 'trend_analysis_data.csv';
        
        switch(activeTab) {
            case 'overallTrend':
                data = exportOverallTrendData();
                filename = 'overall_trend_data.csv';
                break;
            case 'severityTrend':
                data = exportSeverityTrendData();
                filename = 'severity_trend_data.csv';
                break;
            case 'missionTrend':
                data = exportMissionTrendData();
                filename = 'mission_trend_data.csv';
                break;
            case 'remediationTrend':
                data = exportRemediationTrendData();
                filename = 'remediation_trend_data.csv';
                break;
        }
        
        exportToCSV(data, filename);
    }

    // Export overall trend data
    function exportOverallTrendData() {
        const timePoints = ['Current'].concat(
            previousVulnerabilityData.map(pv => pv.label || 'Previous')
        );
        
        return [
            { Period: 'Critical', ...Object.fromEntries(timePoints.map((period, i) => [
                period, 
                i === 0 ? processedData.executiveSummary.current.criticalVulnerabilities :
                processedData.executiveSummary.previous[i - 1].criticalVulnerabilities
            ])) },
            { Period: 'High', ...Object.fromEntries(timePoints.map((period, i) => [
                period, 
                i === 0 ? processedData.executiveSummary.current.highVulnerabilities :
                processedData.executiveSummary.previous[i - 1].highVulnerabilities
            ])) },
            { Period: 'Medium', ...Object.fromEntries(timePoints.map((period, i) => [
                period, 
                i === 0 ? processedData.executiveSummary.current.mediumVulnerabilities :
                processedData.executiveSummary.previous[i - 1].mediumVulnerabilities
            ])) },
            { Period: 'Low', ...Object.fromEntries(timePoints.map((period, i) => [
                period, 
                i === 0 ? processedData.executiveSummary.current.lowVulnerabilities :
                processedData.executiveSummary.previous[i - 1].lowVulnerabilities
            ])) }
        ];
    }

    // Export severity trend data
    function exportSeverityTrendData() {
        return exportOverallTrendData(); // Same data structure
    }

    // Export mission trend data
    function exportMissionTrendData() {
        const timePoints = ['Current'].concat(
            previousVulnerabilityData.map(pv => pv.label || 'Previous')
        );
        
        // Get all missions
        const missions = new Set();
        
        processedData.missionAnalysis.current.forEach((_, mission) => {
            missions.add(mission);
        });
        
        processedData.missionAnalysis.previous.forEach(prev => {
            prev.forEach((_, mission) => {
                missions.add(mission);
            });
        });
        
        return Array.from(missions).map(mission => {
            return {
                Mission: mission,
                ...Object.fromEntries(timePoints.map((period, i) => [
                    period, 
                    i === 0 ? 
                        (processedData.missionAnalysis.current.has(mission) ? 
                            processedData.missionAnalysis.current.get(mission).totalVulnerabilities : 0) :
                        (processedData.missionAnalysis.previous[i - 1].has(mission) ? 
                            processedData.missionAnalysis.previous[i - 1].get(mission).totalVulnerabilities : 0)
                ]))
            };
        });
    }

    // Export remediation trend data
    function exportRemediationTrendData() {
        const timePoints = ['Current'].concat(
            previousVulnerabilityData.map(pv => pv.label || 'Previous')
        );
        
        return [
            { Type: 'New Vulnerabilities', [timePoints[0]]: processedData.diffAnalysis.new.length },
            { Type: 'Remediated Vulnerabilities', [timePoints[0]]: processedData.diffAnalysis.remediated.length }
        ];
    }

    // Render predictive analytics modal
    function renderPredictiveAnalyticsModal() {
        return `
            <div class="tabs">
                <div class="tab active" data-tab="vulnerabilityPrediction">Vulnerability Prediction</div>
                <div class="tab" data-tab="riskScorePrediction">Risk Score Prediction</div>
                <div class="tab" data-tab="remediationPrediction">Remediation Timeline</div>
                <div class="tab" data-tab="trendPrediction">Trend Prediction</div>
            </div>
            
            <div class="tab-content active" id="vulnerabilityPrediction">
                <div class="chart-container">
                    <canvas id="modalVulnerabilityPredictionChart"></canvas>
                </div>
                <div class="mt-4 bg-indigo-50 p-4 rounded-lg">
                    <div class="flex items-start">
                        <i class="fas fa-robot text-indigo-700 text-xl mt-1 mr-3"></i>
                        <div>
                            <h3 class="font-bold text-lg text-indigo-700">AI Insights</h3>
                            <p class="text-sm text-gray-700" id="vulnerabilityPredictionInsight"></p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="riskScorePrediction">
                <div class="chart-container">
                    <canvas id="modalRiskScorePredictionChart"></canvas>
                </div>
                <div class="mt-4 bg-indigo-50 p-4 rounded-lg">
                    <div class="flex items-start">
                        <i class="fas fa-robot text-indigo-700 text-xl mt-1 mr-3"></i>
                        <div>
                            <h3 class="font-bold text-lg text-indigo-700">AI Insights</h3>
                            <p class="text-sm text-gray-700" id="riskScorePredictionInsight"></p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="remediationPrediction">
                <div class="chart-container">
                    <canvas id="modalRemediationPredictionChart"></canvas>
                </div>
                <div class="mt-4 bg-indigo-50 p-4 rounded-lg">
                    <div class="flex items-start">
                        <i class="fas fa-robot text-indigo-700 text-xl mt-1 mr-3"></i>
                        <div>
                            <h3 class="font-bold text-lg text-indigo-700">AI Insights</h3>
                            <p class="text-sm text-gray-700" id="remediationPredictionInsight"></p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="trendPrediction">
                <div class="chart-container">
                    <canvas id="modalTrendPredictionChart"></canvas>
                </div>
                <div class="mt-4 bg-indigo-50 p-4 rounded-lg">
                    <div class="flex items-start">
                        <i class="fas fa-robot text-indigo-700 text-xl mt-1 mr-3"></i>
                        <div>
                            <h3 class="font-bold text-lg text-indigo-700">AI Insights</h3>
                            <p class="text-sm text-gray-700" id="trendPredictionInsight"></p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="flex justify-end space-x-2 mt-4">
                <button id="downloadPredictionChart" class="btn btn-secondary flex items-center">
                    <i class="fas fa-download mr-2"></i>Download Chart
                </button>
                <button id="exportPredictionData" class="btn btn-primary flex items-center">
                    <i class="fas fa-file-export mr-2"></i>Export Data
                </button>
            </div>
        `;
    }

    // Initialize predictive analytics modal
    function initializePredictiveAnalyticsModal() {
        // Setup tab switching
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabs.forEach(tab => {
            tab.addEventListener('click', function() {
                // Remove active class from all tabs and tab contents
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(c => c.classList.remove('active'));
                
                // Add active class to the clicked tab and corresponding content
                this.classList.add('active');
                document.getElementById(this.dataset.tab).classList.add('active');
                
                // Redraw charts to fix any rendering issues
                if (this.dataset.tab === 'vulnerabilityPrediction') renderModalVulnerabilityPredictionChart();
                if (this.dataset.tab === 'riskScorePrediction') renderModalRiskScorePredictionChart();
                if (this.dataset.tab === 'remediationPrediction') renderModalRemediationPredictionChart();
                if (this.dataset.tab === 'trendPrediction') renderModalTrendPredictionChart();
            });
        });
        
        // Render initial charts
        renderModalVulnerabilityPredictionChart();
        
        // Setup download button
        document.getElementById('downloadPredictionChart').addEventListener('click', function() {
            const activeTab = document.querySelector('.tab.active').dataset.tab;
            let chartId;
            
            switch(activeTab) {
                case 'vulnerabilityPrediction': chartId = 'modalVulnerabilityPredictionChart'; break;
                case 'riskScorePrediction': chartId = 'modalRiskScorePredictionChart'; break;
                case 'remediationPrediction': chartId = 'modalRemediationPredictionChart'; break;
                case 'trendPrediction': chartId = 'modalTrendPredictionChart'; break;
            }
            
            if (chartId) downloadChart(chartId);
        });
        
        // Setup export button
        document.getElementById('exportPredictionData').addEventListener('click', function() {
            const activeTab = document.querySelector('.tab.active').dataset.tab;
            exportPredictionData(activeTab);
        });
    }

    // Render vulnerability prediction chart
    function renderModalVulnerabilityPredictionChart() {
        const ctx = document.getElementById('modalVulnerabilityPredictionChart').getContext('2d');
        
        if (!processedData.predictions) {
            document.getElementById('vulnerabilityPredictionInsight').textContent = 
                'Prediction data not available. Please ensure you have at least one previous scan for comparison.';
            return;
        }
        
        const current = processedData.executiveSummary.current;
        const predicted = processedData.predictions.nextScan;
        
        // Get time points
        const timePoints = [];
        
        // Add previous points (in reverse order)
        processedData.executiveSummary.previous.forEach((_, index) => {
            timePoints.push(previousVulnerabilityData[index].label || `Previous ${index + 1}`);
        });
        
        // Add current and future points
        timePoints.push('Current');
        timePoints.push('Next Scan (Predicted)');
        
        // Create datasets
        const datasets = [
            {
                label: 'Critical',
                data: [],
                backgroundColor: 'rgba(239, 68, 68, 0.7)',
                borderColor: 'rgb(239, 68, 68)',
                borderWidth: 1
            },
            {
                label: 'High',
                data: [],
                backgroundColor: 'rgba(249, 115, 22, 0.7)',
                borderColor: 'rgb(249, 115, 22)',
                borderWidth: 1
            },
            {
                label: 'Medium',
                data: [],
                backgroundColor: 'rgba(234, 179, 8, 0.7)',
                borderColor: 'rgb(234, 179, 8)',
                borderWidth: 1
            },
            {
                label: 'Low',
                data: [],
                backgroundColor: 'rgba(34, 197, 94, 0.7)',
                borderColor: 'rgb(34, 197, 94)',
                borderWidth: 1
            }
        ];
        
        // Add previous data points
        processedData.executiveSummary.previous.forEach(prev => {
            datasets[0].data.push(prev.criticalVulnerabilities);
            datasets[1].data.push(prev.highVulnerabilities);
            datasets[2].data.push(prev.mediumVulnerabilities);
            datasets[3].data.push(prev.lowVulnerabilities);
        });
        
        // Add current data point
        datasets[0].data.push(current.criticalVulnerabilities);
        datasets[1].data.push(current.highVulnerabilities);
        datasets[2].data.push(current.mediumVulnerabilities);
        datasets[3].data.push(current.lowVulnerabilities);
        
        // Add predicted data point
        datasets[0].data.push(predicted.critical);
        datasets[1].data.push(predicted.high);
        datasets[2].data.push(predicted.medium);
        datasets[3].data.push(predicted.low);

        // Create chart
        if (modalCharts.modalVulnerabilityPrediction) {
            modalCharts.modalVulnerabilityPrediction.destroy();
        }
        
        modalCharts.modalVulnerabilityPrediction = new Chart(ctx, {
            type: 'bar',
            data: { 
                labels: timePoints,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        stacked: true,
                        title: {
                            display: true,
                            text: 'Scan Period'
                        }
                    },
                    y: {
                        stacked: true,
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Vulnerability Count'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    label += context.parsed.y.toLocaleString();
                                }
                                return label;
                            }
                        }
                    }
                }
            }
        });
        
        // Update insight text
        document.getElementById('vulnerabilityPredictionInsight').innerHTML = 
            `Based on historical data with ${(predicted.confidence * 100).toFixed(0)}% confidence, we predict the next scan will find 
            <strong>${predicted.total}</strong> total vulnerabilities, including 
            <strong>${predicted.critical}</strong> critical and 
            <strong>${predicted.high}</strong> high severity issues. 
            This represents a ${predicted.total > current.totalVulnerabilities ? 'increase' : 'decrease'} of 
            ${Math.abs(predicted.total - current.totalVulnerabilities)} vulnerabilities (${((Math.abs(predicted.total - current.totalVulnerabilities) / current.totalVulnerabilities) * 100).toFixed(1)}%).
            ${predicted.total > current.totalVulnerabilities ? 
                'Without increasing remediation efforts, your organization\'s security risk will continue to grow.' : 
                'Current remediation efforts are effective, but continued vigilance is needed to maintain this positive trend.'}`;
    }

    // Render risk score prediction chart
    function renderModalRiskScorePredictionChart() {
        const ctx = document.getElementById('modalRiskScorePredictionChart').getContext('2d');
        
        if (!processedData.predictions) {
            document.getElementById('riskScorePredictionInsight').textContent = 
                'Prediction data not available. Please ensure you have at least one previous scan for comparison.';
            return;
        }
        
        const current = processedData.executiveSummary.current;
        const predicted = processedData.predictions.nextScan;
        
        // Get time points
        const timePoints = [];
        
        // Add previous points (in reverse order)
        processedData.executiveSummary.previous.forEach((prev, index) => {
            timePoints.push(previousVulnerabilityData[index].label || `Previous ${index + 1}`);
        });
        
        // Add current and future points
        timePoints.push('Current');
        timePoints.push('Next Scan (Predicted)');
        
        // Create dataset
        const data = [];
        
        // Add previous data points
        processedData.executiveSummary.previous.forEach(prev => {
            data.push(prev.riskScore || 0);
        });
        
        // Add current data point
        data.push(current.riskScore);
        
        // Add predicted data point
        data.push(predicted.riskScore);

        // Create chart
        if (modalCharts.modalRiskScorePrediction) {
            modalCharts.modalRiskScorePrediction.destroy();
        }
        
        modalCharts.modalRiskScorePrediction = new Chart(ctx, {
            type: 'line',
            data: { 
                labels: timePoints,
                datasets: [
                    {
                        label: 'Risk Score',
                        data: data,
                        backgroundColor: 'rgba(99, 102, 241, 0.1)',
                        borderColor: 'rgb(99, 102, 241)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 6,
                        pointBackgroundColor: timePoints.map((_, i) => i === timePoints.length - 1 ? 'rgba(99, 102, 241, 0.5)' : 'rgb(99, 102, 241)')
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Risk Score'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Scan Period'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Risk Score: ${context.raw.toFixed(1)}`;
                            }
                        }
                    }
                }
            }
        });
        
        // Update insight text
        document.getElementById('riskScorePredictionInsight').innerHTML = 
            `The organizational risk score is projected to ${predicted.riskScore > current.riskScore ? 'increase' : 'decrease'} from 
            <strong>${current.riskScore.toFixed(1)}</strong> to 
            <strong>${predicted.riskScore.toFixed(1)}</strong> 
            (${predicted.riskScore > current.riskScore ? '+' : ''}${(predicted.riskScore - current.riskScore).toFixed(1)}) in the next scan.
            This change represents a ${Math.abs(((predicted.riskScore - current.riskScore) / current.riskScore) * 100).toFixed(1)}% 
            ${predicted.riskScore > current.riskScore ? 'increase' : 'decrease'} in overall security risk.
            ${predicted.riskScore > current.riskScore ? 
                'Immediate attention is recommended to address the growing security risk.' : 
                'Continue current remediation strategies to maintain this positive trend.'}`;
    }

    // Render remediation prediction chart
    function renderModalRemediationPredictionChart() {
        const ctx = document.getElementById('modalRemediationPredictionChart').getContext('2d');
        
        if (!processedData.predictions) {
            document.getElementById('remediationPredictionInsight').textContent = 
                'Prediction data not available. Please ensure you have at least one previous scan for comparison.';
            return;
        }
        
        const current = processedData.executiveSummary.current;
        const timeToRemediate = processedData.predictions.timeToRemediate;
        
        // Create chart
        if (modalCharts.modalRemediationPrediction) {
            modalCharts.modalRemediationPrediction.destroy();
        }
        
        modalCharts.modalRemediationPrediction = new Chart(ctx, {
            type: 'bar',
            data: { 
                labels: ['Critical', 'High', 'Medium', 'Low'],
                datasets: [
                    {
                        label: 'Current Count',
                        data: [
                            current.criticalVulnerabilities,
                            current.highVulnerabilities,
                            current.mediumVulnerabilities,
                            current.lowVulnerabilities
                        ],
                        backgroundColor: 'rgba(99, 102, 241, 0.7)',
                        borderColor: 'rgb(99, 102, 241)',
                        borderWidth: 1,
                        yAxisID: 'y'
                    },
                    {
                        label: 'Days to Remediate',
                        data: [
                            timeToRemediate.critical,
                            timeToRemediate.high,
                            timeToRemediate.medium,
                            timeToRemediate.low
                        ],
                        backgroundColor: 'rgba(249, 115, 22, 0.7)',
                        borderColor: 'rgb(249, 115, 22)',
                        borderWidth: 1,
                        yAxisID: 'y1'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Vulnerability Count'
                        }
                    },
                    y1: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        grid: {
                            drawOnChartArea: false
                        },
                        title: {
                            display: true,
                            text: 'Days to Remediate'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    }
                }
            }
        });
        
        // Calculate total remediation time
        const totalRemediationTime = Math.max(
            timeToRemediate.critical,
            timeToRemediate.high,
            timeToRemediate.medium,
            timeToRemediate.low
        );
        
        // Update insight text
        document.getElementById('remediationPredictionInsight').innerHTML = 
            `Based on historical remediation rates, it will take approximately <strong>${totalRemediationTime} days</strong> to remediate all current vulnerabilities. 
            Critical vulnerabilities can be remediated in <strong>${timeToRemediate.critical} days</strong>, 
            high severity in <strong>${timeToRemediate.high} days</strong>, 
            medium severity in <strong>${timeToRemediate.medium} days</strong>, and 
            low severity in <strong>${timeToRemediate.low} days</strong>. 
            Focusing resources on critical and high severity vulnerabilities first will provide the greatest risk reduction in the shortest time.`;
    }

    // Render trend prediction chart
    function renderModalTrendPredictionChart() {
        const ctx = document.getElementById('modalTrendPredictionChart').getContext('2d');
        
        if (!processedData.predictions) {
            document.getElementById('trendPredictionInsight').textContent = 
                'Prediction data not available. Please ensure you have at least one previous scan for comparison.';
            return;
        }
        
        // Get time points (past, present, future)
        const pastPoints = processedData.executiveSummary.previous.length;
        const futurePoints = 3; // Predict 3 periods into the future
        
        const timePoints = [];
        
        // Add past points
        for (let i = pastPoints - 1; i >= 0; i--) {
            timePoints.push(previousVulnerabilityData[i].label || `Previous ${i + 1}`);
        }
        
        // Add current point
        timePoints.push('Current');
        
        // Add future points
        for (let i = 1; i <= futurePoints; i++) {
            timePoints.push(`Future ${i}`);
        }
        
        // Calculate future predictions
        const totalPredictions = [processedData.executiveSummary.current.totalVulnerabilities];
        const riskScorePredictions = [processedData.executiveSummary.current.riskScore];
        const growthRate = processedData.predictions.vulnerabilityGrowth;
        
        for (let i = 1; i <= futurePoints; i++) {
            const prevTotal = totalPredictions[i - 1];
            const predictedTotal = Math.max(0, Math.round(prevTotal * (1 + growthRate)));
            totalPredictions.push(predictedTotal);
            
            // Simplified risk score prediction based on growth trend
            const prevRiskScore = riskScorePredictions[i - 1];
            riskScorePredictions.push(prevRiskScore * (1 + (growthRate / 2))); // Risk grows more slowly than vuln count
        }
        
        // Historical data
        const historicalTotals = [];
        const historicalRiskScores = [];
        
        for (let i = processedData.executiveSummary.previous.length - 1; i >= 0; i--) {
            const prev = processedData.executiveSummary.previous[i];
            historicalTotals.push(prev.totalVulnerabilities);
            historicalRiskScores.push(prev.riskScore || 0);
        }
        
        // Create datasets
        const datasets = [
            {
                label: 'Total Vulnerabilities',
                data: [...historicalTotals, ...totalPredictions],
                borderColor: 'rgb(239, 68, 68)',
                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                borderWidth: 3,
                yAxisID: 'y',
                fill: true,
                tension: 0.4,
                pointRadius: timePoints.map((_, i) => i >= pastPoints ? 6 : 4),
                pointBackgroundColor: timePoints.map((_, i) => i >= pastPoints ? 'rgba(239, 68, 68, 0.5)' : 'rgb(239, 68, 68)')
            },
            {
                label: 'Risk Score',
                data: [...historicalRiskScores, ...riskScorePredictions],
                borderColor: 'rgb(99, 102, 241)',
                backgroundColor: 'rgba(99, 102, 241, 0.1)',
                borderWidth: 3,
                yAxisID: 'y1',
                fill: true,
                tension: 0.4,
                pointRadius: timePoints.map((_, i) => i >= pastPoints ? 6 : 4),
                pointBackgroundColor: timePoints.map((_, i) => i >= pastPoints ? 'rgba(99, 102, 241, 0.5)' : 'rgb(99, 102, 241)')
            }
        ];

        // Create chart
        if (modalCharts.modalTrendPrediction) {
            modalCharts.modalTrendPrediction.destroy();
        }
        
        modalCharts.modalTrendPrediction = new Chart(ctx, {
            type: 'line',
            data: { 
                labels: timePoints,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Vulnerability Count'
                        }
                    },
                    y1: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        grid: {
                            drawOnChartArea: false
                        },
                        title: {
                            display: true,
                            text: 'Risk Score'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Scan Period'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    annotation: {
                        annotations: {
                            line1: {
                                type: 'line',
                                xMin: pastPoints - 0.5,
                                xMax: pastPoints - 0.5,
                                borderColor: 'rgba(0, 0, 0, 0.3)',
                                borderWidth: 2,
                                borderDash: [6, 6],
                                label: {
                                    content: 'Prediction starts',
                                    enabled: true,
                                    position: 'top'
                                }
                            }
                        }
                    }
                }
            }
        });
        
        // Update insight text
        const futureTotal = totalPredictions[futurePoints];
        const futureRiskScore = riskScorePredictions[futurePoints];
        const currentTotal = processedData.executiveSummary.current.totalVulnerabilities;
        const currentRiskScore = processedData.executiveSummary.current.riskScore;
        
        document.getElementById('trendPredictionInsight').innerHTML = 
            `Based on the current trend with a growth rate of ${(growthRate * 100).toFixed(1)}%, 
            we predict that in ${futurePoints} scan cycles, your total vulnerability count will 
            ${futureTotal > currentTotal ? 'increase' : 'decrease'} to <strong>${futureTotal}</strong> 
            (${futureTotal > currentTotal ? '+' : ''}${futureTotal - currentTotal} vulnerabilities) and your risk score will 
            ${futureRiskScore > currentRiskScore ? 'increase' : 'decrease'} to <strong>${futureRiskScore.toFixed(1)}</strong> 
            (${futureRiskScore > currentRiskScore ? '+' : ''}${(futureRiskScore - currentRiskScore).toFixed(1)} points). 
            ${
                growthRate > 0 ? 
                'To reverse this trend, consider increasing remediation capacity or implementing more proactive security measures.' : 
                'Continue your effective security practices to maintain this positive trend.'
            }`;
    }

    // Export prediction data
    function exportPredictionData(activeTab) {
        let data = [];
        let filename = 'prediction_data.csv';
        
        switch(activeTab) {
            case 'vulnerabilityPrediction':
                data = exportVulnerabilityPredictionData();
                filename = 'vulnerability_prediction_data.csv';
                break;
            case 'riskScorePrediction':
                data = exportRiskScorePredictionData();
                filename = 'risk_score_prediction_data.csv';
                break;
            case 'remediationPrediction':
                data = exportRemediationPredictionData();
                filename = 'remediation_prediction_data.csv';
                break;
            case 'trendPrediction':
                data = exportTrendPredictionData();
                filename = 'trend_prediction_data.csv';
                break;
        }
        
        exportToCSV(data, filename);
    }

    // Export vulnerability prediction data
    function exportVulnerabilityPredictionData() {
        if (!processedData.predictions) return [];
        
        const current = processedData.executiveSummary.current;
        const predicted = processedData.predictions.nextScan;
        
        return [
            { Severity: 'Critical', Current: current.criticalVulnerabilities, Predicted: predicted.critical, Change: predicted.critical - current.criticalVulnerabilities },
            { Severity: 'High', Current: current.highVulnerabilities, Predicted: predicted.high, Change: predicted.high - current.highVulnerabilities },
            { Severity: 'Medium', Current: current.mediumVulnerabilities, Predicted: predicted.medium, Change: predicted.medium - current.mediumVulnerabilities },
            { Severity: 'Low', Current: current.lowVulnerabilities, Predicted: predicted.low, Change: predicted.low - current.lowVulnerabilities },
            { Severity: 'Total', Current: current.totalVulnerabilities, Predicted: predicted.total, Change: predicted.total - current.totalVulnerabilities }
        ];
    }

    // Export risk score prediction data
    function exportRiskScorePredictionData() {
        if (!processedData.predictions) return [];
        
        const current = processedData.executiveSummary.current;
        const predicted = processedData.predictions.nextScan;
        
        return [
            { Metric: 'Risk Score', Current: current.riskScore.toFixed(2), Predicted: predicted.riskScore.toFixed(2), Change: (predicted.riskScore - current.riskScore).toFixed(2) }
        ];
    }

    // Export remediation prediction data
    function exportRemediationPredictionData() {
        if (!processedData.predictions) return [];
        
        const current = processedData.executiveSummary.current;
        const timeToRemediate = processedData.predictions.timeToRemediate;
        
        return [
            { Severity: 'Critical', 'Current Count': current.criticalVulnerabilities, 'Days to Remediate': timeToRemediate.critical },
            { Severity: 'High', 'Current Count': current.highVulnerabilities, 'Days to Remediate': timeToRemediate.high },
            { Severity: 'Medium', 'Current Count': current.mediumVulnerabilities, 'Days to Remediate': timeToRemediate.medium },
            { Severity: 'Low', 'Current Count': current.lowVulnerabilities, 'Days to Remediate': timeToRemediate.low }
        ];
    }

    // Export trend prediction data
    function exportTrendPredictionData() {
        if (!processedData.predictions) return [];
        
        const growthRate = processedData.predictions.vulnerabilityGrowth;
        const futurePoints = 3;
        
        const totalPredictions = [processedData.executiveSummary.current.totalVulnerabilities];
        const riskScorePredictions = [processedData.executiveSummary.current.riskScore];
        
        for (let i = 1; i <= futurePoints; i++) {
            const prevTotal = totalPredictions[i - 1];
            const predictedTotal = Math.max(0, Math.round(prevTotal * (1 + growthRate)));
            totalPredictions.push(predictedTotal);
            
            const prevRiskScore = riskScorePredictions[i - 1];
            riskScorePredictions.push(prevRiskScore * (1 + (growthRate / 2)));
        }
        
        const result = [];
        
        for (let i = 0; i <= futurePoints; i++) {
            result.push({
                Period: i === 0 ? 'Current' : `Future ${i}`,
                'Total Vulnerabilities': totalPredictions[i],
                'Risk Score': riskScorePredictions[i].toFixed(2)
            });
        }
        
        return result;
    }

    // Render risk score modal
    function renderRiskScoreModal() {
        return `
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <h3 class="text-xl font-semibold mb-3">Risk Score Breakdown</h3>
                    <div class="chart-container">
                        <canvas id="modalRiskScoreBreakdownChart"></canvas>
                    </div>
                </div>
                <div>
                    <h3 class="text-xl font-semibold mb-3">Risk Score Components</h3>
                    <div class="space-y-4">
                        ${renderRiskScoreComponents(processedData)}
                    </div>
                    <div class="mt-6 p-4 bg-gray-50 rounded-lg">
                        <h4 class="font-semibold mb-2">Risk Score Formula</h4>
                        <p class="text-sm text-gray-700">The risk score is calculated using a formula that considers:</p>
                        <ul class="text-sm text-gray-700 list-disc list-inside mt-2">
                            <li>Severity distribution of vulnerabilities (weighted by importance)</li>
                            <li>System exposure (unique IP addresses affected)</li>
                            <li>Critical vulnerability ratio (percentage of critical issues)</li>
                            <li>Vulnerability density (vulnerabilities per system)</li>
                            <li>Persistence of vulnerabilities over time</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="mt-6">
                <h3 class="text-xl font-semibold mb-3">Risk Score Trend</h3>
                <div class="chart-container">
                    <canvas id="modalRiskScoreTrendChart"></canvas>
                </div>
            </div>
            
            <div class="mt-6 bg-indigo-50 p-4 rounded-lg">
                <div class="flex items-start">
                    <i class="fas fa-lightbulb text-indigo-700 text-xl mt-1 mr-3"></i>
                    <div>
                        <h3 class="font-bold text-lg text-indigo-700">Risk Reduction Recommendations</h3>
                        <p class="text-sm text-gray-700 mt-2">To improve your risk score most effectively:</p>
                        <ol class="text-sm text-gray-700 list-decimal list-inside mt-2 space-y-1">
                            <li>Address critical vulnerabilities first, with priority on those affecting multiple systems</li>
                            <li>Focus on high-risk business units, particularly those with mission-critical systems</li>
                            <li>Remediate persistent vulnerabilities that have remained for multiple scan cycles</li>
                            <li>Implement security controls to prevent common vulnerability types from recurring</li>
                            <li>Establish regular remediation cycles to prevent accumulation of security debt</li>
                        </ol>
                    </div>
                </div>
            </div>
        `;
    }

    // Initialize risk score modal
    function initializeRiskScoreModal() {
        renderModalRiskScoreBreakdownChart();
        renderModalRiskScoreTrendChart();
    }

    // Render risk score breakdown chart
    function renderModalRiskScoreBreakdownChart() {
        const ctx = document.getElementById('modalRiskScoreBreakdownChart').getContext('2d');
        
        // Calculate component scores
        const current = processedData.executiveSummary.current;
        
        const severityScore = (current.criticalVulnerabilities * 10 + current.highVulnerabilities * 8 + 
                             current.mediumVulnerabilities * 5 + current.lowVulnerabilities * 2) / 
                             (current.totalVulnerabilities || 1);
        
        const exposureScore = Math.min(10, Math.log(current.uniqueIPs.size + 1) / Math.log(10) * 10);
        
        const criticalRatio = current.criticalVulnerabilities / (current.totalVulnerabilities || 1);
        const criticality = criticalRatio * 10;
        
        const vulnerabilityDensity = current.totalVulnerabilities / (current.uniqueIPs.size || 1);
        const densityScore = Math.min(10, vulnerabilityDensity / 5);
        
        const persistenceScore = 5; // Placeholder, would be calculated from actual vulnerability aging data
        
        // Create chart
        if (modalCharts.modalRiskScoreBreakdown) {
            modalCharts.modalRiskScoreBreakdown.destroy();
        }
        
        modalCharts.modalRiskScoreBreakdown = new Chart(ctx, {
            type: 'radar',
            data: {
                labels: [
                    'Severity Distribution',
                    'System Exposure',
                    'Critical Ratio',
                    'Vulnerability Density',
                    'Persistence'
                ],
                datasets: [{
                    label: 'Component Scores',
                    data: [
                        severityScore,
                        exposureScore,
                        criticality,
                        densityScore,
                        persistenceScore
                    ],
                    backgroundColor: 'rgba(99, 102, 241, 0.2)',
                    borderColor: 'rgb(99, 102, 241)',
                    pointBackgroundColor: 'rgb(99, 102, 241)',
                    pointBorderColor: '#fff',
                    pointHoverBackgroundColor: '#fff',
                    pointHoverBorderColor: 'rgb(99, 102, 241)'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                elements: {
                    line: {
                        borderWidth: 3
                    }
                },
                scales: {
                    r: {
                        angleLines: {
                            display: true
                        },
                        suggestedMin: 0,
                        suggestedMax: 10
                    }
                }
            }
        });
    }

    // Render risk score trend chart
    function renderModalRiskScoreTrendChart() {
        const ctx = document.getElementById('modalRiskScoreTrendChart').getContext('2d');
        
        // Get time points
        const timePoints = [];
        
        // Add previous points (in reverse order)
        processedData.executiveSummary.previous.forEach((_, index) => {
            timePoints.push(previousVulnerabilityData[index].label || `Previous ${index + 1}`);
        });
        
        // Add current point
        timePoints.push('Current');
        
        // Create dataset
        const data = [];
        
        // Add previous data points
        processedData.executiveSummary.previous.forEach(prev => {
            data.push(prev.riskScore || 0);
        });
        
        // Add current data point
        data.push(processedData.executiveSummary.current.riskScore);

        // Create chart
        if (modalCharts.modalRiskScoreTrend) {
            modalCharts.modalRiskScoreTrend.destroy();
        }
        
        modalCharts.modalRiskScoreTrend = new Chart(ctx, {
            type: 'line',
            data: { 
                labels: timePoints,
                datasets: [
                    {
                        label: 'Risk Score',
                        data: data,
                        backgroundColor: 'rgba(99, 102, 241, 0.1)',
                        borderColor: 'rgb(99, 102, 241)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Risk Score'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
    }

    // Render comparative analysis modal
    function renderComparativeAnalysisModal() {
        const scanOptions = ['Current Scan']
            .concat(previousVulnerabilityData.map(pv => pv.label))
            .map(label => `<option value="${label}">${label}</option>`)
            .join('');

        return `
            <div class="mb-6">
                <div class="flex flex-col md:flex-row gap-4">
                    <div class="flex-1">
                        <label for="scan1" class="block text-sm font-medium text-gray-700 mb-1">Select first scan:</label>
                        <select id="scan1" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                            ${scanOptions}
                        </select>
                    </div>
                    <div class="flex-1">
                        <label for="scan2" class="block text-sm font-medium text-gray-700 mb-1">Select second scan:</label>
                        <select id="scan2" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                            ${scanOptions}
                        </select>
                    </div>
                    <div class="flex items-end">
                        <button id="compareScansBtn" class="btn btn-primary">Compare Scans</button>
                    </div>
                </div>
            </div>
            
            <div id="comparisonResult">
                <div class="text-center text-gray-500 p-8">
                    Select two scans above and click "Compare Scans" to see a detailed comparison
                </div>
            </div>
        `;
    }

    // Initialize comparative analysis modal
    function initializeComparativeAnalysisModal() {
        document.getElementById('compareScansBtn').addEventListener('click', compareScans);
        
        // Set different default options
        const scan1Select = document.getElementById('scan1');
        const scan2Select = document.getElementById('scan2');
        
        if (scan1Select.options.length > 0) {
            scan1Select.selectedIndex = 0; // Current Scan
        }
        
        if (scan2Select.options.length > 1) {
            scan2Select.selectedIndex = 1; // First previous scan
        }
    }

    // Compare scans
    function compareScans() {
        const scan1Label = document.getElementById('scan1').value;
        const scan2Label = document.getElementById('scan2').value;
        
        if (scan1Label === scan2Label) {
            alert('Please select two different scans to compare.');
            return;
        }
        
        // Get scan data
        const scan1Data = scan1Label === 'Current Scan' ? 
            processedData.executiveSummary.current : 
            processedData.executiveSummary.previous[previousVulnerabilityData.findIndex(pv => pv.label === scan1Label)];
            
        const scan2Data = scan2Label === 'Current Scan' ? 
            processedData.executiveSummary.current : 
            processedData.executiveSummary.previous[previousVulnerabilityData.findIndex(pv => pv.label === scan2Label)];
        
        // Compare data
        const comparison = compareScansData(scan1Data, scan2Data);
        
        // Render comparison
        const comparisonResult = document.getElementById('comparisonResult');
        comparisonResult.innerHTML = `
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <h3 class="text-xl font-semibold mb-3">Overall Comparison</h3>
                    <div class="chart-container">
                        <canvas id="modalComparisonChart"></canvas>
                    </div>
                </div>
                <div>
                    <h3 class="text-xl font-semibold mb-3">Detailed Metrics</h3>
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Metric</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${scan1Label}</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${scan2Label}</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Difference</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
                            ${renderComparisonTableRows(scan1Data, scan2Data, comparison)}
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="mt-6">
                <h3 class="text-xl font-semibold mb-3">Key Findings</h3>
                ${renderComparisonInsights(scan1Label, scan2Label, comparison)}
            </div>
            
            <div class="flex justify-end space-x-2 mt-4">
                <button id="downloadComparisonChart" class="btn btn-secondary flex items-center">
                    <i class="fas fa-download mr-2"></i>Download Chart
                </button>
                <button id="exportComparisonData" class="btn btn-primary flex items-center">
                    <i class="fas fa-file-export mr-2"></i>Export Data
                </button>
            </div>
        `;
        
        // Render comparison chart
        renderModalComparisonChart(scan1Label, scan2Label, scan1Data, scan2Data);
        
        // Add event listeners for buttons
        document.getElementById('downloadComparisonChart').addEventListener('click', function() {
            downloadChart('modalComparisonChart');
        });
        
        document.getElementById('exportComparisonData').addEventListener('click', function() {
            exportComparisonData(scan1Label, scan2Label, scan1Data, scan2Data, comparison);
        });
    }

    // Compare scans data
    function compareScansData(scan1Data, scan2Data) {
        return {
            totalVulnerabilities: scan1Data.totalVulnerabilities - scan2Data.totalVulnerabilities,
            criticalVulnerabilities: scan1Data.criticalVulnerabilities - scan2Data.criticalVulnerabilities,
            highVulnerabilities: scan1Data.highVulnerabilities - scan2Data.highVulnerabilities,
            mediumVulnerabilities: scan1Data.mediumVulnerabilities - scan2Data.mediumVulnerabilities,
            lowVulnerabilities: scan1Data.lowVulnerabilities - scan2Data.lowVulnerabilities,
            uniquePlugins: scan1Data.uniquePlugins.size - scan2Data.uniquePlugins.size,
            uniqueIPs: scan1Data.uniqueIPs.size - scan2Data.uniqueIPs.size,
            riskScore: (scan1Data.riskScore || 0) - (scan2Data.riskScore || 0)
        };
    }

    // Render comparison table rows
    function renderComparisonTableRows(scan1Data, scan2Data, comparison) {
        const metrics = [
            { name: 'Total Vulnerabilities', key: 'totalVulnerabilities' },
            { name: 'Critical Vulnerabilities', key: 'criticalVulnerabilities' },
            { name: 'High Vulnerabilities', key: 'highVulnerabilities' },
            { name: 'Medium Vulnerabilities', key: 'mediumVulnerabilities' },
            { name: 'Low Vulnerabilities', key: 'lowVulnerabilities' },
            { name: 'Unique Vulnerabilities', key: 'uniquePlugins', value1: scan1Data.uniquePlugins.size, value2: scan2Data.uniquePlugins.size },
            { name: 'Unique Systems', key: 'uniqueIPs', value1: scan1Data.uniqueIPs.size, value2: scan2Data.uniqueIPs.size },
            { name: 'Risk Score', key: 'riskScore', value1: scan1Data.riskScore?.toFixed(1) || 'N/A', value2: scan2Data.riskScore?.toFixed(1) || 'N/A', diff: comparison.riskScore?.toFixed(1) }
        ];
        
        return metrics.map(metric => {
            const value1 = metric.value1 !== undefined ? metric.value1 : scan1Data[metric.key];
            const value2 = metric.value2 !== undefined ? metric.value2 : scan2Data[metric.key];
            const diff = metric.diff !== undefined ? metric.diff : comparison[metric.key];
            
            const diffClass = diff > 0 ? 'text-critical' : diff < 0 ? 'text-low' : 'text-gray-500';
            const diffIcon = diff > 0 ? '<i class="fas fa-arrow-up mr-1"></i>' : 
                           diff < 0 ? '<i class="fas fa-arrow-down mr-1"></i>' : 
                           '<i class="fas fa-minus mr-1"></i>';
            
            return `
                <tr>
                    <td class="px-6 py-4 whitespace-nowrap font-medium">${metric.name}</td>
                    <td class="px-6 py-4 whitespace-nowrap">${value1}</td>
                    <td class="px-6 py-4 whitespace-nowrap">${value2}</td>
                    <td class="px-6 py-4 whitespace-nowrap ${diffClass}">${diffIcon}${diff > 0 ? '+' : ''}${diff}</td>
                </tr>
            `;
        }).join('');
    }

    // Render comparison insights
    function renderComparisonInsights(scan1Label, scan2Label, comparison) {
        const totalChange = comparison.totalVulnerabilities;
        const criticalChange = comparison.criticalVulnerabilities;
        const highChange = comparison.highVulnerabilities;
        const riskScoreChange = comparison.riskScore;
        
        const improvedOrDegraded = totalChange < 0 ? 'improved' : totalChange > 0 ? 'degraded' : 'remained stable';
        const increaseOrDecrease = totalChange < 0 ? 'decrease' : 'increase';
        
        return `
            <div class="bg-gray-50 p-4 rounded-lg">
                <ul class="space-y-2">
                    <li class="flex items-start">
                        <i class="fas fa-chart-line ${totalChange > 0 ? 'text-critical' : totalChange < 0 ? 'text-low' : 'text-gray-500'} mt-1 mr-2"></i>
                        <span>Security posture has <strong>${improvedOrDegraded}</strong> between ${scan2Label} and ${scan1Label} with a ${Math.abs(totalChange)} vulnerability ${increaseOrDecrease} (${Math.abs(totalChange / comparison.totalVulnerabilities * 100).toFixed(1)}%).</span>
                    </li>
                    <li class="flex items-start">
                        <i class="fas fa-exclamation-triangle ${criticalChange > 0 ? 'text-critical' : criticalChange < 0 ? 'text-low' : 'text-gray-500'} mt-1 mr-2"></i>
                        <span>Critical vulnerabilities have ${criticalChange < 0 ? 'decreased' : criticalChange > 0 ? 'increased' : 'remained the same'} by ${Math.abs(criticalChange)}.</span>
                    </li>
                    <li class="flex items-start">
                        <i class="fas fa-exclamation-circle ${highChange > 0 ? 'text-high' : highChange < 0 ? 'text-low' : 'text-gray-500'} mt-1 mr-2"></i>
                        <span>High vulnerabilities have ${highChange < 0 ? 'decreased' : highChange > 0 ? 'increased' : 'remained the same'} by ${Math.abs(highChange)}.</span>
                    </li>
                    <li class="flex items-start">
                        <i class="fas fa-shield-alt ${riskScoreChange > 0 ? 'text-critical' : riskScoreChange < 0 ? 'text-low' : 'text-gray-500'} mt-1 mr-2"></i>
                        <span>Overall risk score has ${riskScoreChange < 0 ? 'decreased' : riskScoreChange > 0 ? 'increased' : 'remained the same'} by ${Math.abs(riskScoreChange).toFixed(1)} points.</span>
                    </li>
                    <li class="flex items-start">
                        <i class="fas fa-lightbulb text-yellow-500 mt-1 mr-2"></i>
                        <span>
                            ${totalChange > 0 ? 
                                'Increased vulnerability count indicates growing security risk. Prioritize remediation of critical and high-severity issues.' : 
                                totalChange < 0 ? 
                                'Decreased vulnerability count shows positive remediation progress. Continue current security practices.' : 
                                'Security posture is stable. Maintain vigilance to prevent new vulnerabilities from being introduced.'}
                        </span>
                    </li>
                </ul>
            </div>
        `;
    }

    // Render modal comparison chart
    function renderModalComparisonChart(scan1Label, scan2Label, scan1Data, scan2Data) {
        const ctx = document.getElementById('modalComparisonChart').getContext('2d');
        
        // Create datasets
        const datasets = [
            {
                label: scan1Label,
                data: [
                    scan1Data.criticalVulnerabilities,
                    scan1Data.highVulnerabilities,
                    scan1Data.mediumVulnerabilities,
                    scan1Data.lowVulnerabilities
                ],
                backgroundColor: 'rgba(99, 102, 241, 0.7)',
                borderColor: 'rgb(99, 102, 241)',
                borderWidth: 1
            },
            {
                label: scan2Label,
                data: [
                    scan2Data.criticalVulnerabilities,
                    scan2Data.highVulnerabilities,
                    scan2Data.mediumVulnerabilities,
                    scan2Data.lowVulnerabilities
                ],
                backgroundColor: 'rgba(249, 115, 22, 0.7)',
                borderColor: 'rgb(249, 115, 22)',
                borderWidth: 1
            }
        ];

        // Create chart
        if (modalCharts.modalComparison) {
            modalCharts.modalComparison.destroy();
        }
        
        modalCharts.modalComparison = new Chart(ctx, {
            type: 'bar',
            data: { 
                labels: ['Critical', 'High', 'Medium', 'Low'],
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    title: {
                        display: true,
                        text: `Vulnerability Comparison: ${scan1Label} vs ${scan2Label}`
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Vulnerability Count'
                        }
                    }
                }
            }
        });
    }

    // Export comparison data
    function exportComparisonData(scan1Label, scan2Label, scan1Data, scan2Data, comparison) {
        const metrics = [
            { name: 'Total Vulnerabilities', key: 'totalVulnerabilities' },
            { name: 'Critical Vulnerabilities', key: 'criticalVulnerabilities' },
            { name: 'High Vulnerabilities', key: 'highVulnerabilities' },
            { name: 'Medium Vulnerabilities', key: 'mediumVulnerabilities' },
            { name: 'Low Vulnerabilities', key: 'lowVulnerabilities' },
            { name: 'Unique Vulnerabilities', key: 'uniquePlugins', value1: scan1Data.uniquePlugins.size, value2: scan2Data.uniquePlugins.size },
            { name: 'Unique Systems', key: 'uniqueIPs', value1: scan1Data.uniqueIPs.size, value2: scan2Data.uniqueIPs.size },
            { name: 'Risk Score', key: 'riskScore', value1: scan1Data.riskScore?.toFixed(1) || 'N/A', value2: scan2Data.riskScore?.toFixed(1) || 'N/A', diff: comparison.riskScore?.toFixed(1) }
        ];
        
        const data = metrics.map(metric => {
            const value1 = metric.value1 !== undefined ? metric.value1 : scan1Data[metric.key];
            const value2 = metric.value2 !== undefined ? metric.value2 : scan2Data[metric.key];
            const diff = metric.diff !== undefined ? metric.diff : comparison[metric.key];
            
            return {
                Metric: metric.name,
                [scan1Label]: value1,
                [scan2Label]: value2,
                Difference: diff
            };
        });
        
        exportToCSV(data, 'scan_comparison_data.csv');
    }

    // Download chart
    function downloadChart(chartId) {
        const canvas = document.getElementById(chartId);
        if (!canvas) return;
        
        const link = document.createElement('a');
        link.download = chartId + '.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
    }

    // Export to CSV
    function exportToCSV(data, filename) {
        if (!data || data.length === 0) return;
        
        // Convert to CSV
        const headers = Object.keys(data[0]);
        const csvData = [
            headers.join(','),
            ...data.map(row => headers.map(header => {
                let value = row[header];
                
                // Handle values that need quoting (strings with commas, quotes, or newlines)
                if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
                    // Escape quotes by doubling them
                    value = value.replace(/"/g, '""');
                    // Wrap with quotes
                    value = `"${value}"`;
                }
                
                return value !== undefined && value !== null ? value : '';
            }).join(','))
        ].join('\n');
        
        // Create download link
        const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    // Setup tooltips
    function setupTooltips() {
        // Will be run during initialization
        // No need to implement if tooltips are working by CSS only
    }

    // Export all data
    function exportAllData() {
        // Create a zip file with all the data
        const exportData = {
            executiveSummary: exportExecutiveSummaryData(),
            vulnerabilityTrend: exportOverallTrendData(),
            missionAnalysis: exportMissionTrendData(),
            severityAnalysis: exportSeverityTrendData(),
            pluginAnalysis: exportPluginAnalysisData(),
            ipAnalysis: exportIPAnalysisData(),
            remediatedVulnerabilities: exportRemediatedVulnerabilitiesData(),
            newVulnerabilities: exportNewVulnerabilitiesData(),
            predictions: exportPredictionSummaryData()
        };
        
        // Prompt user to select what to export
        const types = Object.keys(exportData);
        const selectedTypes = types.filter(type => confirm(`Export ${type} data?`));
        
        // Export selected data types
        selectedTypes.forEach(type => {
            exportToCSV(exportData[type], `${type}_data.csv`);
        });
    }

    // Export executive summary data
    function exportExecutiveSummaryData() {
        const current = processedData.executiveSummary.current;
        
        return [
            { Metric: 'Total Vulnerabilities', Value: current.totalVulnerabilities },
            { Metric: 'Critical Vulnerabilities', Value: current.criticalVulnerabilities },
            { Metric: 'High Vulnerabilities', Value: current.highVulnerabilities },
            { Metric: 'Medium Vulnerabilities', Value: current.mediumVulnerabilities },
            { Metric: 'Low Vulnerabilities', Value: current.lowVulnerabilities },
            { Metric: 'Unique Systems', Value: current.uniqueIPs.size },
            { Metric: 'Unique Vulnerabilities', Value: current.uniquePlugins.size },
            { Metric: 'Risk Score', Value: current.riskScore?.toFixed(2) || 'N/A' }
        ];
    }

    // Export plugin analysis data
    function exportPluginAnalysisData() {
        return Array.from(processedData.pluginAnalysis.current.entries())
            .map(([plugin, data]) => ({
                Plugin: plugin,
                Count: data.count,
                Severity: data.severity,
                Category: extractPluginCategory(plugin),
                'Affected Systems': data.ips?.size || 0,
                'Affected Business Units': data.missions?.size || 0
            }))
            .sort((a, b) => b.Count - a.Count);
    }

    // Export IP analysis data
    function exportIPAnalysisData() {
        return Array.from(processedData.ipAnalysis.current.entries())
            .map(([ip, data]) => ({
                'IP Address': ip,
'Total Vulnerabilities': data.count,
                'Critical Vulnerabilities': data.criticalCount,
                'High Vulnerabilities': data.highCount,
                'Medium Vulnerabilities': data.mediumCount,
                'Low Vulnerabilities': data.lowCount,
                'Affected Business Units': data.missions?.size || 0
            }))
            .sort((a, b) => b['Total Vulnerabilities'] - a['Total Vulnerabilities']);
    }

    // Export remediated vulnerabilities data
    function exportRemediatedVulnerabilitiesData() {
        return processedData.diffAnalysis.remediated.map(vuln => ({
            'Vulnerability': vuln['PLUGIN NAME'] || 'N/A',
            'IP Address': vuln['IP ADDRESS'] || 'N/A',
            'Severity': vuln.SEVERITY || 'Unknown',
            'Business Unit': vuln.MISSION || 'Unknown',
            'Asset Type': vuln.ASSET_TYPE || 'Unknown',
            'Status': 'Remediated'
        }));
    }

    // Export new vulnerabilities data
    function exportNewVulnerabilitiesData() {
        return processedData.diffAnalysis.new.map(vuln => ({
            'Vulnerability': vuln['PLUGIN NAME'] || 'N/A',
            'IP Address': vuln['IP ADDRESS'] || 'N/A',
            'Severity': vuln.SEVERITY || 'Unknown',
            'Business Unit': vuln.MISSION || 'Unknown',
            'Asset Type': vuln.ASSET_TYPE || 'Unknown',
            'Status': 'New'
        }));
    }

    // Export prediction summary data
    function exportPredictionSummaryData() {
        if (!processedData.predictions) return [];
        
        const current = processedData.executiveSummary.current;
        const predicted = processedData.predictions.nextScan;
        
        return [
            { Metric: 'Total Vulnerabilities', Current: current.totalVulnerabilities, Predicted: predicted.total, Change: predicted.total - current.totalVulnerabilities },
            { Metric: 'Critical Vulnerabilities', Current: current.criticalVulnerabilities, Predicted: predicted.critical, Change: predicted.critical - current.criticalVulnerabilities },
            { Metric: 'High Vulnerabilities', Current: current.highVulnerabilities, Predicted: predicted.high, Change: predicted.high - current.highVulnerabilities },
            { Metric: 'Medium Vulnerabilities', Current: current.mediumVulnerabilities, Predicted: predicted.medium, Change: predicted.medium - current.mediumVulnerabilities },
            { Metric: 'Low Vulnerabilities', Current: current.lowVulnerabilities, Predicted: predicted.low, Change: predicted.low - current.lowVulnerabilities },
            { Metric: 'Risk Score', Current: current.riskScore.toFixed(2), Predicted: predicted.riskScore.toFixed(2), Change: (predicted.riskScore - current.riskScore).toFixed(2) },
            { Metric: 'Prediction Confidence', Current: 'N/A', Predicted: (predicted.confidence * 100).toFixed(0) + '%', Change: 'N/A' }
        ];
    }

    // Generate report
    function generateReport() {
        // Create a printable version of the dashboard
        const printWindow = window.open('', '_blank');
        
        if (!printWindow) {
            alert('Please allow pop-ups to generate the report.');
            return;
        }
        
        // Write report HTML
        printWindow.document.write(`
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Cybersecurity Vulnerability Assessment Report</title>
                <style>
                    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
                    
                    body {
                        font-family: 'Inter', sans-serif;
                        color: #1f2937;
                        line-height: 1.6;
                        padding: 2rem;
                    }
                    
                    .header {
                        text-align: center;
                        margin-bottom: 2rem;
                        padding-bottom: 1rem;
                        border-bottom: 2px solid #e5e7eb;
                    }
                    
                    .section {
                        margin-bottom: 2rem;
                        page-break-inside: avoid;
                    }
                    
                    .section-title {
                        font-size: 1.5rem;
                        font-weight: 600;
                        margin-bottom: 1rem;
                        padding-bottom: 0.5rem;
                        border-bottom: 1px solid #e5e7eb;
                    }
                    
                    .subsection-title {
                        font-size: 1.25rem;
                        font-weight: 500;
                        margin-bottom: 0.75rem;
                    }
                    
                    table {
                        width: 100%;
                        border-collapse: collapse;
                        margin-bottom: 1rem;
                    }
                    
                    th, td {
                        padding: 0.75rem;
                        text-align: left;
                        border: 1px solid #e5e7eb;
                    }
                    
                    th {
                        background-color: #f3f4f6;
                        font-weight: 600;
                    }
                    
                    .summary-box {
                        background-color: #f3f4f6;
                        padding: 1rem;
                        border-radius: 0.5rem;
                        margin-bottom: 1rem;
                    }
                    
                    .severity-critical { color: #ef4444; }
                    .severity-high { color: #f97316; }
                    .severity-medium { color: #eab308; }
                    .severity-low { color: #22c55e; }
                    
                    .grid {
                        display: grid;
                        grid-template-columns: repeat(2, 1fr);
                        gap: 1rem;
                    }
                    
                    .metric-card {
                        background-color: #f9fafb;
                        padding: 1rem;
                        border-radius: 0.5rem;
                        border-left: 4px solid #4f46e5;
                    }
                    
                    .metric-value {
                        font-size: 1.5rem;
                        font-weight: 700;
                    }
                    
                    .trend-up { color: #ef4444; }
                    .trend-down { color: #22c55e; }
                    
                    .footer {
                        margin-top: 2rem;
                        padding-top: 1rem;
                        border-top: 2px solid #e5e7eb;
                        text-align: center;
                        font-size: 0.875rem;
                        color: #6b7280;
                    }
                    
                    @media print {
                        body {
                            padding: 0;
                        }
                        
                        .section {
                            page-break-inside: avoid;
                        }
                    }
                </style>
            </head>
            <body>
                <div class="header">
                    <h1>Cybersecurity Vulnerability Assessment Report</h1>
                    <p>Generated on ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}</p>
                </div>
                
                <div class="section">
                    <h2 class="section-title">Executive Summary</h2>
                    <div class="summary-box">
                        <p>
                            This report provides a comprehensive analysis of the organization's cybersecurity posture based on the most recent vulnerability scan.
                            The overall risk score is <strong>${processedData.executiveSummary.current.riskScore?.toFixed(1) || 'N/A'}</strong> out of 10.
                            ${processedData.executiveSummary.previous.length > 0 ? `This represents a 
                            ${processedData.executiveSummary.current.riskScoreChange?.improved ? 'decrease' : 'increase'} of 
                            ${Math.abs(processedData.executiveSummary.current.riskScoreChange?.absolute || 0).toFixed(1)} points compared to the previous scan.` : ''}
                        </p>
                        <p>
                            A total of <strong>${processedData.executiveSummary.current.totalVulnerabilities}</strong> vulnerabilities were identified across 
                            <strong>${processedData.executiveSummary.current.uniqueIPs.size}</strong> systems. This includes 
                            <strong class="severity-critical">${processedData.executiveSummary.current.criticalVulnerabilities} critical</strong>, 
                            <strong class="severity-high">${processedData.executiveSummary.current.highVulnerabilities} high</strong>, 
                            <strong class="severity-medium">${processedData.executiveSummary.current.mediumVulnerabilities} medium</strong>, and 
                            <strong class="severity-low">${processedData.executiveSummary.current.lowVulnerabilities} low</strong> severity vulnerabilities.
                        </p>
                    </div>
                    
                    <h3 class="subsection-title">Key Metrics</h3>
                    <div class="grid">
                        ${renderReportMetricCard('Total Vulnerabilities', processedData.executiveSummary.current.totalVulnerabilities, processedData.comparison[0]?.totalVulnerabilities)}
                        ${renderReportMetricCard('Critical Vulnerabilities', processedData.executiveSummary.current.criticalVulnerabilities, processedData.comparison[0]?.criticalVulnerabilities)}
                        ${renderReportMetricCard('High Vulnerabilities', processedData.executiveSummary.current.highVulnerabilities, processedData.comparison[0]?.highVulnerabilities)}
                        ${renderReportMetricCard('Unique Systems', processedData.executiveSummary.current.uniqueIPs.size, processedData.comparison[0]?.uniqueIPs)}
                    </div>
                </div>
                
                <div class="section">
                    <h2 class="section-title">Business Unit Analysis</h2>
                    <p>
                        The following business units are most impacted by vulnerabilities:
                    </p>
                    <table>
                        <thead>
                            <tr>
                                <th>Business Unit</th>
                                <th>Total</th>
                                <th>Critical</th>
                                <th>High</th>
                                <th>Risk Score</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${renderReportMissionRows(processedData.missionAnalysis.current)}
                        </tbody>
                    </table>
                </div>
                
                <div class="section">
                    <h2 class="section-title">Top Vulnerabilities</h2>
                    <p>
                        The following vulnerabilities are the most prevalent and should be prioritized for remediation:
                    </p>
                    <table>
                        <thead>
                            <tr>
                                <th>Vulnerability</th>
                                <th>Count</th>
                                <th>Severity</th>
                                <th>Affected Systems</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${renderReportTopVulnerabilities(processedData.pluginAnalysis.current)}
                        </tbody>
                    </table>
                </div>
                
                <div class="section">
                    <h2 class="section-title">Remediation Progress</h2>
                    <p>
                        Since the previous scan, the following remediation progress has been made:
                    </p>
                    <div class="grid">
                        ${renderReportRemediationCard('Remediated', processedData.diffAnalysis.remediated.length)}
                        ${renderReportRemediationCard('New', processedData.diffAnalysis.new.length)}
                        ${renderReportRemediationCard('Persisting', processedData.diffAnalysis.persisting.length)}
                        ${renderReportRemediationCard('Total Change', processedData.diffAnalysis.remediated.length - processedData.diffAnalysis.new.length)}
                    </div>
                </div>
                
                <div class="section">
                    <h2 class="section-title">Recommendations</h2>
                    <ol>
                        ${renderReportRecommendations(processedData)}
                    </ol>
                </div>
                
                <div class="footer">
                    <p>This report is confidential and intended for authorized personnel only.</p>
                    <p>Enterprise Cybersecurity Risk Intelligence Dashboard</p>
                </div>
            </body>
            </html>
        `);
        
        // Functions to render report components
        function renderReportMetricCard(title, value, change) {
            const trendClass = change?.improved ? 'trend-down' : 'trend-up';
            const trendIcon = change?.improved ? '▼' : '▲';
            const trendHtml = change ? `<div class="${trendClass}">${trendIcon} ${Math.abs(change.absolute)} (${Math.abs(change.percentage)}%)</div>` : '';
            
            return `
                <div class="metric-card">
                    <div>${title}</div>
                    <div class="metric-value">${value.toLocaleString()}</div>
                    ${trendHtml}
                </div>
            `;
        }
        
        function renderReportMissionRows(missionData) {
            // Convert Map to array and sort by risk score
            const missions = Array.from(missionData.entries())
                .map(([mission, data]) => ({
                    mission,
                    totalVulnerabilities: data.totalVulnerabilities,
                    criticalVulnerabilities: data.criticalVulnerabilities,
                    highVulnerabilities: data.highVulnerabilities,
                    riskScore: data.riskScore || 0
                }))
                .sort((a, b) => b.riskScore - a.riskScore)
                .slice(0, 5); // Top 5 missions
            
            return missions.map(mission => `
                <tr>
                    <td>${mission.mission}</td>
                    <td>${mission.totalVulnerabilities}</td>
                    <td class="severity-critical">${mission.criticalVulnerabilities}</td>
                    <td class="severity-high">${mission.highVulnerabilities}</td>
                    <td>${mission.riskScore.toFixed(1)}</td>
                </tr>
            `).join('');
        }
        
        function renderReportTopVulnerabilities(pluginData) {
            // Convert Map to array and sort by count
            const plugins = Array.from(pluginData.entries())
                .map(([plugin, data]) => ({
                    plugin,
                    count: data.count,
                    severity: data.severity,
                    ips: data.ips?.size || 0
                }))
                .sort((a, b) => b.count - a.count)
                .slice(0, 10); // Top 10 plugins
            
            return plugins.map(plugin => {
                let severityClass = '';
                switch(plugin.severity.toLowerCase()) {
                    case 'critical': severityClass = 'severity-critical'; break;
                    case 'high': severityClass = 'severity-high'; break;
                    case 'medium': severityClass = 'severity-medium'; break;
                    case 'low': severityClass = 'severity-low'; break;
                }
                
                return `
                    <tr>
                        <td>${plugin.plugin}</td>
                        <td>${plugin.count}</td>
                        <td class="${severityClass}">${plugin.severity}</td>
                        <td>${plugin.ips}</td>
                    </tr>
                `;
            }).join('');
        }
        
        function renderReportRemediationCard(title, value) {
            const isPositive = (title === 'Remediated' || (title === 'Total Change' && value > 0));
            const isNegative = (title === 'New' || (title === 'Total Change' && value < 0));
            const valueClass = isPositive ? 'severity-low' : isNegative ? 'severity-critical' : '';
            const prefix = title === 'Total Change' && value > 0 ? '+' : '';
            
            return `
                <div class="metric-card">
                    <div>${title}</div>
                    <div class="metric-value ${valueClass}">${prefix}${value.toLocaleString()}</div>
                </div>
            `;
        }
        
        function renderReportRecommendations(data) {
            const recommendations = [];
            
            // Add critical recommendations
            if (data.executiveSummary.current.criticalVulnerabilities > 0) {
                recommendations.push(`
                    <li>
                        <strong>Immediately remediate all ${data.executiveSummary.current.criticalVulnerabilities} critical vulnerabilities.</strong> 
                        These pose the greatest risk to the organization and should be addressed as soon as possible.
                    </li>
                `);
            }
            
            // Add high recommendations
            if (data.executiveSummary.current.highVulnerabilities > 0) {
                recommendations.push(`
                    <li>
                        <strong>Prioritize remediation of ${data.executiveSummary.current.highVulnerabilities} high severity vulnerabilities.</strong> 
                        Focus on those affecting mission-critical systems and business units.
                    </li>
                `);
            }
            
            // Add business unit specific recommendations
            const topMission = Array.from(data.missionAnalysis.current.entries())
                .sort((a, b) => b[1].riskScore - a[1].riskScore)[0];
            
            if (topMission) {
                recommendations.push(`
                    <li>
                        <strong>Focus resources on the ${topMission[0]} business unit.</strong> 
                        With a risk score of ${topMission[1].riskScore?.toFixed(1) || 'N/A'} and 
                        ${topMission[1].criticalVulnerabilities} critical vulnerabilities, this represents the highest risk area.
                    </li>
                `);
            }
            
            // Add persistent vulnerability recommendation
            if (data.diffAnalysis.persisting.length > 0) {
                recommendations.push(`
                    <li>
                        <strong>Address ${data.diffAnalysis.persisting.length} persistent vulnerabilities from previous scans.</strong> 
                        Long-standing vulnerabilities indicate potential challenges in the remediation process that should be investigated.
                    </li>
                `);
            }
            
            // Add general recommendations
            recommendations.push(`
                <li>
                    <strong>Establish a regular vulnerability scanning and remediation cycle.</strong> 
                    This will help identify and address new vulnerabilities before they can be exploited.
                </li>
            `);
            
            recommendations.push(`
                <li>
                    <strong>Implement security awareness training for all staff.</strong> 
                    Many vulnerabilities can be prevented through proper security practices and awareness.
                </li>
            `);
            
            return recommendations.join('');
        }
        
        // Finish and print
        printWindow.document.close();
        setTimeout(() => printWindow.print(), 1000);
    }

    // Initialize charts
    function initializeCharts() {
        Chart.register(ChartDataLabels);
        
        // Default chart.js settings
        Chart.defaults.font.family = "'Inter', 'Helvetica', 'Arial', sans-serif";
        Chart.defaults.font.size = 12;
        Chart.defaults.plugins.legend.labels.usePointStyle = true;
        Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        Chart.defaults.plugins.tooltip.padding = 10;
        Chart.defaults.plugins.tooltip.cornerRadius = 6;
        Chart.defaults.plugins.tooltip.titleFont = { weight: 'bold' };
        
        // Global datalabels settings
        Chart.defaults.plugins.datalabels = {
            color: '#fff',
            font: {
                weight: 'bold'
            },
            formatter: (value, ctx) => {
                if (ctx.chart.config.type === 'pie' || ctx.chart.config.type === 'doughnut') {
                    let sum = 0;
                    let dataArr = ctx.chart.data.datasets[0].data;
                    dataArr.map(data => {
                        sum += data;
                    });
                    let percentage = ((value * 100) / sum).toFixed(1) + "%";
                    return percentage;
                } else {
                    return null; // Hide labels for other chart types by default
                }
            },
            display: function(context) {
                // Only show datalabels for pie/doughnut charts and if the value is significant
                return (context.chart.config.type === 'pie' || context.chart.config.type === 'doughnut') && 
                        context.dataset.data[context.dataIndex] > 0;
            }
        };
    }
</script>